var app = (function () {
    'use strict';

    function noop$1() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$1;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active$1 = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active$1 += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active$1 -= deleted;
            if (!active$1)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active$1)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    function create_animation(node, from, fn, params) {
        if (!from)
            return noop$1;
        const to = node.getBoundingClientRect();
        if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
            return noop$1;
        const { delay = 0, duration = 300, easing = identity, 
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = now() + delay, 
        // @ts-ignore todo:
        end = start_time + duration, tick = noop$1, css } = fn(node, { from, to }, params);
        let running = true;
        let started = false;
        let name;
        function start() {
            if (css) {
                name = create_rule(node, 0, 1, duration, delay, easing, css);
            }
            if (!delay) {
                started = true;
            }
        }
        function stop() {
            if (css)
                delete_rule(node, name);
            running = false;
        }
        loop(now => {
            if (!started && now >= start_time) {
                started = true;
            }
            if (started && now >= end) {
                tick(1, 0);
                stop();
            }
            if (!running) {
                return false;
            }
            if (started) {
                const p = now - start_time;
                const t = 0 + 1 * easing(p / duration);
                tick(t, 1 - t);
            }
            return true;
        });
        start();
        tick(0, 1);
        return stop;
    }
    function fix_position(node) {
        const style = getComputedStyle(node);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
            const { width, height } = style;
            const a = node.getBoundingClientRect();
            node.style.position = 'absolute';
            node.style.width = width;
            node.style.height = height;
            add_transform(node, a);
        }
    }
    function add_transform(node, a) {
        const b = node.getBoundingClientRect();
        if (a.left !== b.left || a.top !== b.top) {
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
        block.f();
        outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind$1(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$1;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$1;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse$1(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.42.4 */

    function create_else_block$c(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (244:0) {#if componentParams}
    function create_if_block$i(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    function create_fragment$10(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$i, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location$1 = derived(loc, $loc => $loc.location);
    derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse$1(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.__svelte_spa_router_scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$$, create_fragment$10, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});
    	}
    }

    const notification = writable();

    async function toaster (node, sessionKey) {
      const unsubscribe = notification.subscribe(value => {
        if (!value) { return }
        node.dispatchEvent(
          new CustomEvent('notify', { detail: value })
        );
        notification.set();
      });

      await tick();
      try {
        const existing = JSON.parse(
          sessionStorage.getItem(sessionKey)
        );
        for (const n of existing) {
          notification.set(n);
        }
      } catch (e) {
      } finally {
        try {
          sessionStorage.removeItem(sessionKey);
        } catch (e2) {}
      }

      return {
        destroy () {
          unsubscribe();
        }
      }
    }

    /* node_modules/@beyonk/svelte-notifications/Notifications.svelte generated by Svelte v3.42.4 */

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (4:6) {#if toast.persist}
    function create_if_block$h(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[7](/*toast*/ ctx[9]);
    	}

    	return {
    		c() {
    			button = element("button");
    			button.textContent = "✕";
    			attr(button, "class", "close svelte-vlqkf6");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", click_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (2:2) {#each toasts as toast (toast.id)}
    function create_each_block$n(key_1, ctx) {
    	let li;
    	let t0;
    	let div0;
    	let t1_value = /*toast*/ ctx[9].message + "";
    	let t1;
    	let t2;
    	let div1;
    	let t3;
    	let li_outro;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*toast*/ ctx[9].persist && create_if_block$h(ctx);

    	function animationend_handler() {
    		return /*animationend_handler*/ ctx[8](/*toast*/ ctx[9]);
    	}

    	return {
    		key: key_1,
    		first: null,
    		c() {
    			li = element("li");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			attr(div0, "class", "content svelte-vlqkf6");
    			attr(div1, "class", "progress svelte-vlqkf6");
    			set_style(div1, "animation-duration", /*toast*/ ctx[9].timeout + "ms");
    			attr(li, "class", "toast svelte-vlqkf6");
    			set_style(li, "background", /*toast*/ ctx[9].background);
    			this.first = li;
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			if (if_block) if_block.m(li, null);
    			append(li, t0);
    			append(li, div0);
    			append(div0, t1);
    			append(li, t2);
    			append(li, div1);
    			append(li, t3);
    			current = true;

    			if (!mounted) {
    				dispose = listen(div1, "animationend", animationend_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*toast*/ ctx[9].persist) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					if_block.m(li, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((!current || dirty & /*toasts*/ 2) && t1_value !== (t1_value = /*toast*/ ctx[9].message + "")) set_data(t1, t1_value);

    			if (!current || dirty & /*toasts*/ 2) {
    				set_style(div1, "animation-duration", /*toast*/ ctx[9].timeout + "ms");
    			}

    			if (!current || dirty & /*toasts*/ 2) {
    				set_style(li, "background", /*toast*/ ctx[9].background);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (li_outro) li_outro.end(1);
    			current = true;
    		},
    		o(local) {
    			li_outro = create_out_transition(li, animateOut, {});
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			if (if_block) if_block.d();
    			if (detaching && li_outro) li_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$$(ctx) {
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let toaster_action;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*toasts*/ ctx[1];
    	const get_key = ctx => /*toast*/ ctx[9].id;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$n(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$n(key, child_ctx));
    	}

    	return {
    		c() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(ul, "class", "toasts svelte-vlqkf6");
    		},
    		m(target, anchor) {
    			insert(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(toaster_action = toaster.call(null, ul, /*sessionKey*/ ctx[0])),
    					listen(ul, "notify", /*createToast*/ ctx[2])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*toasts, maybePurge, purge*/ 26) {
    				each_value = /*toasts*/ ctx[1];
    				group_outros();
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$n, null, get_each_context$n);
    				check_outros();
    			}

    			if (toaster_action && is_function(toaster_action.update) && dirty & /*sessionKey*/ 1) toaster_action.update.call(null, /*sessionKey*/ ctx[0]);
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function animateOut(node, { delay = 0, duration = 1000 }) {
    	return {
    		delay,
    		duration,
    		css: t => `opacity: ${(t - 0.7) * 1}; transform-origin: top right;`
    	};
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { themes = {
    		danger: '#bb2124',
    		success: '#22bb33',
    		warning: '#f0ad4e',
    		info: '#5bc0de',
    		default: '#aaaaaa'
    	} } = $$props;

    	let { timeout = 3000 } = $$props;
    	let { sessionKey = 'byk-toasts' } = $$props;
    	let toasts = [];

    	function createToast({ detail }) {
    		const { message, type, options = {} } = detail;
    		const background = themes[type] || themes.default;
    		const persist = options.persist;
    		const computedTimeout = options.persist ? 0 : options.timeout || timeout;
    		const id = Math.random().toString(36).replace(/[^a-z]+/g, '');

    		try {
    			sessionStorage.setItem(sessionKey, JSON.stringify([
    				...JSON.parse(sessionStorage.getItem(sessionKey) || '[]'),
    				{ ...detail, id }
    			]));
    		} catch(e) {
    			
    		}

    		$$invalidate(1, toasts = [
    			{
    				id,
    				message,
    				background,
    				persist,
    				timeout: computedTimeout,
    				width: '100%'
    			},
    			...toasts
    		]);
    	}

    	function maybePurge(toast) {
    		!toast.persist && purge(toast.id);
    	}

    	function purge(id) {
    		const filter = t => t.id !== id;
    		$$invalidate(1, toasts = toasts.filter(filter));

    		try {
    			sessionStorage.setItem(sessionKey, JSON.stringify(JSON.parse(sessionStorage.getItem(sessionKey) || '[]').filter(filter)));
    		} catch(e) {
    			
    		}
    	}

    	const click_handler = toast => purge(toast.id);
    	const animationend_handler = toast => maybePurge(toast);

    	$$self.$$set = $$props => {
    		if ('themes' in $$props) $$invalidate(5, themes = $$props.themes);
    		if ('timeout' in $$props) $$invalidate(6, timeout = $$props.timeout);
    		if ('sessionKey' in $$props) $$invalidate(0, sessionKey = $$props.sessionKey);
    	};

    	return [
    		sessionKey,
    		toasts,
    		createToast,
    		maybePurge,
    		purge,
    		themes,
    		timeout,
    		click_handler,
    		animationend_handler
    	];
    }

    class Notifications extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$_, create_fragment$$, safe_not_equal, { themes: 5, timeout: 6, sessionKey: 0 });
    	}
    }

    function parseLegacyOptions (options) {
      return typeof options === 'number' ? { timeout: options } : options
    }

    function send (message, type = 'default', options) {
      notification.set({ type, message, options: parseLegacyOptions(options) });
    }

    function danger (message, options) {
      send(message, 'danger', options);
    }

    function warning (message, options) {
      send(message, 'warning', options);
    }

    function info (message, options) {
      send(message, 'info', options);
    }

    function success (message, options) {
      send(message, 'success', options);
    }

    // List of nodes to update
    const nodes = [];

    // Current location
    let location;

    // Function that updates all nodes marking the active ones
    function checkActive(el) {
        const matchesLocation = el.pattern.test(location);
        toggleClasses(el, el.className, matchesLocation);
        toggleClasses(el, el.inactiveClassName, !matchesLocation);
    }

    function toggleClasses(el, className, shouldAdd) {
        (className || '').split(' ').forEach((cls) => {
            if (!cls) {
                return
            }
            // Remove the class firsts
            el.node.classList.remove(cls);

            // If the pattern doesn't match, then set the class
            if (shouldAdd) {
                el.node.classList.add(cls);
            }
        });
    }

    // Listen to changes in the location
    loc.subscribe((value) => {
        // Update the location
        location = value.location + (value.querystring ? '?' + value.querystring : '');

        // Update all nodes
        nodes.map(checkActive);
    });

    /**
     * @typedef {Object} ActiveOptions
     * @property {string|RegExp} [path] - Path expression that makes the link active when matched (must start with '/' or '*'); default is the link's href
     * @property {string} [className] - CSS class to apply to the element when active; default value is "active"
     */

    /**
     * Svelte Action for automatically adding the "active" class to elements (links, or any other DOM element) when the current location matches a certain path.
     * 
     * @param {HTMLElement} node - The target node (automatically set by Svelte)
     * @param {ActiveOptions|string|RegExp} [opts] - Can be an object of type ActiveOptions, or a string (or regular expressions) representing ActiveOptions.path.
     * @returns {{destroy: function(): void}} Destroy function
     */
    function active(node, opts) {
        // Check options
        if (opts && (typeof opts == 'string' || (typeof opts == 'object' && opts instanceof RegExp))) {
            // Interpret strings and regular expressions as opts.path
            opts = {
                path: opts
            };
        }
        else {
            // Ensure opts is a dictionary
            opts = opts || {};
        }

        // Path defaults to link target
        if (!opts.path && node.hasAttribute('href')) {
            opts.path = node.getAttribute('href');
            if (opts.path && opts.path.length > 1 && opts.path.charAt(0) == '#') {
                opts.path = opts.path.substring(1);
            }
        }

        // Default class name
        if (!opts.className) {
            opts.className = 'active';
        }

        // If path is a string, it must start with '/' or '*'
        if (!opts.path || 
            typeof opts.path == 'string' && (opts.path.length < 1 || (opts.path.charAt(0) != '/' && opts.path.charAt(0) != '*'))
        ) {
            throw Error('Invalid value for "path" argument')
        }

        // If path is not a regular expression already, make it
        const {pattern} = typeof opts.path == 'string' ?
            parse$1(opts.path) :
            {pattern: opts.path};

        // Add the node to the list
        const el = {
            node,
            className: opts.className,
            inactiveClassName: opts.inactiveClassName,
            pattern
        };
        nodes.push(el);

        // Trigger the action right away
        checkActive(el);

        return {
            // When the element is destroyed, remove it from the list
            destroy() {
                nodes.splice(nodes.indexOf(el), 1);
            }
        }
    }

    var docs = [
    	{
    		firstname: "Nissy",
    		lastname: "Tunno",
    		email: "ntunnol4@princeton.edu",
    		city: "Shikeng",
    		street: "Blue Bill Park",
    		house_number: "6",
    		telephone_number: "6187969517",
    		subscribed_to_newsletter: false,
    		_id: "7e2f6d14-4137-564e-86e7-ca46dcf8cf74",
    		id: 1,
    		type: "customer",
    		registration_date: 1608940800000,
    		renewed_on: 0,
    		postal_code: 21810,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615075200000,
    		highlight: ""
    	},
    	{
    		firstname: "Zilvia",
    		lastname: "Heaviside",
    		email: "zheavisidef8@qq.com",
    		city: "Abeokuta",
    		street: "Evergreen",
    		house_number: "851",
    		telephone_number: "9511662807",
    		subscribed_to_newsletter: false,
    		_id: "f8ed73b5-fd2b-58be-8fbb-d7bd0fa38ee2",
    		id: 2,
    		type: "customer",
    		registration_date: 1605139200000,
    		renewed_on: 0,
    		postal_code: 92750,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616803200000,
    		highlight: ""
    	},
    	{
    		firstname: "Quincey",
    		lastname: "MacAllaster",
    		email: "qmacallaster6n@independent.co.uk",
    		city: "Złoty Stok",
    		postal_code: 48601,
    		street: "Oxford",
    		house_number: "66908",
    		telephone_number: "5742228330",
    		subscribed_to_newsletter: true,
    		_id: "f58638c6-3c92-5bc3-bd42-223eca736f1c",
    		id: 3,
    		type: "customer",
    		registration_date: 1598313600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614816000000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Enrica",
    		lastname: "Luetkemeyers",
    		email: "eluetkemeyerspq@acquirethisname.com",
    		city: "Karang Kulon",
    		street: "Ruskin",
    		house_number: "49",
    		telephone_number: "8479421710",
    		subscribed_to_newsletter: false,
    		_id: "4a2e21d8-12a9-5e07-aee1-953b48399652",
    		id: 4,
    		type: "customer",
    		registration_date: 1586995200000,
    		renewed_on: 0,
    		postal_code: 63473,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616457600000,
    		highlight: ""
    	},
    	{
    		firstname: "Lay",
    		lastname: "Ogelsby",
    		email: "logelsbylw@wordpress.com",
    		city: "Banjar Mambalkajanan",
    		street: "Iowa",
    		house_number: "800",
    		telephone_number: "7174438962",
    		subscribed_to_newsletter: true,
    		_id: "3d04a648-8149-5ddd-a33d-bb9671c8f642",
    		id: 5,
    		type: "customer",
    		registration_date: 1586822400000,
    		renewed_on: 0,
    		postal_code: 84522,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615680000000,
    		highlight: ""
    	},
    	{
    		firstname: "Baldwin",
    		lastname: "Sheilds",
    		email: "bsheildsoi@netscape.com",
    		city: "Valday",
    		postal_code: 86534,
    		street: "Lakewood Gardens",
    		house_number: "28",
    		telephone_number: "6489598645",
    		subscribed_to_newsletter: true,
    		_id: "0ead260b-faef-5d6d-ba89-f0114427ad47",
    		id: 6,
    		type: "customer",
    		registration_date: 1601078400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615507200000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Kennett",
    		lastname: "McNish",
    		email: "kmcnishhm@stumbleupon.com",
    		city: "Paris 07",
    		postal_code: 21630,
    		street: "Clarendon",
    		house_number: "6437",
    		telephone_number: "3364449161",
    		remark: "dui maecenas tristique est et",
    		subscribed_to_newsletter: true,
    		_id: "412e2c9d-0f62-5aa9-b1fa-ebec4e8d25e0",
    		id: 7,
    		type: "customer",
    		registration_date: 1602806400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616284800000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Nikaniki",
    		lastname: "Bursnell",
    		email: "nbursnell8z@house.gov",
    		city: "Verba",
    		postal_code: 68753,
    		street: "Lighthouse Bay",
    		house_number: "7",
    		telephone_number: "3223053856",
    		subscribed_to_newsletter: false,
    		_id: "5375c2e5-1eb8-58f1-ae58-c4cde86a245f",
    		id: 8,
    		type: "customer",
    		registration_date: 1567036800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614902400000,
    		highlight: ""
    	},
    	{
    		firstname: "Adler",
    		lastname: "Murie",
    		email: "amurieqj@state.gov",
    		city: "Tibro",
    		postal_code: 40318,
    		street: "Fairview",
    		house_number: "685",
    		telephone_number: "6309947304",
    		subscribed_to_newsletter: false,
    		_id: "9a818eb9-b7ca-51e3-a940-8c4d7090a444",
    		id: 9,
    		type: "customer",
    		registration_date: 1567728000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615248000000,
    		highlight: ""
    	},
    	{
    		firstname: "Michele",
    		lastname: "Maceur",
    		email: "mmaceurj6@weebly.com",
    		city: "Springfield",
    		postal_code: 21356,
    		street: "Grim",
    		house_number: "8604",
    		telephone_number: "7819757001",
    		subscribed_to_newsletter: true,
    		_id: "1d8db2e5f-22fe-5bd5-aa2c-8b07c1cf213a",
    		id: 10,
    		type: "customer",
    		registration_date: 1583884800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614643200000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Conroy",
    		lastname: "Kubicek",
    		email: "ckubicekq8@addthis.com",
    		city: "Provins",
    		postal_code: 92067,
    		street: "Center",
    		house_number: "9",
    		telephone_number: "9873270667",
    		subscribed_to_newsletter: true,
    		_id: "19f352587-c808-54b6-9835-1b569ae98f23",
    		id: 11,
    		type: "customer",
    		registration_date: 1570060800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615939200000,
    		highlight: ""
    	},
    	{
    		firstname: "Romeo",
    		lastname: "Marushak",
    		email: "rmarushakjo@icio.us",
    		city: "Rogowo",
    		postal_code: 77053,
    		street: "Mayer",
    		house_number: "6922",
    		telephone_number: "4832908208",
    		subscribed_to_newsletter: true,
    		_id: "129abe6ac-4b97-5127-9254-e4cc438caa80",
    		id: 12,
    		type: "customer",
    		registration_date: 1601424000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615939200000,
    		highlight: ""
    	},
    	{
    		firstname: "Claudianus",
    		lastname: "Fevier",
    		email: "cfevierde@xing.com",
    		city: "Nong Phok",
    		postal_code: 23811,
    		street: "Clemons",
    		house_number: "278",
    		telephone_number: "2069133956",
    		subscribed_to_newsletter: true,
    		_id: "1fcd45fd1-893f-5063-959b-3f4217c31b49",
    		id: 13,
    		type: "customer",
    		registration_date: 1599696000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615852800000,
    		highlight: ""
    	},
    	{
    		firstname: "Zea",
    		lastname: "Daville",
    		email: "zdaville8l@macromedia.com",
    		city: "Budapest",
    		postal_code: 46222,
    		street: "Mockingbird",
    		house_number: "8",
    		telephone_number: "1706083031",
    		subscribed_to_newsletter: false,
    		_id: "1a7632ae4-420a-5ffe-9202-3fe491662072",
    		id: 14,
    		type: "customer",
    		registration_date: 1568764800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615507200000,
    		highlight: ""
    	},
    	{
    		firstname: "Garek",
    		lastname: "Janikowski",
    		email: "gjanikowski6w@digg.com",
    		city: "Juhaynah",
    		street: "Raven",
    		house_number: "46054",
    		telephone_number: "5761735353",
    		remark: "luctus et ultrices",
    		subscribed_to_newsletter: false,
    		_id: "1cdbc3f74-9482-5cf0-8b4a-b59b1ab60605",
    		id: 15,
    		type: "customer",
    		registration_date: 1564876800000,
    		renewed_on: 0,
    		postal_code: 19530,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616112000000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Kale",
    		lastname: "Lainge",
    		email: "klainged1@qq.com",
    		city: "Timba Lauk",
    		street: "Schlimgen",
    		house_number: "03714",
    		telephone_number: "5921089325",
    		remark: "morbi odio odio elementum eu interdum eu",
    		subscribed_to_newsletter: false,
    		_id: "1265f3208-739e-564e-baf1-2d2ed78662fe",
    		id: 16,
    		type: "customer",
    		registration_date: 1592611200000,
    		renewed_on: 0,
    		postal_code: 49213,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616198400000,
    		highlight: ""
    	},
    	{
    		firstname: "Martguerita",
    		lastname: "Cruft",
    		email: "mcruftnm@devhub.com",
    		city: "Arroio Grande",
    		postal_code: 19960,
    		street: "Roxbury",
    		house_number: "957",
    		telephone_number: "5265199920",
    		subscribed_to_newsletter: false,
    		_id: "63b17439e-665a-5d4b-8f1d-6289ce1b83d5",
    		id: 60,
    		type: "customer",
    		registration_date: 1592611200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: ""
    	},
    	{
    		firstname: "Jeana",
    		lastname: "Collihole",
    		email: "jcolliholeqs@go.com",
    		city: "Zhukovo",
    		postal_code: 11832,
    		street: "Lotheville",
    		house_number: "615",
    		telephone_number: "1237584292",
    		subscribed_to_newsletter: false,
    		_id: "1a5cbb347-f3b5-5b7c-ac01-94ac710d1793",
    		id: 18,
    		type: "customer",
    		registration_date: 1556323200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614988800000,
    		highlight: ""
    	},
    	{
    		firstname: "Zorine",
    		lastname: "Stichel",
    		email: "zstichelby@goo.ne.jp",
    		city: "Carapo",
    		street: "Burning Wood",
    		house_number: "9",
    		telephone_number: "1117290665",
    		subscribed_to_newsletter: false,
    		_id: "16b998ef7-3c74-50a3-90ce-536621a2a470",
    		id: 19,
    		type: "customer",
    		registration_date: 1608595200000,
    		renewed_on: 0,
    		postal_code: 80629,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616716800000,
    		highlight: ""
    	},
    	{
    		firstname: "Fax",
    		lastname: "Moneypenny",
    		email: "fmoneypennyka@w3.org",
    		city: "Bol’shaya Setun’",
    		postal_code: 92795,
    		street: "Heffernan",
    		house_number: "6798",
    		telephone_number: "2892685720",
    		subscribed_to_newsletter: true,
    		_id: "2e5455327-fe25-52e9-a755-f1f197639774",
    		id: 20,
    		type: "customer",
    		registration_date: 1573689600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Jacquie",
    		lastname: "Costanza",
    		email: "jcostanza6k@dyndns.org",
    		city: "Glasgow",
    		postal_code: 25284,
    		street: "Pleasure",
    		house_number: "1",
    		telephone_number: "5476825732",
    		subscribed_to_newsletter: false,
    		_id: "3cf832bcb-0f69-5cbf-b7af-c1ee9255874e",
    		id: 30,
    		type: "customer",
    		registration_date: 1570665600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: ""
    	},
    	{
    		firstname: "Tiphanie",
    		lastname: "Macauley",
    		email: "tmacauleypo@nytimes.com",
    		city: "Daming",
    		street: "Sutteridge",
    		house_number: "84679",
    		telephone_number: "9085448531",
    		subscribed_to_newsletter: false,
    		_id: "27b62deaa-1842-57de-b967-567a496870b9",
    		id: 22,
    		type: "customer",
    		registration_date: 1560643200000,
    		renewed_on: 0,
    		postal_code: 65039,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614988800000,
    		highlight: ""
    	},
    	{
    		firstname: "Ronna",
    		lastname: "Jiggins",
    		email: "rjigginse3@ebay.com",
    		city: "Ancahuasi",
    		street: "Oak",
    		house_number: "2673",
    		telephone_number: "6963406050",
    		subscribed_to_newsletter: true,
    		_id: "270edf7ba-6009-56b3-916e-384ddb3fb780",
    		id: 23,
    		type: "customer",
    		registration_date: 1587168000000,
    		renewed_on: 0,
    		postal_code: 65445,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616025600000,
    		highlight: ""
    	},
    	{
    		firstname: "Adrianne",
    		lastname: "Thomkins",
    		email: "athomkins2x@smh.com.au",
    		city: "Havana",
    		street: "Farragut",
    		house_number: "5441",
    		telephone_number: "3683299884",
    		subscribed_to_newsletter: false,
    		_id: "2d1e8d177-95d1-5c86-8ebe-83866b17851f",
    		id: 24,
    		type: "customer",
    		registration_date: 1611532800000,
    		renewed_on: 0,
    		postal_code: 75196,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614729600000,
    		highlight: ""
    	},
    	{
    		firstname: "Alisa",
    		lastname: "Kindred",
    		email: "akindreddm@exblog.jp",
    		city: "Quellouno",
    		street: "Clemons",
    		house_number: "8",
    		telephone_number: "3967432551",
    		subscribed_to_newsletter: true,
    		_id: "2b6074fc2-095b-5ed3-9a94-9041215f48b1",
    		id: 25,
    		type: "customer",
    		registration_date: 1593561600000,
    		renewed_on: 0,
    		postal_code: 12656,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616112000000,
    		highlight: ""
    	},
    	{
    		firstname: "Piggy",
    		lastname: "Methringham",
    		email: "pmethringhamm5@buzzfeed.com",
    		city: "Malanville",
    		street: "Corry",
    		house_number: "6145",
    		telephone_number: "7739808177",
    		subscribed_to_newsletter: false,
    		_id: "2cd008802-80b5-5df5-a782-09c070f8d122",
    		id: 26,
    		type: "customer",
    		registration_date: 1598659200000,
    		renewed_on: 0,
    		postal_code: 84674,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615248000000,
    		highlight: ""
    	},
    	{
    		firstname: "Christiano",
    		lastname: "Jaqueme",
    		email: "cjaquemecy@netlog.com",
    		city: "Huangjindong",
    		street: "Bluestem",
    		house_number: "5",
    		telephone_number: "7972262708",
    		subscribed_to_newsletter: false,
    		_id: "2e2c9a563-5402-5794-8229-11297a8969cc",
    		id: 27,
    		type: "customer",
    		registration_date: 1599091200000,
    		renewed_on: 0,
    		postal_code: 79663,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615852800000,
    		highlight: ""
    	},
    	{
    		firstname: "Maryanna",
    		lastname: "Grahl",
    		email: "mgrahlq5@house.gov",
    		city: "Mariestad",
    		postal_code: 12423,
    		street: "Caliangt",
    		house_number: "07746",
    		telephone_number: "5865800348",
    		subscribed_to_newsletter: false,
    		_id: "2bd6ddebc-9f56-5977-8b2e-990fa3d5e23f",
    		id: 28,
    		type: "customer",
    		registration_date: 1598659200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: ""
    	},
    	{
    		firstname: "Ellis",
    		lastname: "Clapperton",
    		email: "eclapperton57@ox.ac.uk",
    		city: "Batouri",
    		street: "Rutledge",
    		house_number: "5370",
    		telephone_number: "3007668408",
    		remark: "rhoncus aliquam lacus morbi quis tortor id",
    		subscribed_to_newsletter: true,
    		_id: "2360ce38b-f9f1-5f0b-b3c8-ab7353023e7e",
    		id: 29,
    		type: "customer",
    		registration_date: 1556755200000,
    		renewed_on: 0,
    		postal_code: 75162,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615852800000,
    		highlight: ""
    	},
    	{
    		firstname: "Jacquie",
    		lastname: "Costanza",
    		email: "jcostanza6k@dyndns.org",
    		city: "Glasgow",
    		postal_code: 25284,
    		street: "Pleasure",
    		house_number: "1",
    		telephone_number: "5476825732",
    		subscribed_to_newsletter: false,
    		_id: "317d7be25-ef99-5486-82e8-bebf8c137394",
    		id: 30,
    		type: "customer",
    		registration_date: 1570665600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: ""
    	},
    	{
    		firstname: "Susann",
    		lastname: "Sunderland",
    		email: "ssunderlandlm@behance.net",
    		city: "Guarapari",
    		postal_code: 22229,
    		street: "Browning",
    		house_number: "4",
    		telephone_number: "1556410065",
    		subscribed_to_newsletter: false,
    		_id: "36e2b568a-60ab-5917-8e5a-79dc830bcf64",
    		id: 31,
    		type: "customer",
    		registration_date: 1608336000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614643200000,
    		highlight: ""
    	},
    	{
    		firstname: "Carly",
    		lastname: "Cornwell",
    		email: "ccornwell8e@ed.gov",
    		city: "Na'ale",
    		street: "Golf",
    		house_number: "9602",
    		telephone_number: "7371856075",
    		subscribed_to_newsletter: true,
    		_id: "3b0b3d95d-be1d-5642-ba97-e6997739fb05",
    		id: 32,
    		type: "customer",
    		registration_date: 1564444800000,
    		renewed_on: 0,
    		postal_code: 91998,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616889600000,
    		highlight: ""
    	},
    	{
    		firstname: "Ronica",
    		lastname: "Phifer",
    		email: "rphiferoz@usa.gov",
    		city: "Dengnan",
    		street: "Eggendart",
    		house_number: "9458",
    		telephone_number: "6305604608",
    		subscribed_to_newsletter: true,
    		_id: "358c7e58a-0d11-5626-a587-0e8a6727196c",
    		id: 33,
    		type: "customer",
    		registration_date: 1605830400000,
    		renewed_on: 0,
    		postal_code: 79854,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614556800000,
    		highlight: "rgb(131, 235, 52)"
    	},
    	{
    		firstname: "Rustie",
    		lastname: "Dalglish",
    		email: "rdalglishlk@canalblog.com",
    		city: "Nālūt",
    		street: "Little Fleur",
    		house_number: "6",
    		telephone_number: "6538308624",
    		subscribed_to_newsletter: false,
    		_id: "3392483b6-7974-53ae-b167-2cac31dfc69e",
    		id: 34,
    		type: "customer",
    		registration_date: 1588550400000,
    		renewed_on: 0,
    		postal_code: 96677,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: ""
    	},
    	{
    		firstname: "Latrena",
    		lastname: "Slym",
    		email: "lslymqr@studiopress.com",
    		city: "Zhengdun",
    		street: "Toban",
    		house_number: "918",
    		telephone_number: "6949167944",
    		subscribed_to_newsletter: true,
    		_id: "3fe83f0d0-6cc1-5ea0-9b5c-63b746180dbc",
    		id: 35,
    		type: "customer",
    		registration_date: 1608595200000,
    		renewed_on: 0,
    		postal_code: 58234,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615334400000,
    		highlight: ""
    	},
    	{
    		firstname: "Prisca",
    		lastname: "Mitchener",
    		email: "pmitchenerda@blogspot.com",
    		city: "Berëzovka",
    		postal_code: 98783,
    		street: "Elka",
    		house_number: "6384",
    		telephone_number: "8692116051",
    		subscribed_to_newsletter: true,
    		_id: "65e231748-02b7-5d02-bc8f-76e8b160fbb2",
    		id: 65,
    		type: "customer",
    		registration_date: 1587254400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616716800000,
    		highlight: "rgb(131, 235, 52)"
    	},
    	{
    		firstname: "Virginia",
    		lastname: "Rosbrough",
    		email: "vrosbroughe2@ucla.edu",
    		city: "Orkney",
    		postal_code: 21203,
    		street: "Heath",
    		house_number: "1",
    		telephone_number: "6105929660",
    		subscribed_to_newsletter: false,
    		_id: "3a6801d21-6a7a-56e0-80f9-0d84723e37ca",
    		id: 37,
    		type: "customer",
    		registration_date: 1604448000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614816000000,
    		highlight: ""
    	},
    	{
    		firstname: "Pat",
    		lastname: "Tofful",
    		email: "ptoffulf1@icio.us",
    		city: "Maogang",
    		street: "Tomscot",
    		house_number: "840",
    		telephone_number: "3408564528",
    		subscribed_to_newsletter: false,
    		_id: "350d67f2d-180b-590d-a100-bf75e26fef16",
    		id: 38,
    		type: "customer",
    		registration_date: 1592697600000,
    		renewed_on: 0,
    		postal_code: 28319,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615420800000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Rockey",
    		lastname: "Broadbent",
    		email: "rbroadbentey@geocities.com",
    		city: "Fuying",
    		street: "Kropf",
    		house_number: "45",
    		telephone_number: "8737230430",
    		remark: "bibendum felis sed",
    		subscribed_to_newsletter: false,
    		_id: "37996de63-001c-5733-bac0-b66ea6dc6e18",
    		id: 39,
    		type: "customer",
    		registration_date: 1562457600000,
    		renewed_on: 0,
    		postal_code: 95568,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615161600000,
    		highlight: ""
    	},
    	{
    		firstname: "Ravid",
    		lastname: "Barbrick",
    		email: "rbarbrick6m@flavors.me",
    		city: "Nice",
    		postal_code: 17385,
    		street: "Doe Crossing",
    		house_number: "682",
    		telephone_number: "2851403193",
    		subscribed_to_newsletter: true,
    		_id: "4a4ff5c0b-c1d7-50ef-bab3-c28c273eba9c",
    		id: 40,
    		type: "customer",
    		registration_date: 1614470400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: ""
    	},
    	{
    		firstname: "Dulcea",
    		lastname: "Fumagall",
    		email: "dfumagallf9@printfriendly.com",
    		city: "Kozel’shchyna",
    		street: "Weeping Birch",
    		house_number: "62",
    		telephone_number: "1451626543",
    		remark: "pede lobortis ligula sit amet eleifend pede",
    		subscribed_to_newsletter: false,
    		_id: "8779c3b3e-da0d-5ed1-a3e4-a69dc1201dd6",
    		id: 88,
    		type: "customer",
    		registration_date: 1571702400000,
    		renewed_on: 0,
    		postal_code: 85352,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Willette",
    		lastname: "Fieldgate",
    		email: "wfieldgateco@mysql.com",
    		city: "Hongcao",
    		street: "5th",
    		house_number: "5",
    		telephone_number: "3914167287",
    		subscribed_to_newsletter: false,
    		_id: "418fbf298-4f8e-529f-ace6-e26f2eab4352",
    		id: 42,
    		type: "customer",
    		registration_date: 1586822400000,
    		renewed_on: 0,
    		postal_code: 79551,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616284800000,
    		highlight: ""
    	},
    	{
    		firstname: "Ravid",
    		lastname: "Conre",
    		email: "rconremk@answers.com",
    		city: "Debar",
    		postal_code: 66591,
    		street: "Carey",
    		house_number: "4",
    		telephone_number: "3156842097",
    		subscribed_to_newsletter: true,
    		_id: "4e3d07aa8-da99-5b51-a625-478a9cdf9fb1",
    		id: 43,
    		type: "customer",
    		registration_date: 1595376000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Jacinthe",
    		lastname: "Glanester",
    		email: "jglanester1l@europa.eu",
    		city: "Sindong",
    		street: "Stuart",
    		house_number: "2",
    		telephone_number: "8585537584",
    		subscribed_to_newsletter: false,
    		_id: "421d9a06e-e26c-5df5-b025-c7b2be2d4092",
    		id: 44,
    		type: "customer",
    		registration_date: 1562112000000,
    		renewed_on: 0,
    		postal_code: 70790,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614729600000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Elisabetta",
    		lastname: "Dowdle",
    		email: "edowdlebu@businessinsider.com",
    		city: "Haiyu",
    		street: "Lerdahl",
    		house_number: "508",
    		telephone_number: "8747036789",
    		subscribed_to_newsletter: true,
    		_id: "4e31ec1fc-2dbf-5eee-8df5-fbbcc7fdeeb4",
    		id: 45,
    		type: "customer",
    		registration_date: 1590105600000,
    		renewed_on: 0,
    		postal_code: 56191,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615593600000,
    		highlight: ""
    	},
    	{
    		firstname: "Rori",
    		lastname: "Breslauer",
    		email: "rbreslauerr6@nasa.gov",
    		city: "Portel",
    		postal_code: 60146,
    		street: "Mitchell",
    		house_number: "99669",
    		telephone_number: "9203299507",
    		subscribed_to_newsletter: false,
    		_id: "49ece0cc1-8106-5009-baa1-51fdc9016dc0",
    		id: 46,
    		type: "customer",
    		registration_date: 1580601600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616889600000,
    		highlight: ""
    	},
    	{
    		firstname: "Fred",
    		lastname: "MacAndie",
    		email: "fmacandiep2@tinyurl.com",
    		city: "Puńsk",
    		postal_code: 51572,
    		street: "Steensland",
    		house_number: "63",
    		telephone_number: "1719526668",
    		subscribed_to_newsletter: true,
    		_id: "46380aea5-f1bb-58e5-b742-6e3decea18c7",
    		id: 47,
    		type: "customer",
    		registration_date: 1597017600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616025600000,
    		highlight: ""
    	},
    	{
    		firstname: "L;urette",
    		lastname: "Como",
    		email: "lcomoqu@independent.co.uk",
    		city: "Lahat",
    		street: "Delaware",
    		house_number: "333",
    		telephone_number: "2569559477",
    		subscribed_to_newsletter: true,
    		_id: "4d8abda05-819b-571c-bdcb-f199970bf39c",
    		id: 48,
    		type: "customer",
    		registration_date: 1605916800000,
    		renewed_on: 0,
    		postal_code: 44345,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614816000000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Pattie",
    		lastname: "Beddingham",
    		email: "pbeddinghamla@usatoday.com",
    		city: "Jambu",
    		street: "Northland",
    		house_number: "3",
    		telephone_number: "6151878923",
    		subscribed_to_newsletter: true,
    		_id: "476c45668-8a5c-5a76-a101-c8706edcdf3f",
    		id: 49,
    		type: "customer",
    		registration_date: 1584921600000,
    		renewed_on: 0,
    		postal_code: 89828,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615939200000,
    		highlight: ""
    	},
    	{
    		firstname: "Ham",
    		lastname: "Markussen",
    		email: "hmarkussen5i@fc2.com",
    		city: "Tamnag",
    		postal_code: 38234,
    		street: "Wayridge",
    		house_number: "80",
    		telephone_number: "4594890926",
    		remark: "luctus cum sociis",
    		subscribed_to_newsletter: false,
    		_id: "5a75f48cb-d8c6-5557-8872-978e11c7fc30",
    		id: 50,
    		type: "customer",
    		registration_date: 1584230400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: "rgb(131, 235, 52)"
    	},
    	{
    		firstname: "Missie",
    		lastname: "Crockett",
    		email: "mcrockettj5@networkadvertising.org",
    		city: "Vila Nova da Baronia",
    		postal_code: 91863,
    		street: "Browning",
    		house_number: "5197",
    		telephone_number: "5986241534",
    		subscribed_to_newsletter: true,
    		_id: "526c2d78b-10ca-58b3-a98b-ee8bdac23b08",
    		id: 51,
    		type: "customer",
    		registration_date: 1587945600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616284800000,
    		highlight: ""
    	},
    	{
    		firstname: "Philippa",
    		lastname: "Sames",
    		email: "psames3r@nifty.com",
    		city: "Chashnikovo",
    		postal_code: 14528,
    		street: "Independence",
    		house_number: "9",
    		telephone_number: "9231351931",
    		subscribed_to_newsletter: false,
    		_id: "58c964a9b-c00b-5b38-b219-375fa8d7514d",
    		id: 52,
    		type: "customer",
    		registration_date: 1616889600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616457600000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Prince",
    		lastname: "Ridding",
    		email: "pridding94@netlog.com",
    		city: "Stockholm",
    		postal_code: 60472,
    		street: "Monterey",
    		house_number: "7747",
    		telephone_number: "7256295226",
    		subscribed_to_newsletter: true,
    		_id: "5fa54cdb9-88a4-5bc0-824f-2ade87b8088e",
    		id: 53,
    		type: "customer",
    		registration_date: 1610928000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615248000000,
    		highlight: ""
    	},
    	{
    		firstname: "Trescha",
    		lastname: "Quesne",
    		email: "tquesne9g@csmonitor.com",
    		city: "Jablonec nad Nisou",
    		postal_code: 51056,
    		street: "Burning Wood",
    		house_number: "8645",
    		telephone_number: "8074604503",
    		subscribed_to_newsletter: false,
    		_id: "5237e5fa5-1eea-5c59-a703-7bf4aa9f2206",
    		id: 54,
    		type: "customer",
    		registration_date: 1568246400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615075200000,
    		highlight: ""
    	},
    	{
    		firstname: "Holli",
    		lastname: "Gabby",
    		email: "hgabbyhn@wordpress.com",
    		city: "Qianjia",
    		street: "American Ash",
    		house_number: "57",
    		telephone_number: "1745044269",
    		remark: "neque duis bibendum morbi non quam nec dui luctus rutrum",
    		subscribed_to_newsletter: true,
    		_id: "5b27745d3-f2b0-5d48-b118-b8e61d0b282d",
    		id: 55,
    		type: "customer",
    		registration_date: 1612051200000,
    		renewed_on: 0,
    		postal_code: 52697,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614902400000,
    		highlight: ""
    	},
    	{
    		firstname: "Jo",
    		lastname: "Face",
    		email: "jfacelv@multiply.com",
    		city: "Biskamzha",
    		postal_code: 80407,
    		street: "Schlimgen",
    		house_number: "60501",
    		telephone_number: "4855925050",
    		subscribed_to_newsletter: false,
    		_id: "5af90201b-657b-505e-a555-673914071375",
    		id: 56,
    		type: "customer",
    		registration_date: 1591574400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615420800000,
    		highlight: ""
    	},
    	{
    		firstname: "Clive",
    		lastname: "Edgley",
    		email: "cedgley1d@tuttocitta.it",
    		city: "Kurayoshi",
    		postal_code: 26815,
    		street: "Monument",
    		house_number: "88618",
    		telephone_number: "8624573518",
    		subscribed_to_newsletter: true,
    		_id: "50c0b6448-e1b5-5120-b951-fd2fea3010f2",
    		id: 57,
    		type: "customer",
    		registration_date: 1585785600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616630400000,
    		highlight: ""
    	},
    	{
    		firstname: "Federica",
    		lastname: "Langstone",
    		email: "flangstoneh2@imdb.com",
    		city: "Hongyan",
    		street: "Duke",
    		house_number: "3",
    		telephone_number: "5758393683",
    		subscribed_to_newsletter: true,
    		_id: "5cea3993b-e1d4-5bdf-b7e8-a2a10f58160b",
    		id: 58,
    		type: "customer",
    		registration_date: 1564531200000,
    		renewed_on: 0,
    		postal_code: 90660,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615593600000,
    		highlight: ""
    	},
    	{
    		firstname: "Cristina",
    		lastname: "Orrice",
    		email: "corricegu@angelfire.com",
    		city: "La Mohammedia",
    		street: "Northwestern",
    		house_number: "8",
    		telephone_number: "2399567455",
    		subscribed_to_newsletter: false,
    		_id: "507c066d5-2900-5336-8a25-94511feb0281",
    		id: 59,
    		type: "customer",
    		registration_date: 1612915200000,
    		renewed_on: 0,
    		postal_code: 89250,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615852800000,
    		highlight: ""
    	},
    	{
    		firstname: "Martguerita",
    		lastname: "Cruft",
    		email: "mcruftnm@devhub.com",
    		city: "Arroio Grande",
    		postal_code: 19960,
    		street: "Roxbury",
    		house_number: "957",
    		telephone_number: "5265199920",
    		subscribed_to_newsletter: false,
    		_id: "69b2db8f1-b060-565b-96d7-ed207775668f",
    		id: 60,
    		type: "customer",
    		registration_date: 1592611200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: ""
    	},
    	{
    		firstname: "Dall",
    		lastname: "Attyeo",
    		email: "dattyeoml@skype.com",
    		city: "Kabīrwāla",
    		postal_code: 49113,
    		street: "Kipling",
    		house_number: "4235",
    		telephone_number: "6476359443",
    		subscribed_to_newsletter: true,
    		_id: "69a58e7e8-a2af-5b9e-8eda-60465b07fc3f",
    		id: 61,
    		type: "customer",
    		registration_date: 1605139200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615161600000,
    		highlight: ""
    	},
    	{
    		firstname: "Helyn",
    		lastname: "Hurling",
    		email: "hhurlingej@storify.com",
    		city: "Baishuitan",
    		street: "Old Gate",
    		house_number: "33",
    		telephone_number: "9994070428",
    		subscribed_to_newsletter: true,
    		_id: "6cc6544b1-40ea-5275-95cb-4852593d9221",
    		id: 62,
    		type: "customer",
    		registration_date: 1610409600000,
    		renewed_on: 0,
    		postal_code: 55135,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614816000000,
    		highlight: ""
    	},
    	{
    		firstname: "Ephrem",
    		lastname: "Franz",
    		email: "efranz2z@guardian.co.uk",
    		city: "Quy Đạt",
    		street: "Comanche",
    		house_number: "92245",
    		telephone_number: "8057275524",
    		subscribed_to_newsletter: false,
    		_id: "6585b1715-b9d1-53de-8489-4aa2f63a44a3",
    		id: 63,
    		type: "customer",
    		registration_date: 1611446400000,
    		renewed_on: 0,
    		postal_code: 90416,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615939200000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Dunn",
    		lastname: "Smyth",
    		email: "dsmythq4@amazonaws.com",
    		city: "Rustam jo Goth",
    		postal_code: 34271,
    		street: "Calypso",
    		house_number: "1885",
    		telephone_number: "5344915612",
    		subscribed_to_newsletter: true,
    		_id: "6b17f9c8f-4732-5255-8d4e-d64b4f826b2a",
    		id: 64,
    		type: "customer",
    		registration_date: 1569196800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615420800000,
    		highlight: ""
    	},
    	{
    		firstname: "Prisca",
    		lastname: "Mitchener",
    		email: "pmitchenerda@blogspot.com",
    		city: "Berëzovka",
    		postal_code: 98783,
    		street: "Elka",
    		house_number: "6384",
    		telephone_number: "8692116051",
    		subscribed_to_newsletter: true,
    		_id: "63c24db51-8f97-5eea-bf01-5657596a3d97",
    		id: 65,
    		type: "customer",
    		registration_date: 1587254400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616716800000,
    		highlight: "rgb(131, 235, 52)"
    	},
    	{
    		firstname: "Hendrik",
    		lastname: "Clunan",
    		email: "hclunanhp@hc360.com",
    		city: "Darkton",
    		street: "Anthes",
    		house_number: "21",
    		telephone_number: "4554178902",
    		subscribed_to_newsletter: false,
    		_id: "601b8cd54-0693-557b-8492-e222af6c2c04",
    		id: 66,
    		type: "customer",
    		registration_date: 1581292800000,
    		renewed_on: 0,
    		postal_code: 29588,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616025600000,
    		highlight: ""
    	},
    	{
    		firstname: "Winni",
    		lastname: "Windridge",
    		email: "wwindridgepk@huffingtonpost.com",
    		city: "Nebug",
    		postal_code: 66788,
    		street: "Dwight",
    		house_number: "976",
    		telephone_number: "6814491994",
    		remark: "nam nulla integer pede",
    		subscribed_to_newsletter: false,
    		_id: "6d81d2f51-563c-586a-92fc-de607891653c",
    		id: 67,
    		type: "customer",
    		registration_date: 1589068800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614556800000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Charlotte",
    		lastname: "Bourges",
    		email: "cbourgesfi@amazonaws.com",
    		city: "Carson City",
    		postal_code: 27488,
    		street: "Thackeray",
    		house_number: "2984",
    		telephone_number: "7751917136",
    		subscribed_to_newsletter: true,
    		_id: "694049be4-7469-5288-a47d-a9871173a4ce",
    		id: 68,
    		type: "customer",
    		registration_date: 1560988800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615248000000,
    		highlight: ""
    	},
    	{
    		firstname: "Vergil",
    		lastname: "Chadwell",
    		email: "vchadwellmr@stumbleupon.com",
    		city: "Tabunok",
    		postal_code: 32922,
    		street: "Mallard",
    		house_number: "464",
    		telephone_number: "5293198615",
    		subscribed_to_newsletter: true,
    		_id: "65b2824d8-49b4-5e2c-bc76-34b80280d762",
    		id: 69,
    		type: "customer",
    		registration_date: 1571184000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: ""
    	},
    	{
    		firstname: "Roddy",
    		lastname: "Maltby",
    		email: "rmaltby75@blogspot.com",
    		city: "Igreja",
    		postal_code: 67938,
    		street: "Mayer",
    		house_number: "16316",
    		telephone_number: "5164800572",
    		subscribed_to_newsletter: false,
    		_id: "712804277-7be9-5ab8-a043-41d548e308d2",
    		id: 70,
    		type: "customer",
    		registration_date: 1569369600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616457600000,
    		highlight: ""
    	},
    	{
    		firstname: "Sena",
    		lastname: "Kendle",
    		email: "skendle2@sourceforge.net",
    		city: "Kolbuszowa",
    		postal_code: 24547,
    		street: "Sheridan",
    		house_number: "63",
    		telephone_number: "5258167037",
    		subscribed_to_newsletter: true,
    		_id: "7d3263fd7-ac16-52e8-95e1-813477d60987",
    		id: 71,
    		type: "customer",
    		registration_date: 1579910400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615075200000,
    		highlight: ""
    	},
    	{
    		firstname: "Ker",
    		lastname: "Waything",
    		email: "kwaything2o@prweb.com",
    		city: "El Espino",
    		street: "Mccormick",
    		house_number: "7731",
    		telephone_number: "6742829100",
    		subscribed_to_newsletter: false,
    		_id: "72060c4ea-5888-538a-9c38-1b25e76d43c5",
    		id: 72,
    		type: "customer",
    		registration_date: 1597708800000,
    		renewed_on: 0,
    		postal_code: 86437,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614643200000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Janey",
    		lastname: "Kaley",
    		email: "jkaleyfk@biglobe.ne.jp",
    		city: "Wangren",
    		street: "Coleman",
    		house_number: "5346",
    		telephone_number: "3051525272",
    		subscribed_to_newsletter: true,
    		_id: "702ca9477-c3fc-5352-be5a-af05c860a6ae",
    		id: 73,
    		type: "customer",
    		registration_date: 1565222400000,
    		renewed_on: 0,
    		postal_code: 33282,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615420800000,
    		highlight: ""
    	},
    	{
    		firstname: "Phyllys",
    		lastname: "Blenkiron",
    		email: "pblenkironal@cdbaby.com",
    		city: "Gaya",
    		street: "Cody",
    		house_number: "83",
    		telephone_number: "6805267107",
    		subscribed_to_newsletter: true,
    		_id: "731e0c3ed-15ad-5222-838c-b358c78cd07c",
    		id: 74,
    		type: "customer",
    		registration_date: 1608163200000,
    		renewed_on: 0,
    		postal_code: 69042,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615507200000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Magdaia",
    		lastname: "Curlis",
    		email: "mcurlisq0@nih.gov",
    		city: "Pagangan",
    		postal_code: 42003,
    		street: "Dennis",
    		house_number: "20255",
    		telephone_number: "5885921531",
    		subscribed_to_newsletter: true,
    		_id: "7ed250c4d-a054-5abe-ade7-5fd5b8a8ddd2",
    		id: 75,
    		type: "customer",
    		registration_date: 1611532800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616716800000,
    		highlight: ""
    	},
    	{
    		firstname: "Wolfgang",
    		lastname: "Seville",
    		email: "wsevillejf@dmoz.org",
    		city: "Hitachi-Naka",
    		postal_code: 87115,
    		street: "Orin",
    		house_number: "2777",
    		telephone_number: "1277353453",
    		subscribed_to_newsletter: true,
    		_id: "75a2121e2-ef62-5445-9d33-71413c968326",
    		id: 76,
    		type: "customer",
    		registration_date: 1610150400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615852800000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Tim",
    		lastname: "Spare",
    		email: "tsparep0@amazon.co.jp",
    		city: "Huagai",
    		street: "Blue Bill Park",
    		house_number: "007",
    		telephone_number: "9195402483",
    		subscribed_to_newsletter: false,
    		_id: "7f023d256-05c9-5d4b-8035-cef3f88d442c",
    		id: 77,
    		type: "customer",
    		registration_date: 1592092800000,
    		renewed_on: 0,
    		postal_code: 10500,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616544000000,
    		highlight: "rgb(131, 235, 52)"
    	},
    	{
    		firstname: "Eddie",
    		lastname: "Camillo",
    		email: "ecamillol5@hexun.com",
    		city: "Yancheng",
    		street: "Artisan",
    		house_number: "881",
    		telephone_number: "4335114644",
    		subscribed_to_newsletter: false,
    		_id: "7f4d7c17d-91ff-5a44-afd9-d75345dff29f",
    		id: 78,
    		type: "customer",
    		registration_date: 1574899200000,
    		renewed_on: 0,
    		postal_code: 74393,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615939200000,
    		highlight: ""
    	},
    	{
    		firstname: "Napoleon",
    		lastname: "Strangeways",
    		email: "nstrangeways7@imageshack.us",
    		city: "Halayhay",
    		postal_code: 53007,
    		street: "Fieldstone",
    		house_number: "40",
    		telephone_number: "2156728800",
    		subscribed_to_newsletter: false,
    		_id: "78905d2d2-c782-58b0-a92a-444f7158c87b",
    		id: 79,
    		type: "customer",
    		registration_date: 1597363200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614729600000,
    		highlight: ""
    	},
    	{
    		firstname: "Rona",
    		lastname: "Solman",
    		email: "rsolman73@un.org",
    		city: "Pindobaçu",
    		postal_code: 34416,
    		street: "Tony",
    		house_number: "7",
    		telephone_number: "2913635920",
    		remark: "quisque id",
    		subscribed_to_newsletter: false,
    		_id: "8be562498-5da4-5d2d-94bf-f94f6fb97d64",
    		id: 80,
    		type: "customer",
    		registration_date: 1589673600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616889600000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Diann",
    		lastname: "Feeham",
    		email: "dfeeham9r@wired.com",
    		city: "Yashalta",
    		postal_code: 10851,
    		street: "Lunder",
    		house_number: "91",
    		telephone_number: "7166131057",
    		subscribed_to_newsletter: false,
    		_id: "8dfc7974f-508f-5c66-953a-cb9a12667dd6",
    		id: 81,
    		type: "customer",
    		registration_date: 1595030400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614643200000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Elisha",
    		lastname: "Aliman",
    		email: "ealimanom@gov.uk",
    		city: "Rogów",
    		postal_code: 27706,
    		street: "Ronald Regan",
    		house_number: "3691",
    		telephone_number: "7124227658",
    		subscribed_to_newsletter: true,
    		_id: "8629a3e3d-5133-5a21-834a-c967e15c5c76",
    		id: 82,
    		type: "customer",
    		registration_date: 1553904000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616112000000,
    		highlight: ""
    	},
    	{
    		firstname: "Stevy",
    		lastname: "Bendare",
    		email: "sbendare26@buzzfeed.com",
    		city: "Katrineholm",
    		postal_code: 15840,
    		street: "Kedzie",
    		house_number: "4",
    		telephone_number: "7578766693",
    		subscribed_to_newsletter: true,
    		_id: "8f29ac391-8f43-547c-be9e-aff582945b52",
    		id: 83,
    		type: "customer",
    		registration_date: 1613692800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616371200000,
    		highlight: "rgb(45, 144, 224)"
    	},
    	{
    		firstname: "Alwyn",
    		lastname: "Taunton.",
    		email: "atauntonkt@economist.com",
    		city: "Marugame",
    		postal_code: 52594,
    		street: "Bunting",
    		house_number: "865",
    		telephone_number: "2191189434",
    		subscribed_to_newsletter: true,
    		_id: "894a9d571-4214-5955-995e-0ebd8f540dab",
    		id: 84,
    		type: "customer",
    		registration_date: 1579996800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616284800000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Shannen",
    		lastname: "McCoish",
    		email: "smccoishn2@mlb.com",
    		city: "Versailles",
    		postal_code: 95450,
    		street: "Spohn",
    		house_number: "76",
    		telephone_number: "6853941937",
    		remark: "mauris lacinia sapien quis",
    		subscribed_to_newsletter: false,
    		_id: "8e5e11c11-ad58-5892-be84-d83df5283cdd",
    		id: 85,
    		type: "customer",
    		registration_date: 1616544000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614902400000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Noami",
    		lastname: "McAnalley",
    		email: "nmcanalleyik@huffingtonpost.com",
    		city: "Kiyevskoye",
    		postal_code: 43431,
    		street: "Shopko",
    		house_number: "9",
    		telephone_number: "4039778719",
    		subscribed_to_newsletter: false,
    		_id: "8e6824cb1-023b-5e73-aab3-05325a4de316",
    		id: 86,
    		type: "customer",
    		registration_date: 1560902400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614643200000,
    		highlight: ""
    	},
    	{
    		firstname: "Leonore",
    		lastname: "MacDermid",
    		email: "lmacdermid8w@usa.gov",
    		city: "Ajuy",
    		postal_code: 88597,
    		street: "Erie",
    		house_number: "668",
    		telephone_number: "8972565645",
    		subscribed_to_newsletter: false,
    		_id: "84040f073-ffed-5d16-a66b-79e12ee3ae57",
    		id: 87,
    		type: "customer",
    		registration_date: 1571270400000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616112000000,
    		highlight: ""
    	},
    	{
    		firstname: "Dulcea",
    		lastname: "Fumagall",
    		email: "dfumagallf9@printfriendly.com",
    		city: "Kozel’shchyna",
    		street: "Weeping Birch",
    		house_number: "62",
    		telephone_number: "1451626543",
    		remark: "pede lobortis ligula sit amet eleifend pede",
    		subscribed_to_newsletter: false,
    		_id: "8e76314e7-0d46-5766-a04c-bd295c3bc2dc",
    		id: 88,
    		type: "customer",
    		registration_date: 1571702400000,
    		renewed_on: 0,
    		postal_code: 85352,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: "rgb(250, 45, 30)"
    	},
    	{
    		firstname: "Issy",
    		lastname: "Stone Fewings",
    		email: "istonefewingso0@vkontakte.ru",
    		city: "Šavnik",
    		street: "Lukken",
    		house_number: "1",
    		telephone_number: "5651151894",
    		subscribed_to_newsletter: false,
    		_id: "86990fd92-49a7-59fb-a216-3935b8013850",
    		id: 89,
    		type: "customer",
    		registration_date: 1585267200000,
    		renewed_on: 0,
    		postal_code: 53533,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616284800000,
    		highlight: ""
    	},
    	{
    		firstname: "Carny",
    		lastname: "Frantsev",
    		email: "cfrantsevd4@symantec.com",
    		city: "Zhushan Chengguanzhen",
    		street: "Texas",
    		house_number: "91",
    		telephone_number: "9842799404",
    		subscribed_to_newsletter: true,
    		_id: "98743b6ab-0efb-5a35-b24c-e290b4528f62",
    		id: 90,
    		type: "customer",
    		registration_date: 1602115200000,
    		renewed_on: 0,
    		postal_code: 83402,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616630400000,
    		highlight: ""
    	},
    	{
    		firstname: "Brandie",
    		lastname: "Lonsdale",
    		email: "blonsdaleow@tiny.cc",
    		city: "Paris La Défense",
    		postal_code: 88044,
    		street: "Grasskamp",
    		house_number: "29",
    		telephone_number: "6871364109",
    		subscribed_to_newsletter: true,
    		_id: "991edb0d6-a7a2-5675-a094-5de45b80cdcf",
    		id: 91,
    		type: "customer",
    		registration_date: 1600992000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616112000000,
    		highlight: ""
    	},
    	{
    		firstname: "Obadiah",
    		lastname: "Dumphries",
    		email: "odumphries2s@odnoklassniki.ru",
    		city: "Inda Silasē",
    		street: "Valley Edge",
    		house_number: "647",
    		telephone_number: "5913774046",
    		subscribed_to_newsletter: true,
    		_id: "9e234f31c-839e-548a-9cb1-c9d8f05a3b56",
    		id: 92,
    		type: "customer",
    		registration_date: 1591660800000,
    		renewed_on: 0,
    		postal_code: 38426,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614988800000,
    		highlight: ""
    	},
    	{
    		firstname: "Juditha",
    		lastname: "Grise",
    		email: "jgrisem0@miibeian.gov.cn",
    		city: "Neftobod",
    		street: "Sherman",
    		house_number: "84",
    		telephone_number: "7798210578",
    		subscribed_to_newsletter: false,
    		_id: "92a55f9c6-a552-5b30-a361-0997d51f75b1",
    		id: 93,
    		type: "customer",
    		registration_date: 1569801600000,
    		renewed_on: 0,
    		postal_code: 48155,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614556800000,
    		highlight: ""
    	},
    	{
    		firstname: "Myrvyn",
    		lastname: "Fittes",
    		email: "mfittesfn@surveymonkey.com",
    		city: "Ninomiya",
    		postal_code: 86398,
    		street: "Kinsman",
    		house_number: "497",
    		telephone_number: "9691603411",
    		subscribed_to_newsletter: false,
    		_id: "9c31760df-76f1-538d-b5a3-347f435561bc",
    		id: 94,
    		type: "customer",
    		registration_date: 1596153600000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615939200000,
    		highlight: ""
    	},
    	{
    		firstname: "Albie",
    		lastname: "Govan",
    		email: "agovandf@guardian.co.uk",
    		city: "Tambo",
    		postal_code: 82128,
    		street: "Carioca",
    		house_number: "931",
    		telephone_number: "4105513709",
    		subscribed_to_newsletter: false,
    		_id: "9ee19c652-7497-53e4-b608-371f85e04f7d",
    		id: 95,
    		type: "customer",
    		registration_date: 1576195200000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615420800000,
    		highlight: ""
    	},
    	{
    		firstname: "Aleta",
    		lastname: "Tilston",
    		email: "atilston9i@barnesandnoble.com",
    		city: "Miasteczko Śląskie",
    		postal_code: 99381,
    		street: "Mayfield",
    		house_number: "3",
    		telephone_number: "9081719310",
    		subscribed_to_newsletter: false,
    		_id: "9e3dee01e-100a-51b3-bcbb-ed26ed20aca0",
    		id: 96,
    		type: "customer",
    		registration_date: 1574640000000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614729600000,
    		highlight: "rgb(247, 239, 10)"
    	},
    	{
    		firstname: "Jdavie",
    		lastname: "Beddin",
    		email: "jbeddinly@webeden.co.uk",
    		city: "Madan",
    		street: "Westport",
    		house_number: "64633",
    		telephone_number: "2325769196",
    		subscribed_to_newsletter: false,
    		_id: "99ced28a6-f9c8-5f01-8ebd-ac00af1ea99b",
    		id: 97,
    		type: "customer",
    		registration_date: 1554595200000,
    		renewed_on: 0,
    		postal_code: 68262,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615766400000,
    		highlight: ""
    	},
    	{
    		firstname: "Tallulah",
    		lastname: "Costen",
    		email: "tcostenqx@nydailynews.com",
    		city: "Nglengkong",
    		street: "Jenna",
    		house_number: "57",
    		telephone_number: "3535905033",
    		subscribed_to_newsletter: true,
    		_id: "9ba7b5d1e-fb88-56c8-80ca-8a4a5074a022",
    		id: 98,
    		type: "customer",
    		registration_date: 1615766400000,
    		renewed_on: 0,
    		postal_code: 54790,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1616630400000,
    		highlight: ""
    	},
    	{
    		firstname: "Elliot",
    		lastname: "Fallis",
    		email: "efalliseu@cmu.edu",
    		city: "Rixinhe",
    		street: "Granby",
    		house_number: "583",
    		telephone_number: "4534871698",
    		subscribed_to_newsletter: true,
    		_id: "9ffe1084e-7066-5c8f-8035-4f9d0b321f87",
    		id: 99,
    		type: "customer",
    		registration_date: 1564185600000,
    		renewed_on: 0,
    		postal_code: 63503,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1614816000000,
    		highlight: "rgb(131, 235, 52)"
    	},
    	{
    		firstname: "Laurette",
    		lastname: "Palluschek",
    		email: "lpalluschek2l@rambler.ru",
    		city: "Cereté",
    		postal_code: 49591,
    		street: "Bultman",
    		house_number: "58840",
    		telephone_number: "2535673244",
    		subscribed_to_newsletter: false,
    		_id: "10c947e90e-2466-5144-a701-acecb041fcdc",
    		id: 100,
    		type: "customer",
    		registration_date: 1605916800000,
    		renewed_on: 0,
    		heard: "gesehen, vorbeigelaufen",
    		last_update: 1615075200000,
    		highlight: ""
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d6a829e098949-0dab-5dbc-9ac6-310ad9c31f7e",
    		id: 5025,
    		name: "Campingsessel",
    		brand: "-",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1551052800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/campingsessel/",
    		wc_id: "2276",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5025.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "rund, klappbar",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615248000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8ccc2383882132-8c5f-5fcd-964b-e604e6f60860",
    		id: 1747,
    		name: "Tennisschläger",
    		brand: "Völkl",
    		itype: "syndro soft",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "mit Schutzhülle",
    		added: 1587686400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/tennisschlaeger-3/",
    		wc_id: "3649",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6109.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615248000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8bf6600b7eb659-c365-5ef6-a46b-76246ead86e8",
    		id: 205,
    		name: "Elektro-Öl-Radiator",
    		brand: "DeLonghi",
    		itype: "Venturi",
    		category: "Haushalt",
    		deposit: 35,
    		parts: "1",
    		manual: "",
    		"package": "Originalkarton",
    		added: 1536624000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/haushalt/elektro-oel-radiator/",
    		wc_id: "1967",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/205.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616112000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d8123796d2bd0-dd52-57a6-814e-62f23f8a50e3",
    		id: 6101,
    		name: "Faszienrolle",
    		brand: "Blackroll MED",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 5,
    		parts: "1",
    		manual: "Beschreibung auf Karton",
    		"package": "originalKarton",
    		added: 1582761600000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "rgb(247, 239, 10)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615334400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d33ab0f7c1979-16f7-5602-b4bd-3328334ab1d2",
    		id: 2915,
    		name: "Akkuschrauber",
    		brand: "Bosch",
    		itype: "Ixo full set",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "4",
    		manual: "in Schriftform vorhanden",
    		"package": "originalKarton",
    		added: 1578873600000,
    		status: "onbackorder",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/akkuschrauber-5/",
    		wc_id: "3263",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/01/2915.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Bedienungsanleitung in Schriftform vorhanden,\nmit Exzenter und Winkelaufsatz",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615161600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d1f0a11714b15-e081-5f84-bf0e-393635982532",
    		id: 2801,
    		name: "Busvorzelt",
    		brand: "Carryox",
    		itype: "10T",
    		category: "Freizeit",
    		deposit: 25,
    		parts: "2",
    		manual: "",
    		"package": "Originalverpackung",
    		added: 1558915200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/vorzelt/",
    		wc_id: "2376",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/06/2801.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "für Busse und Campingvans, 280×300 cm breit, 210 cm hoch, Packmaß 24×74 cm",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616284800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c7efab6adde11-c74b-59d6-81b2-4ff3ef9f0b1d",
    		id: 1243,
    		name: "Handmixer",
    		brand: "KRUPS 3 MIX 3000",
    		itype: "",
    		category: "Küche",
    		deposit: "15",
    		parts: "5",
    		manual: "",
    		"package": "",
    		added: 1611014400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/handmixer-3/",
    		wc_id: "4632",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2021/01/1243_1.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c18bf25d8396e-b315-5ce4-8e5c-94ed120e5b2e",
    		id: 504,
    		name: "Hörnchen-Automat",
    		brand: "Komet",
    		itype: "7117 BE",
    		category: "Küche",
    		deposit: 15,
    		parts: "2",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1536105600000,
    		status: "onbackorder",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/hoernchen-automat/",
    		wc_id: "237",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/504.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615680000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d17c6abab5e69-9cc5-5b34-91e5-2afe3b882850",
    		id: 2708,
    		name: "2708 geändert in 1900 nicht neu besetzen",
    		brand: "",
    		itype: "",
    		category: "",
    		deposit: 0,
    		parts: "",
    		manual: "",
    		"package": "",
    		added: 0,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615766400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d0c6341db9d9b-9081-51be-b989-a8554631778f",
    		id: 2607,
    		name: "Lötpistole",
    		brand: "Parkside",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "6",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "OriginalKarton",
    		added: 1555113600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/loetpistole/",
    		wc_id: "2993",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/2607.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "180W",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614902400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c9b7d28f14478-7e78-5004-ba6b-5107c6e5b2f1",
    		id: 1506,
    		name: "el. Kettensäge",
    		brand: "Dolmar",
    		itype: "-",
    		category: "Garten",
    		deposit: 25,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539561600000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/garten/el-kettensaege/",
    		wc_id: "436",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1506.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Sägeblatt stumpf, muss erneuert werden.\nZum ausleihen muss der Nutzer/ die Nutzerin schriftlich bestätigen, dass er/ sie mit einer Kettensäge umgehen kann und diese nicht im Wald, sondern nur auf dem eigenen Grundstück einsetzt.\nInkl. Verlängerungskabel",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615852800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d62ecbb94f369-49f5-5224-97ec-ff4a0eecfa55",
    		id: 5010,
    		name: "Hydraulik-Holzspalter",
    		brand: "Scheppach",
    		itype: "HL 650",
    		category: "Heimwerker",
    		deposit: 100,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/5010.pdf",
    		"package": "-",
    		added: 1542844800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/1548/",
    		wc_id: "1548",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5010.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "3 PS, Spaltkraft: 6,5 t, Max. Spaltgutlänge: 52 cm, 2.200 W, ca. 50kg",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c63e48371c3f0-f79e-5e41-92d0-04b31f8e3c8b",
    		id: 1116,
    		name: "Sandwichmaker",
    		brand: "Hit",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1543536000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/sandwichmaker/",
    		wc_id: "2862",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1116.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616284800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d26c578b801f0-5f67-5ce8-8625-c56f742e8084",
    		id: 2816,
    		name: "Glätteisen",
    		brand: "Philips",
    		itype: "-",
    		category: "Haushalt",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1564704000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/haushalt/glaetteisen/",
    		wc_id: "3014",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/08/2816.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "mit Braun-Tasche",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614902400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c45cd850b8655-d92c-5f71-a92c-7dd6c51ccd22",
    		id: 830,
    		name: "Silikonspritze",
    		brand: "",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1588550400000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/silikonspritze-2/",
    		wc_id: "3727",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "auch: Profi – Kartuschen-Spritze",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615161600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d0b42b86997cc-a708-5433-a8d4-aeb1d6621644",
    		id: 2605,
    		name: "Wärmeplatte",
    		brand: "Salton",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1554940800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/waermeplatte/",
    		wc_id: "2256",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/2605.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d30889a653910-b212-5c14-9873-a7a0913e94f6",
    		id: 2909,
    		name: "Multi-Scanner",
    		brand: "Tevion",
    		itype: "SPENDENVerKAUF",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "8",
    		manual: "",
    		"package": "",
    		added: 1568160000000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616371200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d78e144e4e1ab-8d02-57af-96db-c91e536ac2af",
    		id: 5055,
    		name: "Feine-Metall-Feilen",
    		brand: "-",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 5,
    		parts: "-",
    		manual: "",
    		"package": "",
    		added: 1602460800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/feine-metall-feilen/",
    		wc_id: "4155",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/10/5055.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "verschiedene Größen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614902400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cf3ff9afba6bb-3c58-5358-9e71-e496e608a440",
    		id: 2402,
    		name: "Babywippe",
    		brand: "chicco",
    		itype: "SPENDENVERKAUF",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1551398400000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616198400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c5d17ca9c1356-f796-56fe-af66-f5a3b3ae981a",
    		id: 1101,
    		name: "Joghurt-Box",
    		brand: "A.Vogel",
    		itype: "SPENDENVERKAUF",
    		category: "Küche",
    		deposit: 5,
    		parts: "5",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1536278400000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614643200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c45cd6de2ea5b-991e-5cc0-abac-e47bf0d0a253",
    		id: 830,
    		name: "Silikonspritze",
    		brand: "",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1588550400000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/silikonspritze-2/",
    		wc_id: "3727",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "auch: Profi – Kartuschen-Spritze",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8be200d800b5d8-69ee-5c89-a2ea-dd4dde204546",
    		id: 15,
    		name: "Stichsäge",
    		brand: "TOP Craft",
    		itype: "TPS 550E",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "2",
    		manual: "",
    		"package": "",
    		added: 1581292800000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/stichsaege-6/",
    		wc_id: "3423",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		highlight: "",
    		synonyms: "Laubsäge, Laubsägemaschine, Wippsäge",
    		description: "mit Auffangbeutel von Bosch",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616889600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c402f6c3b8f99-a612-5b33-9a71-0fd240b04b9a",
    		id: 820,
    		name: "Rollkoffer",
    		brand: "eaglecreek",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539561600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/rollkoffer/",
    		wc_id: "303",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/820.jpg",
    		highlight: "",
    		synonyms: "Trolley",
    		description: "mit Tragegestell",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615593600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c78e3703a7591-a9c6-5e4f-ba10-30d391ca37b6",
    		id: 1231,
    		name: "Wok",
    		brand: "Bodum",
    		itype: "Chambord",
    		category: "Küche",
    		deposit: 15,
    		parts: "4",
    		manual: "",
    		"package": "Originalkarton",
    		added: 1543622400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/wok-2/",
    		wc_id: "2876",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1231.jpg",
    		highlight: "",
    		synonyms: "Wokpfanne",
    		description: "Emaille-beschichtet, für alle Herdarten geeignet (incl. Induktion)\n,gusseisern,370 mm",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615593600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c00c8e7fe29e9-c0ee-5398-a2ab-ebe04774ae2d",
    		id: 308,
    		name: "Römertopf",
    		brand: "-",
    		itype: "-",
    		category: "Küche",
    		deposit: 5,
    		parts: "2",
    		manual: "",
    		"package": "-",
    		added: 1536019200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/roemertopf/",
    		wc_id: "2797",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/308.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615334400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c2e8ca61bec00-41ee-5ce4-8999-89871b229f32",
    		id: 626,
    		name: "Autokindersitz",
    		brand: "Maxi Cosi",
    		itype: "-",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1544659200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/autokindersitz/",
    		wc_id: "172",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/108.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Gr. 9-18 kg",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614902400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d5abd2cb265c9-3c73-5315-ad1b-127a41ff652d",
    		id: 4001,
    		name: "Geschirr",
    		brand: "-",
    		itype: "-",
    		category: "Küche",
    		deposit: 5,
    		parts: "-",
    		manual: "",
    		"package": "-",
    		added: 1541376000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/geschirr/",
    		wc_id: "541",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/4001.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "ca. 30 Teller, Untertassen, Tassen verschiedener Art",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615507200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c8be28c3b8eca-e7f5-52e0-abda-0d237f393294",
    		id: 1328,
    		name: "Kleistermaschine",
    		brand: "Träkle",
    		itype: "CUTTERKANT",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "",
    		manual: "",
    		"package": "OriginalKarton",
    		added: 1597017600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/kleistermaschine-3/",
    		wc_id: "4001",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/08/1328.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615075200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cf3ff4b484f9f-b5f9-50ad-8f98-fb29900238b3",
    		id: 2402,
    		name: "Babywippe",
    		brand: "chicco",
    		itype: "SPENDENVERKAUF",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1551398400000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615593600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c25b4425d4cc2-66f6-52e3-af66-0a611f5d0931",
    		id: 606,
    		name: "Elektr. Gemüseschneider",
    		brand: "Moulinex",
    		itype: "Charlotte HV3",
    		category: "Küche",
    		deposit: 15,
    		parts: "22",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1536105600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/kuechenmaschine-2/",
    		wc_id: "256",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/606.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615248000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d84b47c2e63c2-0a92-5be2-b035-be53c320d82d",
    		id: 6106,
    		name: "nicht neu besetzen jetzt 1430",
    		brand: "",
    		itype: "",
    		category: "",
    		deposit: 0,
    		parts: "",
    		manual: "",
    		"package": "",
    		added: 0,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615766400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8ce87b9c207d9f-ddbd-54df-ab07-c01d821d509f",
    		id: 2208,
    		name: "Bohrmaschine",
    		brand: "AEG",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1549065600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/bohrmaschine-3/",
    		wc_id: "931",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/2208.jpg",
    		highlight: "",
    		synonyms: "Bohrer, Bohrgerät",
    		description: "750 Watt",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615766400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d1014f240f38a-7de3-541c-a62a-a42b99736968",
    		id: 2616,
    		name: "Fahrrad-Kindersitz",
    		brand: "-",
    		itype: "-",
    		category: "Kinder",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "",
    		added: 1557964800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/fahrrad-kindersitz-3/",
    		wc_id: "2995",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/05/2616.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615161600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c6aa0b1582914-57b3-508b-914b-d2287c298708",
    		id: 1207,
    		name: "Stabmixer",
    		brand: "Braun",
    		itype: "SPENDENVERKAUF",
    		category: "Küche",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1536278400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/stabmixer-2/",
    		wc_id: "361",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1207.jpg",
    		highlight: "",
    		synonyms: "Mixstab, Pürierstab, Zauberstab",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615593600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cc929e65a68cc-f386-5eb6-a56e-8aac08860dad",
    		id: 1742,
    		name: "Fugenkratzer",
    		brand: "-",
    		itype: "-",
    		category: "Garten",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1551657600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/garten/fugenkratzer/",
    		wc_id: "2931",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1742-1.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d825a6a782c18-b231-5ed7-b302-70949fd57714",
    		id: 6103,
    		name: "Strommessgerät",
    		brand: "ENBW",
    		itype: "",
    		category: "Haushalt",
    		deposit: 5,
    		parts: "1",
    		manual: "in Schriftform vorhanden",
    		"package": "originalKarton",
    		added: 1582761600000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615161600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d57900089e65a-f3e6-58e9-87d3-cee86d1f040c",
    		id: 3317,
    		name: "Strandliegen",
    		brand: "",
    		itype: "",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "4",
    		manual: "",
    		"package": "",
    		added: 1596153600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/strandliegen/",
    		wc_id: "3940",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/08/3317.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "1 Paar, zerlegbar",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c4bf301b1e8b5-bef7-5701-b817-ffd948c2c3c1",
    		id: 912,
    		name: "Elektrohobel",
    		brand: "KingCraft",
    		itype: "WK 900 EH",
    		category: "Heimwerker",
    		deposit: 45,
    		parts: "5",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1539561600000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614556800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c0a15a0caec43-e9a4-524a-9838-515cfa16eea3",
    		id: 403,
    		name: "Ski/Snowboardhelm versch. Größen",
    		brand: "TCM",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1536019200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/ski-snowboardhelm/",
    		wc_id: "2802",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/403.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "XS/S 50-53cm, 5 versch. Modelle",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616371200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d7ad91456f759-55f0-5e9b-8a46-dba146d6d323",
    		id: 5059,
    		name: "Kabeltrommel",
    		brand: "-",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "1",
    		manual: "-",
    		"package": "-",
    		added: 1605744000000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/kabeltrommel/",
    		wc_id: "4307",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "50m",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615766400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d493871c60c1b-8391-517c-94eb-bdd211665a56",
    		id: 3212,
    		name: "Multifunktionsmixer",
    		brand: "Bullet Express",
    		itype: "KASCHKA",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "",
    		manual: "",
    		"package": "",
    		added: 1567728000000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "rgb(45, 144, 224)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615075200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d2fc66da4e40f-d044-5384-8eb3-dd880557e359",
    		id: 2906,
    		name: "Bohrmaschine",
    		brand: "Bosch",
    		itype: "PBH 16 RE",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "4",
    		manual: "",
    		"package": "",
    		added: 1572220800000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/bohrmaschine-5/",
    		wc_id: "3022",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/10/2906.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615507200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c46be9f726bf9-4588-5029-9fb4-0d41efa466e4",
    		id: 832,
    		name: "Elektr. Fondue",
    		brand: "TCM",
    		itype: "64696",
    		category: "Küche",
    		deposit: 15,
    		parts: "11",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1596758400000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d2ce8b2d07b87-78ce-56ca-b996-249a4a61d97b",
    		id: 2900,
    		name: "Kinder Schlittschuhkuven",
    		brand: "-",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 5,
    		parts: "2",
    		manual: "",
    		"package": "",
    		added: 1592179200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/kinder-schlittschuhkuven/",
    		wc_id: "3823",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/06/2900.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Größe ist auf den jeweiligen Schuh anzupassen -„Eisrutscherle“",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616284800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c3f77487f75f1-c080-547f-b24f-6cb58cc7318a",
    		id: 819,
    		name: "Kindertrage",
    		brand: "fourseasons",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 25,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539043200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/kindertrage/",
    		wc_id: "2044",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/819.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "bis zu 15 kg",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616889600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d5badb1d93846-69a5-514e-8f06-a4538641dd40",
    		id: 4003,
    		name: "Bowle-Set",
    		brand: "-",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "9",
    		manual: "",
    		"package": "-",
    		added: 1542326400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/bowle-set/",
    		wc_id: "3046",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/4003.jpg",
    		highlight: "rgb(131, 235, 52)",
    		synonyms: "",
    		description: "mit 6 Tassen, Schöpfkelle",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8bf93e74e652c3-d5e0-58c2-b1d7-51e93e091bd9",
    		id: 212,
    		name: "Kinderhochstuhl",
    		brand: "icoo",
    		itype: "SPENDENVERKAUF",
    		category: "Kinder",
    		deposit: 15,
    		parts: "4",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/212.pdf",
    		"package": "-",
    		added: 1536624000000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616803200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c08ef2547f2a9-649a-5abf-b36c-74d2aa0f40bc",
    		id: 329,
    		name: "Schokofondue-Set",
    		brand: "kela",
    		itype: "",
    		category: "Küche",
    		deposit: "15",
    		parts: "10",
    		manual: "",
    		"package": "",
    		added: 1611014400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/schokofondue-set/",
    		wc_id: "4631",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2021/01/0329.jpg",
    		highlight: "rgb(247, 239, 10)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c4ffb2edb67ac-bc84-570e-a388-675ef6423e3c",
    		id: 921,
    		name: "Entsafter",
    		brand: "mia",
    		itype: "SP2003",
    		category: "Küche",
    		deposit: 15,
    		parts: "6",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/921.pdf",
    		"package": "-",
    		added: 1544486400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/entsafter-2/",
    		wc_id: "326",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/921.jpg",
    		highlight: "",
    		synonyms: "Fruchtpresse, Kelter, Moster, Mostpresse, Obstpresse, Saftpresse",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cb580b46e334f-3b45-563e-bad2-81dd698c57ab",
    		id: 1703,
    		name: "Lötkolben",
    		brand: "Ersa",
    		itype: "150",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "4",
    		manual: "",
    		"package": "-",
    		added: 1537228800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/loetkolben/",
    		wc_id: "2157",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1703.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "mit Lötfett, -stein, -zinn",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616198400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d7ad9766ded74-9e1e-5163-99c5-b196ebb865fb",
    		id: 5059,
    		name: "Kabeltrommel",
    		brand: "-",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "1",
    		manual: "-",
    		"package": "-",
    		added: 1605744000000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/kabeltrommel/",
    		wc_id: "4307",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		highlight: "rgb(45, 144, 224)",
    		synonyms: "",
    		description: "50m",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616457600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cd734f41f1f7a-72e9-5ea3-a82b-5b901ea7c2d2",
    		id: 1907,
    		name: "belgisches Waffeleisen",
    		brand: "ambiano",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1540771200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/belgisches-waffeleisen/",
    		wc_id: "513",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1907.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614556800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d7ce53c2a4591-c296-575a-876a-9a1ca87056ec",
    		id: 6002,
    		name: "Babysitz",
    		brand: "bébé comfort",
    		itype: "",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "",
    		added: 1581897600000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615507200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c25b46d494223-7b48-5771-94e8-1c431a7b771b",
    		id: 606,
    		name: "Elektr. Gemüseschneider",
    		brand: "Moulinex",
    		itype: "Charlotte HV3",
    		category: "Küche",
    		deposit: 15,
    		parts: "22",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1536105600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/kuechenmaschine-2/",
    		wc_id: "256",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/606.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616630400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cb5408dfb453e-debf-5d64-ad21-98bbbc79ee09",
    		id: 1702,
    		name: "Ravioli-Former",
    		brand: "TCM",
    		itype: "-",
    		category: "Küche",
    		deposit: 5,
    		parts: "3",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1537228800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/ravioli-former/",
    		wc_id: "463",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1702.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615593600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c0beac97e7f68-ab2d-5408-9ed5-04fd1ceb9b72",
    		id: 409,
    		name: "Dampfbügelstation",
    		brand: "TCM",
    		itype: "KASCHKA",
    		category: "Haushalt",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1536019200000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "rgb(45, 144, 224)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d5fcf32d81b01-3391-57ed-b7ca-a6f15977746f",
    		id: 5004,
    		name: "Hammer",
    		brand: "-",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 5,
    		parts: "-",
    		manual: "",
    		"package": "-",
    		added: 1541116800000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/hammer/",
    		wc_id: "1845",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5004.jpg",
    		highlight: "",
    		synonyms: "Fäustel",
    		description: "verschiedene Art und Größen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615680000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d37af3309ec92-21be-579f-920a-d920d5579789",
    		id: 3004,
    		name: "Werkzeugkasten",
    		brand: "-",
    		itype: "",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "",
    		manual: "",
    		"package": "",
    		added: 1578096000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/werkzeugkasten/",
    		wc_id: "3246",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/01/3004.jpg",
    		highlight: "",
    		synonyms: "Werkzeugbox, Werkzeugkiste, Werkzeugkoffer",
    		description: "Mit Säge und Knieschoner usw…,weiterer Zubehör siehe Bild",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616630400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8be82068492814-5c8b-50c8-811f-9bc01abdcbdc",
    		id: 100,
    		name: "Staubsauger",
    		brand: "Thomas",
    		itype: "SPENDENVERKAUF",
    		category: "Haushalt",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539907200000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614729600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d1261acf28dc8-d531-5d56-bb75-f3011d3c97d1",
    		id: 2622,
    		name: "Metronom",
    		brand: "Wittner",
    		itype: "Tactell piccolino",
    		category: "Freizeit",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1589500800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/metronom/",
    		wc_id: "3761",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/2622.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "made in Germany , Qualität seit 1895",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614643200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c584095a0203e-d196-5afa-a11e-6657f2ce60b2",
    		id: 1009,
    		name: "Luftentfeuchter",
    		brand: "Workzone",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "-",
    		added: 1540512000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/luftentfeuchter/",
    		wc_id: "2068",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1009.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616198400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cb2fd4ab9ccfd-f2e7-5248-84ae-5a70679f882d",
    		id: 1630,
    		name: "Inliner GR. 33-36",
    		brand: "crane",
    		itype: "Art.-Nr. 91943",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "",
    		added: 1581897600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/inliner/",
    		wc_id: "3480",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/6009.jpg",
    		highlight: "rgb(45, 144, 224)",
    		synonyms: "",
    		description: "für Jungen Gr. 33-36, 72mm",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615075200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d07ee12d8ee8c-bdb0-5a3c-97a8-205e99bc43c3",
    		id: 2522,
    		name: "Walkingstöcke",
    		brand: "-",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "2",
    		manual: "",
    		"package": "-",
    		added: 1564704000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/walkingstoecke/",
    		wc_id: "2988",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/08/2522.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Höhe: 110 cm",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616716800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cf3ff4dace921-1ab1-5df2-b129-3d20fe578635",
    		id: 2402,
    		name: "Babywippe",
    		brand: "chicco",
    		itype: "SPENDENVERKAUF",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1551398400000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cb924fde4dc39-6d22-5030-9d46-0f12f8a0dc62",
    		id: 1710,
    		name: "Tortenring",
    		brand: "chg",
    		itype: "-",
    		category: "Küche",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1537747200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/tortenring/",
    		wc_id: "2916",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1710.jpg",
    		highlight: "rgb(131, 235, 52)",
    		synonyms: "",
    		description: "8,5 cm hoch",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cccb7522eba62-95f8-5732-9aec-194f7168a99e",
    		id: 1800,
    		name: "Speiseeismaschine",
    		brand: "studio",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "5",
    		manual: "",
    		"package": "Originalkarton",
    		added: 1596758400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/speiseeismaschine-3/",
    		wc_id: "3970",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1807.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Kühlflüssigkeit über Nacht kühlstellen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616284800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d536d16d0819b-e8cb-5310-9d0a-96e521d3925f",
    		id: 3309,
    		name: "Navigationsgerät",
    		brand: "Tomtom",
    		itype: "",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "2",
    		manual: "",
    		"package": "",
    		added: 1572480000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/navigationsgeraet/",
    		wc_id: "3045",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/10/3309.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615680000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c3397c34d1646-ee64-5074-afd3-ec19b284e644",
    		id: 708,
    		name: "Motorradbatterie-Ladegerät",
    		brand: "smartCharcher",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "2",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1539561600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/motorradbatterie-ladegeraet/",
    		wc_id: "2032",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/708.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "2x vorhanden, Input 230V Output 12V",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614556800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8bf28b529ec261-f758-5017-a410-dcc229a1b34f",
    		id: 120,
    		name: "Infrarot-Temperaturmessgerät",
    		brand: "POWERFIX",
    		itype: "Profi+",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "2",
    		manual: "in Schriftform vorhanden",
    		"package": "OriginalKarton",
    		added: 1602720000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/infrarot-temperaturmessgeraet/",
    		wc_id: "4166",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/10/P1060730.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Anleitung in Schriftform vorhanden\nZeigt Wärmeverluste an Fenstern, Türen oder Isolierungen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616112000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c7e63daed8914-6b8a-5a54-b6f4-aa87cf6924ca",
    		id: 1242,
    		name: "Laufrad",
    		brand: "Puky",
    		itype: "12,5 Zoll",
    		category: "Kinder",
    		deposit: "15",
    		parts: "1",
    		manual: "",
    		"package": "",
    		added: 1610755200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/laufrad-2/",
    		wc_id: "4615",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2021/01/2116.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616371200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cd4fb620b75eb-3748-587c-a9f8-46ae60013650",
    		id: 1902,
    		name: "Reithelm",
    		brand: "SPENDENVERKAF",
    		itype: "-",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539907200000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8ca0c9f0c8e1e5-8bde-5319-9ad3-0f180c83a630",
    		id: 1517,
    		name: "Einrad",
    		brand: "-",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1548460800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/einrad/",
    		wc_id: "888",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1517.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614556800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8bf867511fe1ed-be02-5e95-bb6a-87d22d68eebb",
    		id: 210,
    		name: "Stativleinwand",
    		brand: "universa",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539648000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/stativleinwand/",
    		wc_id: "183",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/210.jpg",
    		highlight: "rgb(247, 239, 10)",
    		synonyms: "",
    		description: "Maximale Maße der Leinwand: 1,2 m x 1,25 m",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615852800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c3536931f52dc-5151-5cf8-96fa-3fc6458fcbb4",
    		id: 711,
    		name: "Küchenmaschine",
    		brand: "Braun",
    		itype: "Type 4200",
    		category: "Küche",
    		deposit: 35,
    		parts: "21",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Karton",
    		added: 1539561600000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/kuechenmaschine-3/",
    		wc_id: "2830",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614988800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c48d5158311b6-f776-5081-b33d-786eab2aafc8",
    		id: 905,
    		name: "Stichsäge",
    		brand: "Metabo",
    		itype: "St EP 560",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "2",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkoffer",
    		added: 1536192000000,
    		status: "onbackorder",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/stichsaege-2/",
    		wc_id: "310",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/905.jpg",
    		highlight: "rgb(131, 235, 52)",
    		synonyms: "Laubsäge, Laubsägemaschine, Wippsäge",
    		description: "div. Sägeblätter",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d5e7c049f5ce9-4d4b-567d-b17c-de91058b930e",
    		id: 5002,
    		name: "Schraubenschlüssel",
    		brand: "-",
    		itype: "-",
    		category: "Heimwerker",
    		deposit: 5,
    		parts: "-",
    		manual: "",
    		"package": "-",
    		added: 1537747200000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/1529/",
    		wc_id: "1529",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "auch: Gabel-Ringschlüssel, Gabelschlüssel\nverschiedene Größen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d612f0b803678-b9b5-52ee-bd60-916e2b36df13",
    		id: 5006,
    		name: "Wasserwaage, 100cm, Alu",
    		brand: "Bauhaus",
    		itype: "",
    		category: "Heimwerker",
    		deposit: "25",
    		parts: "",
    		manual: "",
    		"package": "",
    		added: 1614038400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/wasserwaage-100cm-alu/",
    		wc_id: "4684",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614902400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c793f2f9ee9c0-5d1a-5d98-867d-a263d9edcbf2",
    		id: 1232,
    		name: "Saftpresse",
    		brand: "-",
    		itype: "-",
    		category: "Küche",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1543622400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/saftpresse/",
    		wc_id: "2877",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1232.jpg",
    		highlight: "",
    		synonyms: "Entsafter, Fruchtpresse, Kelter, Moster, Mostpresse, Obstpresse",
    		description: "2x vorhanden",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615334400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d30881629f49e-c0e9-56ca-9e64-5ddf86af39f9",
    		id: 2909,
    		name: "Multi-Scanner",
    		brand: "Tevion",
    		itype: "SPENDENVerKAUF",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "8",
    		manual: "",
    		"package": "",
    		added: 1568160000000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615852800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cf6f28e9043f3-6bf1-5a69-b9c5-856e2bb43ff6",
    		id: 2407,
    		name: "Schreibmaschine",
    		brand: "Olympia",
    		itype: "",
    		category: "Freizeit",
    		deposit: 25,
    		parts: "1",
    		manual: "",
    		"package": "Originalkoffer",
    		added: 1553126400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/schreibmaschine/",
    		wc_id: "2236",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/2407.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Reiseschreibmaschine mit Tragekoffer",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616630400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8be26823bf3c9c-739e-5592-8b06-184e227bd14d",
    		id: 18,
    		name: "Filmvorführgerät",
    		brand: "ELMO",
    		itype: "SP-F",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "",
    		added: 1581292800000,
    		status: "onbackorder",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/diaprojektor-5/",
    		wc_id: "3427",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/18.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c05c319f9bca6-702d-5f2f-b12c-96c015bc62c5",
    		id: 321,
    		name: "Bunsenbrenner",
    		brand: "campingaz",
    		itype: "soudagaz 20C",
    		category: "Heimwerker",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1542931200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/loetlampe/",
    		wc_id: "1984",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/321.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "mit Gas-Stechkartusche, zum Einsetzen der Kartusche sind 2 Personen benötigt",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616284800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c687db0a71517-1f10-5d8c-8c62-3ba099c3c255",
    		id: 1202,
    		name: "Fleischwolf",
    		brand: "alfa",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "7",
    		manual: "",
    		"package": "Originalkarton",
    		added: 1536278400000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/fleischwolf/",
    		wc_id: "2864",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1202.jpg",
    		highlight: "",
    		synonyms: "Faschiermaschine, Fleischmaschine",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616284800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cd0ff0954f9d0-0219-545a-8ba0-db157f2acb7e",
    		id: 1807,
    		name: "Speiseeismaschine",
    		brand: "studio",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "5",
    		manual: "",
    		"package": "Originalkarton",
    		added: 1542931200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/speiseeismaschine/",
    		wc_id: "497",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1807.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Kühlflüssigkeit über Nacht kühlstellen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615075200000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cd5cfad7904d8-1709-5699-8bc1-4a16878e8f92",
    		id: 1903,
    		name: "Reithelm",
    		brand: "Penta",
    		itype: "Champion",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1539907200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/reithelm-2/",
    		wc_id: "2194",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1903.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Größe XS/01 50-54 cm",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616544000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d6e8084fdfcc5-88a2-5024-8d1f-ba5ed3e93657",
    		id: 5035,
    		name: "Gartenkralle",
    		brand: "Garden Claw",
    		itype: "-",
    		category: "Garten",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1530403200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/garten/gartenkralle/",
    		wc_id: "2836",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/814.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614816000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c99aaac601362-b4de-5b3b-a054-221f80f95259",
    		id: 1501,
    		name: "Rollator",
    		brand: "Invacare",
    		itype: "KA",
    		category: "Haushalt",
    		deposit: 25,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1501.pdf",
    		"package": "-",
    		added: 1530403200000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615852800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c2957915ab7cb-cc89-50ec-9fe3-c551b5b1b830",
    		id: 614,
    		name: "Autokindersitz",
    		brand: "Nania",
    		itype: "KASCHKA",
    		category: "Kinder",
    		deposit: 5,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "-",
    		added: 1539043200000,
    		status: "deleted",
    		wc_url: "",
    		wc_id: "",
    		image: "",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616457600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d6a829da8cc78-8c9e-5622-aabc-1a041729199f",
    		id: 5025,
    		name: "Campingsessel",
    		brand: "-",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 5,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1551052800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/campingsessel/",
    		wc_id: "2276",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5025.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "rund, klappbar",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c36b0df8470ad-f021-558d-ad23-f5cc14041148",
    		id: 715,
    		name: "Multi-Elektrosäge",
    		brand: "KingCraft",
    		itype: "KMS 550 E",
    		category: "Heimwerker",
    		deposit: 25,
    		parts: "1",
    		manual: "",
    		"package": "OriginalKarton",
    		added: 1550448000000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/multi-elektrosaege/",
    		wc_id: "2037",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "incl. Sägeblätter\nauch: Säbel – Sägemaschine, elektischer Fuchsschwanz",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8bf416f86b3f42-cf0c-55ad-93ae-8e4d0ea6f2e1",
    		id: 122,
    		name: "Digital-Multimeter",
    		brand: "POWERFIX",
    		itype: "Profi +",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "3",
    		manual: "in Schriftform vorhanden",
    		"package": "original karton",
    		added: 1605744000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/digital-multimeter/",
    		wc_id: "4295",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/0122.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Bedienungsanleitung in Schriftform vorhanden",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615334400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d2d3b81f866b2-0a10-5d75-a1d1-cf1889ba0350",
    		id: 2901,
    		name: "Schwingschleifer",
    		brand: "Bosch",
    		itype: "PSS 23 AE",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "-",
    		added: 1564963200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/schwingschleifer-2/",
    		wc_id: "3838",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/06/2901.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "mit div. Schleifpapier",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616025600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c188c9840b8dd-8242-5480-b2da-dd53cf5554a6",
    		id: 502,
    		name: "Camping Gaskocher",
    		brand: "Week End",
    		itype: "-",
    		category: "Freizeit",
    		deposit: 15,
    		parts: "1",
    		manual: "",
    		"package": "Originalkarton",
    		added: 1536105600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/freizeit/camping-gaskocher/",
    		wc_id: "2812",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/502.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Gasanschluss möglich für Butan/Propan, 2 Kochstellen\nman benötigt eine große Gasflasche & einen Gas-Schlauch-Regler",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616112000000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cf302ec817395-2bd4-5e1f-a3af-12ce3ac7a0ca",
    		id: 2318,
    		name: "Autokindersitz",
    		brand: "Cybex",
    		itype: "ECE R44/ 04",
    		category: "Kinder",
    		deposit: 15,
    		parts: "1",
    		manual: "in Schriftform vorhanden",
    		"package": "",
    		added: 1579219200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kinder/autokindersitz-12/",
    		wc_id: "3298",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/01/2800.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "Bedienungsanleitung in Schriftform vorhanden\nca. 3-12 Jahre (15-36kg) <150cm",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615420800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c9eb1f2eec798-d18c-51ba-b0d6-6263536d593f",
    		id: 1511,
    		name: "Multifunktionswerkzeug",
    		brand: "Dremel",
    		itype: "300",
    		category: "Heimwerker",
    		deposit: 15,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1511.pdf",
    		"package": "Originalkoffer",
    		added: 1540512000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/multifunktionswerkzeug/",
    		wc_id: "441",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1511.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "div. Aufsatzteile",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615852800000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c1c79b96efea8-6322-5438-a549-3984cc39b42f",
    		id: 512,
    		name: "Kontaktgrill",
    		brand: "privileg",
    		itype: "-",
    		category: "Küche",
    		deposit: 15,
    		parts: "1",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1539561600000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/kontaktgrill/",
    		wc_id: "2816",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/512.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615766400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cdd01d9429dd3-42d3-504d-ba27-82dd5a3bcd13",
    		id: 1919,
    		name: "Dörr-Automat",
    		brand: "ABC Elektrogeräte",
    		itype: "600.1/601.1",
    		category: "Küche",
    		deposit: 15,
    		parts: "1",
    		manual: "in Schriftform vorhanden",
    		"package": "OriginalKarton",
    		added: 1587686400000,
    		status: "outofstock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/doerr-automat/",
    		wc_id: "3654",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		highlight: "rgb(250, 45, 30)",
    		synonyms: "",
    		description: "Bedienungsanleitung in Schriftform vorhanden",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615593600000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8d6e16635cc65e-d86d-508e-864e-5edbf07c9a0b",
    		id: 5034,
    		name: "Kabeltrommel",
    		brand: "",
    		itype: "",
    		category: "Heimwerker",
    		deposit: "25",
    		parts: "1",
    		manual: "",
    		"package": "",
    		added: 1579824000000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/verlaengerungskabel/",
    		wc_id: "3353",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/01/5034.jpg",
    		highlight: "rgb(45, 144, 224)",
    		synonyms: "",
    		description: "mit 3 Steckdosen, 45m",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1616198400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8c0289af238f26-08bf-5a76-97b5-e55f6336ffa1",
    		id: 311,
    		name: "Getreidemühle",
    		brand: "Alnatura",
    		itype: "-",
    		category: "Küche",
    		deposit: 25,
    		parts: "8",
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "Originalkarton",
    		added: 1536019200000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/kueche/getreidemuehle/",
    		wc_id: "199",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/311.jpg",
    		highlight: "",
    		synonyms: "",
    		description: "2 Gummifüße fehlen",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1615766400000
    	},
    	{
    		_id: "6e8e3f8877ed77c2fc8efa41a8cd3b58fb328cd-33ea-5dc7-bc01-3391f1bf04b3",
    		id: 1900,
    		name: "Dekupiersäge",
    		brand: "Güde",
    		itype: "GDS 16 Elektronik",
    		category: "Heimwerker",
    		deposit: 55,
    		parts: 2,
    		manual: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/gedruckte-Bedienungsanleitung.pdf",
    		"package": "OriginalKarton",
    		added: 1558828800000,
    		status: "instock",
    		wc_url: "https://www.buergerstiftung-karlsruhe.de/leihlokal/sortiment/heimwerker/dekupiersaege-2/",
    		wc_id: "3002",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/05/2708.jpg",
    		highlight: "rgb(247, 239, 10)",
    		synonyms: "",
    		description: "",
    		exists_more_than_once: 0,
    		type: "item",
    		last_update: 1614988800000
    	},
    	{
    		_id: "8cc2f9de-7fb6-5bf1-b6e8-c4d79a334e37",
    		rented_on: 1616716800000,
    		to_return_on: 1617321600000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 4,
    		customer_name: "Luetkemeyers",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1614988800000,
    		remark: ""
    	},
    	{
    		_id: "acd86855-ae59-5523-8979-cad97d6ae77e",
    		rented_on: 1615420800000,
    		to_return_on: 1617235200000,
    		returned_on: 1616630400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1506.jpg",
    		item_id: 1506,
    		item_name: "el. Kettensäge",
    		customer_id: 5,
    		customer_name: "Ogelsby",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616284800000,
    		remark: ""
    	},
    	{
    		_id: "8dfa0546-d7b2-5c8a-ab7a-403e3a371bf0",
    		rented_on: 1614643200000,
    		to_return_on: 1615248000000,
    		returned_on: 1615248000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 58,
    		customer_name: "Langstone",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616803200000,
    		remark: ""
    	},
    	{
    		_id: "4a83c8c6-6eeb-5f82-823b-67a8c4af3463",
    		rented_on: 1615075200000,
    		to_return_on: 1616889600000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 56,
    		customer_name: "Face",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1616025600000,
    		remark: ""
    	},
    	{
    		_id: "558d0834-3671-5c59-b719-66fbd24933d3",
    		rented_on: 1616371200000,
    		to_return_on: 1618185600000,
    		returned_on: 1617580800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 51,
    		customer_name: "Crockett",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1616630400000,
    		remark: ""
    	},
    	{
    		_id: "85ef9170-d7e0-5622-808c-5df1d01d5fe4",
    		rented_on: 1616371200000,
    		to_return_on: 1618185600000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1506.jpg",
    		item_id: 1506,
    		item_name: "el. Kettensäge",
    		customer_id: 40,
    		customer_name: "Barbrick",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1616457600000,
    		remark: ""
    	},
    	{
    		_id: "1c52c90a-80f1-57b3-b4bb-2744f3fcc1be",
    		rented_on: 1616371200000,
    		to_return_on: 1617580800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 84,
    		customer_name: "Taunton.",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 5,
    		deposit_returned: 0,
    		last_update: 1616198400000,
    		remark: ""
    	},
    	{
    		_id: "08dfaf7c-36cf-521b-89dd-b07fc62951c3",
    		rented_on: 1614729600000,
    		to_return_on: 1615939200000,
    		returned_on: 1615593600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 58,
    		customer_name: "Langstone",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 5,
    		deposit_returned: 0,
    		last_update: 1616803200000,
    		remark: ""
    	},
    	{
    		_id: "83083740-445f-551b-ab07-22a8ba9791d7",
    		rented_on: 1615680000000,
    		to_return_on: 1616284800000,
    		returned_on: 1615680000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 59,
    		customer_name: "Orrice",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1615939200000,
    		remark: ""
    	},
    	{
    		_id: "14889f37b-3ce0-5655-87de-350439b31de0",
    		rented_on: 1616457600000,
    		to_return_on: 1617667200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 64,
    		customer_name: "Smyth",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1615334400000,
    		remark: ""
    	},
    	{
    		_id: "117b1b981-5d0f-5237-883c-03826beb6b59",
    		rented_on: 1614902400000,
    		to_return_on: 1616112000000,
    		returned_on: 1616716800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 85,
    		customer_name: "McCoish",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1616112000000,
    		remark: ""
    	},
    	{
    		_id: "13f38eb14-4c73-5093-8a10-ac6f17f86d38",
    		rented_on: 1616630400000,
    		to_return_on: 1618444800000,
    		returned_on: 1617840000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 66,
    		customer_name: "Clunan",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1616112000000,
    		remark: ""
    	},
    	{
    		_id: "13dfb4908-cdbb-52cc-8f1f-8da5bdf568a2",
    		rented_on: 1616198400000,
    		to_return_on: 1616803200000,
    		returned_on: 1616803200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 27,
    		customer_name: "Jaqueme",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1614643200000,
    		remark: ""
    	},
    	{
    		_id: "1a0fbb3dd-2bc5-5bc1-a0d7-c4b52c647f51",
    		rented_on: 1616112000000,
    		to_return_on: 1616716800000,
    		returned_on: 1616716800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 12,
    		customer_name: "Marushak",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1614556800000,
    		remark: ""
    	},
    	{
    		_id: "186be0416-7072-5a85-9dfe-0130104e6a69",
    		rented_on: 1614902400000,
    		to_return_on: 1616112000000,
    		returned_on: 1614902400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 30,
    		customer_name: "Costanza",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1615161600000,
    		remark: ""
    	},
    	{
    		_id: "1ae2f84f5-b6da-53fa-9d93-a87df897f288",
    		rented_on: 1615680000000,
    		to_return_on: 1617494400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 83,
    		customer_name: "Bendare",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1614556800000,
    		remark: ""
    	},
    	{
    		_id: "1e46579a9-e38f-5b61-96b1-56bb8be5245e",
    		rented_on: 1616198400000,
    		to_return_on: 1617408000000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 70,
    		customer_name: "Maltby",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 15,
    		deposit_returned: 0,
    		last_update: 1614643200000,
    		remark: ""
    	},
    	{
    		_id: "139276c9e-4e43-5cdb-8d59-53bdc7693d4b",
    		rented_on: 1615939200000,
    		to_return_on: 1617148800000,
    		returned_on: 1616544000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 40,
    		customer_name: "Barbrick",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1615420800000,
    		remark: ""
    	},
    	{
    		_id: "130d1a185-69a7-50c9-a569-9c1011c01601",
    		rented_on: 1614729600000,
    		to_return_on: 1616544000000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 30,
    		customer_name: "Costanza",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 15,
    		deposit_returned: 0,
    		last_update: 1616889600000,
    		remark: ""
    	},
    	{
    		_id: "2c50348ec-7f21-5f8b-bd12-2e7ca54c880d",
    		rented_on: 1615680000000,
    		to_return_on: 1617494400000,
    		returned_on: 1616889600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 25,
    		customer_name: "Kindred",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1616371200000,
    		remark: ""
    	},
    	{
    		_id: "20212d2c5-ece2-5e7b-9af9-5cc0a0e69251",
    		rented_on: 1616544000000,
    		to_return_on: 1617148800000,
    		returned_on: 1616544000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 29,
    		customer_name: "Clapperton",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1616803200000,
    		remark: ""
    	},
    	{
    		_id: "26c485a05-6497-5e8b-9f8a-6f2ae9ee6ca4",
    		rented_on: 1615593600000,
    		to_return_on: 1616803200000,
    		returned_on: 1616198400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 100,
    		customer_name: "Palluschek",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615420800000,
    		remark: ""
    	},
    	{
    		_id: "263371cbe-c60d-51f9-9b33-0e106d885067",
    		rented_on: 1616889600000,
    		to_return_on: 1618099200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 60,
    		customer_name: "Cruft",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "2061dfff1-c3f8-5939-8daa-8bad465c7910",
    		rented_on: 1616198400000,
    		to_return_on: 1618012800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 16,
    		customer_name: "Lainge",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1615766400000,
    		remark: ""
    	},
    	{
    		_id: "28db74051-3815-578a-9fdb-0b5a219ce617",
    		rented_on: 1616284800000,
    		to_return_on: 1617494400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 35,
    		customer_name: "Slym",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1614902400000,
    		remark: ""
    	},
    	{
    		_id: "2f30623d8-9e70-54cc-a7f0-07d85a367ca3",
    		rented_on: 1615507200000,
    		to_return_on: 1616112000000,
    		returned_on: 1616112000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 14,
    		customer_name: "Daville",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1616371200000,
    		remark: ""
    	},
    	{
    		_id: "21daa364b-01d2-51a1-9511-3d364f427cb5",
    		rented_on: 1616284800000,
    		to_return_on: 1616889600000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 73,
    		customer_name: "Kaley",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1615248000000,
    		remark: ""
    	},
    	{
    		_id: "2079442f1-49ff-5b79-939a-b4fdeccdf2c8",
    		rented_on: 1616457600000,
    		to_return_on: 1618272000000,
    		returned_on: 1617667200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 63,
    		customer_name: "Franz",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615593600000,
    		remark: ""
    	},
    	{
    		_id: "251ba7d92-7ff9-5dfe-96aa-7bb1affaa612",
    		rented_on: 1615939200000,
    		to_return_on: 1617148800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 40,
    		customer_name: "Barbrick",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1615680000000,
    		remark: ""
    	},
    	{
    		_id: "3d812c023-3e6d-573d-acf6-fe78d7e43be9",
    		rented_on: 1614556800000,
    		to_return_on: 1616371200000,
    		returned_on: 1615593600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 24,
    		customer_name: "Thomkins",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "3063cdcd0-cdbb-57c9-9b4e-e1a6e69c071f",
    		rented_on: 1614988800000,
    		to_return_on: 1616198400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 4,
    		customer_name: "Luetkemeyers",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1615248000000,
    		remark: ""
    	},
    	{
    		_id: "3665fdcb4-c9bf-56c3-9973-9f3d95c37539",
    		rented_on: 1614816000000,
    		to_return_on: 1616630400000,
    		returned_on: 1616025600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 32,
    		customer_name: "Cornwell",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1614902400000,
    		remark: ""
    	},
    	{
    		_id: "304b8f25d-583b-5e1b-9f01-0d1816f64104",
    		rented_on: 1614902400000,
    		to_return_on: 1615507200000,
    		returned_on: 1616112000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 31,
    		customer_name: "Sunderland",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616025600000,
    		remark: ""
    	},
    	{
    		_id: "32c13ed1a-1685-50fe-8048-e843ff7660d9",
    		rented_on: 1616112000000,
    		to_return_on: 1617926400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		item_id: 711,
    		item_name: "Küchenmaschine",
    		customer_id: 2,
    		customer_name: "Heaviside",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1616457600000,
    		remark: ""
    	},
    	{
    		_id: "349f0e515-fcfc-51e6-ba2f-7c0be7c204f8",
    		rented_on: 1616457600000,
    		to_return_on: 1617667200000,
    		returned_on: 1617062400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 90,
    		customer_name: "Frantsev",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1616889600000,
    		remark: ""
    	},
    	{
    		_id: "38efef905-baa6-5225-bbe6-3b8fd373bae4",
    		rented_on: 1615766400000,
    		to_return_on: 1616976000000,
    		returned_on: 1616371200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 8,
    		customer_name: "Bursnell",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1615248000000,
    		remark: ""
    	},
    	{
    		_id: "38cbabea8-260c-5e22-a1d7-4610fce25000",
    		rented_on: 1615766400000,
    		to_return_on: 1617580800000,
    		returned_on: 1616976000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 73,
    		customer_name: "Kaley",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1614643200000,
    		remark: ""
    	},
    	{
    		_id: "3143c7af2-596b-52a5-a9d9-25bb1b362ded",
    		rented_on: 1615334400000,
    		to_return_on: 1617148800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 52,
    		customer_name: "Sames",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 15,
    		deposit_returned: 0,
    		last_update: 1616889600000,
    		remark: ""
    	},
    	{
    		_id: "390880a08-9472-5153-8eee-2f5f78e17dbb",
    		rented_on: 1614816000000,
    		to_return_on: 1616025600000,
    		returned_on: 1615420800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1506.jpg",
    		item_id: 1506,
    		item_name: "el. Kettensäge",
    		customer_id: 86,
    		customer_name: "McAnalley",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615075200000,
    		remark: ""
    	},
    	{
    		_id: "4760a2462-feb1-5d67-ac74-8371ab5f7335",
    		rented_on: 1615680000000,
    		to_return_on: 1616889600000,
    		returned_on: 1616889600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 14,
    		customer_name: "Daville",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1615680000000,
    		remark: ""
    	},
    	{
    		_id: "4f736ec44-a48e-5d11-b50a-5efb116dc92d",
    		rented_on: 1614643200000,
    		to_return_on: 1616457600000,
    		returned_on: 1615852800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 96,
    		customer_name: "Tilston",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1615939200000,
    		remark: ""
    	},
    	{
    		_id: "4ae073cb1-c6bb-50ecF-8020-d27f8f1f8d81",
    		rented_on: 1615334400000,
    		to_return_on: 1616544000000,
    		returned_on: 1616544000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 24,
    		customer_name: "Thomkins",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "429fa87f9-0998-53ef-a8d0-794fa13f6b04",
    		rented_on: 1615939200000,
    		to_return_on: 1616544000000,
    		returned_on: 1616544000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 44,
    		customer_name: "Glanester",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1616544000000,
    		remark: ""
    	},
    	{
    		_id: "4cfe3e902-eef3-54cd-81b4-d0351af33277",
    		rented_on: 1616716800000,
    		to_return_on: 1617926400000,
    		returned_on: 1617321600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 87,
    		customer_name: "MacDermid",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1616889600000,
    		remark: ""
    	},
    	{
    		_id: "45d2b85c7-0ef6-5244-9fea-f4acf8c5f31a",
    		rented_on: 1615680000000,
    		to_return_on: 1616284800000,
    		returned_on: 1615680000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 71,
    		customer_name: "Kendle",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1615420800000,
    		remark: ""
    	},
    	{
    		_id: "49dd0d6cb-57a8-5bea-b9fe-106b4bdb5063",
    		rented_on: 1615852800000,
    		to_return_on: 1617667200000,
    		returned_on: 1617062400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 29,
    		customer_name: "Clapperton",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1616544000000,
    		remark: ""
    	},
    	{
    		_id: "4cb3881a6-f222-5991-9dbb-6d99898ecd8d",
    		rented_on: 1615939200000,
    		to_return_on: 1617753600000,
    		returned_on: 1617148800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 88,
    		customer_name: "Fumagall",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616025600000,
    		remark: ""
    	},
    	{
    		_id: "47fc3174b-156b-5024-82d2-e40b789e68d0",
    		rented_on: 1616457600000,
    		to_return_on: 1617062400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 98,
    		customer_name: "Costen",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1615334400000,
    		remark: ""
    	},
    	{
    		_id: "4c1116b7b-126c-5951-9575-87948e9b94a6",
    		rented_on: 1614729600000,
    		to_return_on: 1616544000000,
    		returned_on: 1615939200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 84,
    		customer_name: "Taunton.",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1614902400000,
    		remark: ""
    	},
    	{
    		_id: "5fb2ddea3-f9b6-5a8e-b1bf-19edb3f757fe",
    		rented_on: 1614988800000,
    		to_return_on: 1616198400000,
    		returned_on: 1615593600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 81,
    		customer_name: "Feeham",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1614988800000,
    		remark: ""
    	},
    	{
    		_id: "5b51c3d53-70a1-5589-a643-b443ae7a9f5e",
    		rented_on: 1615334400000,
    		to_return_on: 1616544000000,
    		returned_on: 1615939200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 2,
    		customer_name: "Heaviside",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1614816000000,
    		remark: ""
    	},
    	{
    		_id: "5c12e98a2-04f3-5bea-b557-9fe66d138576",
    		rented_on: 1615939200000,
    		to_return_on: 1616544000000,
    		returned_on: 1615939200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 39,
    		customer_name: "Broadbent",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1615161600000,
    		remark: ""
    	},
    	{
    		_id: "57248d749-bc1b-56e9-819f-9109aea6e170",
    		rented_on: 1615075200000,
    		to_return_on: 1616284800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 55,
    		customer_name: "Gabby",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1616198400000,
    		remark: ""
    	},
    	{
    		_id: "571427433-f108-5d53-ad02-8ddd02a960f8",
    		rented_on: 1616716800000,
    		to_return_on: 1617321600000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 65,
    		customer_name: "Mitchener",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 5,
    		deposit_returned: 0,
    		last_update: 1615593600000,
    		remark: ""
    	},
    	{
    		_id: "58544e7d6-a578-5887-9729-2a72a9af07ea",
    		rented_on: 1616889600000,
    		to_return_on: 1617494400000,
    		returned_on: 1616889600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 88,
    		customer_name: "Fumagall",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616630400000,
    		remark: ""
    	},
    	{
    		_id: "5b7980e2e-963e-579e-9d17-bbc8e629218c",
    		rented_on: 1616457600000,
    		to_return_on: 1618272000000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 38,
    		customer_name: "Tofful",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1615334400000,
    		remark: ""
    	},
    	{
    		_id: "59ec36db2-15bd-5675-aaa0-d24826f38df2",
    		rented_on: 1614729600000,
    		to_return_on: 1615939200000,
    		returned_on: 1615334400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 78,
    		customer_name: "Camillo",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1616803200000,
    		remark: ""
    	},
    	{
    		_id: "5f05dd97b-d738-5a5c-9aa6-8254e39ec0c4",
    		rented_on: 1615593600000,
    		to_return_on: 1616803200000,
    		returned_on: 1615593600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		item_id: 711,
    		item_name: "Küchenmaschine",
    		customer_id: 70,
    		customer_name: "Maltby",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1616803200000,
    		remark: ""
    	},
    	{
    		_id: "5c03a11bd-b1d9-5fb3-8c45-44a941629b80",
    		rented_on: 1616630400000,
    		to_return_on: 1617235200000,
    		returned_on: 1616630400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		item_id: 711,
    		item_name: "Küchenmaschine",
    		customer_id: 60,
    		customer_name: "Cruft",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1615075200000,
    		remark: ""
    	},
    	{
    		_id: "6d9ec58a9-744c-5b8d-b676-3a00f8baa34e",
    		rented_on: 1616803200000,
    		to_return_on: 1617408000000,
    		returned_on: 1616803200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5004.jpg",
    		item_id: 5004,
    		item_name: "Hammer",
    		customer_id: 67,
    		customer_name: "Windridge",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615939200000,
    		remark: ""
    	},
    	{
    		_id: "6f6f2a299-ca57-50b2-a1c9-7c696ea1c770",
    		rented_on: 1615852800000,
    		to_return_on: 1617667200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 98,
    		customer_name: "Costen",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 15,
    		deposit_returned: 0,
    		last_update: 1614729600000,
    		remark: ""
    	},
    	{
    		_id: "66339e2ec-bfb8-5cd2-b6c8-468398410b3b",
    		rented_on: 1615593600000,
    		to_return_on: 1616803200000,
    		returned_on: 1616803200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		item_id: 711,
    		item_name: "Küchenmaschine",
    		customer_id: 51,
    		customer_name: "Crockett",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "6cc35223d-a21f-519d-8a9f-ea67d3df92a2",
    		rented_on: 1614816000000,
    		to_return_on: 1616025600000,
    		returned_on: 1615420800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 54,
    		customer_name: "Quesne",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "6f6aaa958-44d3-5372-87d0-cac9e5da290b",
    		rented_on: 1616630400000,
    		to_return_on: 1617235200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 60,
    		customer_name: "Cruft",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1614816000000,
    		remark: ""
    	},
    	{
    		_id: "64b14492c-c9d6-5a92-bf1c-5acce7baebb3",
    		rented_on: 1616112000000,
    		to_return_on: 1617926400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 10,
    		customer_name: "Maceur",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 5,
    		deposit_returned: 0,
    		last_update: 1615334400000,
    		remark: ""
    	},
    	{
    		_id: "6f932675f-35a2-5645-a126-f798294ef141",
    		rented_on: 1615852800000,
    		to_return_on: 1617062400000,
    		returned_on: 1616457600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 83,
    		customer_name: "Bendare",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1614816000000,
    		remark: ""
    	},
    	{
    		_id: "64a6bcd81-ef4b-53d0-8ccf-12867e8cca8d",
    		rented_on: 1615161600000,
    		to_return_on: 1616371200000,
    		returned_on: 1616371200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 84,
    		customer_name: "Taunton.",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1615939200000,
    		remark: ""
    	},
    	{
    		_id: "60a09315e-4e3f-5244-bbb6-beab7389ccd6",
    		rented_on: 1615680000000,
    		to_return_on: 1616284800000,
    		returned_on: 1616284800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 97,
    		customer_name: "Beddin",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1616284800000,
    		remark: ""
    	},
    	{
    		_id: "62d65ad9e-bd4d-5200-89db-e52576328a8b",
    		rented_on: 1616025600000,
    		to_return_on: 1617235200000,
    		returned_on: 1616630400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 42,
    		customer_name: "Fieldgate",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "72437df33-6aad-5110-9402-184d3fc86c7e",
    		rented_on: 1614816000000,
    		to_return_on: 1615420800000,
    		returned_on: 1614816000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		item_id: 711,
    		item_name: "Küchenmaschine",
    		customer_id: 75,
    		customer_name: "Curlis",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1615334400000,
    		remark: ""
    	},
    	{
    		_id: "766a2bb77-231c-5453-a4e6-8b35217e4d96",
    		rented_on: 1615507200000,
    		to_return_on: 1617321600000,
    		returned_on: 1616716800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5004.jpg",
    		item_id: 5004,
    		item_name: "Hammer",
    		customer_id: 42,
    		customer_name: "Fieldgate",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 15,
    		deposit_returned: 15,
    		last_update: 1616112000000,
    		remark: ""
    	},
    	{
    		_id: "7910c99f0-a5e4-543c-816d-b00475c2483b",
    		rented_on: 1616198400000,
    		to_return_on: 1617408000000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 60,
    		customer_name: "Cruft",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 10,
    		deposit_returned: 0,
    		last_update: 1615766400000,
    		remark: ""
    	},
    	{
    		_id: "759f2f761-f87e-5124-9a0e-21bc38fefd5c",
    		rented_on: 1614729600000,
    		to_return_on: 1615334400000,
    		returned_on: 1614729600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 82,
    		customer_name: "Aliman",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1615507200000,
    		remark: ""
    	},
    	{
    		_id: "7ac326c89-6a24-58ae-85b1-d2fde7308f18",
    		rented_on: 1614643200000,
    		to_return_on: 1616457600000,
    		returned_on: 1615593600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1506.jpg",
    		item_id: 1506,
    		item_name: "el. Kettensäge",
    		customer_id: 11,
    		customer_name: "Kubicek",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 5,
    		deposit_returned: 0,
    		last_update: 1615766400000,
    		remark: ""
    	},
    	{
    		_id: "7875feb32-aec8-5ed4-ab7d-7ae2a44b146f",
    		rented_on: 1615507200000,
    		to_return_on: 1616716800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5004.jpg",
    		item_id: 5004,
    		item_name: "Hammer",
    		customer_id: 23,
    		customer_name: "Jiggins",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1616198400000,
    		remark: ""
    	},
    	{
    		_id: "7c8594d62-c8f1-52eb-8a3c-0cd12a7c46f5",
    		rented_on: 1614729600000,
    		to_return_on: 1616544000000,
    		returned_on: 1615939200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 50,
    		customer_name: "Markussen",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1616889600000,
    		remark: ""
    	},
    	{
    		_id: "7e8bbb0c4-2e1b-59e0-8c22-4b15eabbf232",
    		rented_on: 1615334400000,
    		to_return_on: 1616544000000,
    		returned_on: 1615939200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/1506.jpg",
    		item_id: 1506,
    		item_name: "el. Kettensäge",
    		customer_id: 34,
    		customer_name: "Dalglish",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1615852800000,
    		remark: ""
    	},
    	{
    		_id: "7f33cb20c-e8b5-5b97-ade8-a9528efb7fe2",
    		rented_on: 1616630400000,
    		to_return_on: 1617235200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/711.jpg",
    		item_id: 711,
    		item_name: "Küchenmaschine",
    		customer_id: 93,
    		customer_name: "Grise",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 50,
    		deposit_returned: 0,
    		last_update: 1615939200000,
    		remark: ""
    	},
    	{
    		_id: "7085b2bed-980a-5b54-8368-48dc735afd79",
    		rented_on: 1616889600000,
    		to_return_on: 1618704000000,
    		returned_on: 1618099200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 32,
    		customer_name: "Cornwell",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1614556800000,
    		remark: ""
    	},
    	{
    		_id: "85caddd2f-76e2-52cc-bae3-4a5081037b81",
    		rented_on: 1615420800000,
    		to_return_on: 1616630400000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 78,
    		customer_name: "Camillo",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1616284800000,
    		remark: ""
    	},
    	{
    		_id: "84b2db8e8-09cd-5c46-9f78-19b9d85f4097",
    		rented_on: 1615420800000,
    		to_return_on: 1617235200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/04/6114.jpg",
    		item_id: 1919,
    		item_name: "Dörr-Automat",
    		customer_id: 33,
    		customer_name: "Phifer",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 5,
    		deposit_returned: 0,
    		last_update: 1615334400000,
    		remark: ""
    	},
    	{
    		_id: "88949f181-e8a8-5b11-b2a1-aa7234106e71",
    		rented_on: 1614816000000,
    		to_return_on: 1616025600000,
    		returned_on: 1616630400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 67,
    		customer_name: "Windridge",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1616889600000,
    		remark: ""
    	},
    	{
    		_id: "83714553a-e203-55ff-90d3-41d6f478bcee",
    		rented_on: 1614988800000,
    		to_return_on: 1615593600000,
    		returned_on: 1615593600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 2,
    		customer_name: "Heaviside",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1616284800000,
    		remark: ""
    	},
    	{
    		_id: "89c97bb5a-eeef-52a0-a45d-25a669e7369c",
    		rented_on: 1614816000000,
    		to_return_on: 1615420800000,
    		returned_on: 1616025600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 51,
    		customer_name: "Crockett",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1616630400000,
    		remark: ""
    	},
    	{
    		_id: "8b3469f5c-b07f-5823-bf74-25c62020ec50",
    		rented_on: 1616457600000,
    		to_return_on: 1617667200000,
    		returned_on: 1617062400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 85,
    		customer_name: "McCoish",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1615075200000,
    		remark: ""
    	},
    	{
    		_id: "849dd59fc-b72d-501b-b162-e4b4289539b7",
    		rented_on: 1614729600000,
    		to_return_on: 1615334400000,
    		returned_on: 1615334400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/02/15.jpg",
    		item_id: 15,
    		item_name: "Stichsäge",
    		customer_id: 84,
    		customer_name: "Taunton.",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1614556800000,
    		remark: ""
    	},
    	{
    		_id: "8b676f1ce-5e6d-5c43-bcf5-ff9e344f746b",
    		rented_on: 1615507200000,
    		to_return_on: 1616112000000,
    		returned_on: 1615507200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 55,
    		customer_name: "Gabby",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1616198400000,
    		remark: ""
    	},
    	{
    		_id: "83bfa8f4d-5654-5a72-b1a9-b2fc5ca0d26c",
    		rented_on: 1616371200000,
    		to_return_on: 1618185600000,
    		returned_on: 1617580800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 61,
    		customer_name: "Attyeo",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1615852800000,
    		remark: ""
    	},
    	{
    		_id: "8742dafcc-9ad1-50f8-b644-454a551574c0",
    		rented_on: 1615766400000,
    		to_return_on: 1617580800000,
    		returned_on: 1616976000000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 6,
    		customer_name: "Sheilds",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1614902400000,
    		remark: ""
    	},
    	{
    		_id: "97aea42e4-0d90-545b-be80-684ca1d96501",
    		rented_on: 1616198400000,
    		to_return_on: 1616803200000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 99,
    		customer_name: "Fallis",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 15,
    		deposit_returned: 0,
    		last_update: 1614729600000,
    		remark: ""
    	},
    	{
    		_id: "9229dcb25-1481-52e9-889f-6e7f1af2ff6d",
    		rented_on: 1615420800000,
    		to_return_on: 1617235200000,
    		returned_on: 1616630400000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 10,
    		customer_name: "Maceur",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1614902400000,
    		remark: ""
    	},
    	{
    		_id: "993e1c6a4-e049-5682-ac08-f839ee5eaeee",
    		rented_on: 1615766400000,
    		to_return_on: 1616371200000,
    		returned_on: 1616371200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/11/5059.jpg",
    		item_id: 5059,
    		item_name: "Kabeltrommel",
    		customer_id: 23,
    		customer_name: "Jiggins",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616544000000,
    		remark: ""
    	},
    	{
    		_id: "9a86f6124-9667-5f68-94c0-93b82d4cac18",
    		rented_on: 1616544000000,
    		to_return_on: 1618358400000,
    		returned_on: 1617753600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 32,
    		customer_name: "Cornwell",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1615248000000,
    		remark: ""
    	},
    	{
    		_id: "989020351-67c5-5a3e-84e4-86d4b6de4255",
    		rented_on: 1616889600000,
    		to_return_on: 1617494400000,
    		returned_on: 1616889600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/10/2906.jpg",
    		item_id: 2906,
    		item_name: "Bohrmaschine",
    		customer_id: 95,
    		customer_name: "Govan",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1615766400000,
    		remark: ""
    	},
    	{
    		_id: "9d43739ce-6644-5e5b-bedf-d81225a4d2aa",
    		rented_on: 1616803200000,
    		to_return_on: 1617408000000,
    		returned_on: 1616803200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 40,
    		customer_name: "Barbrick",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 200,
    		deposit_returned: 200,
    		last_update: 1614729600000,
    		remark: ""
    	},
    	{
    		_id: "9245b89ca-a593-5b1a-a865-7d3b9101e934",
    		rented_on: 1616371200000,
    		to_return_on: 1618185600000,
    		returned_on: 1617580800000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 86,
    		customer_name: "McAnalley",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 5,
    		deposit_returned: 5,
    		last_update: 1616457600000,
    		remark: ""
    	},
    	{
    		_id: "97c59fc88-a15e-5f75-ac5e-faac5f93052e",
    		rented_on: 1615161600000,
    		to_return_on: 1616976000000,
    		returned_on: 1616371200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/03/715.jpg",
    		item_id: 715,
    		item_name: "Multi-Elektrosäge",
    		customer_id: 95,
    		customer_name: "Govan",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 10,
    		deposit_returned: 10,
    		last_update: 1616544000000,
    		remark: ""
    	},
    	{
    		_id: "9b8da7a1b-4d1a-5f39-ad30-c1fe61fd0396",
    		rented_on: 1615161600000,
    		to_return_on: 1615766400000,
    		returned_on: 1616889600000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5002.jpg",
    		item_id: 5002,
    		item_name: "Schraubenschlüssel",
    		customer_id: 90,
    		customer_name: "Frantsev",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1616716800000,
    		remark: ""
    	},
    	{
    		_id: "9c946e17a-baee-5dd0-bdf7-caedd6f86bc4",
    		rented_on: 1615334400000,
    		to_return_on: 1617148800000,
    		returned_on: 0,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2020/05/814.jpg",
    		item_id: 830,
    		item_name: "Silikonspritze",
    		customer_id: 100,
    		customer_name: "Palluschek",
    		passing_out_employee: "ABC",
    		receiving_employee: "",
    		deposit: 200,
    		deposit_returned: 0,
    		last_update: 1614556800000,
    		remark: ""
    	},
    	{
    		_id: "1053f48fbb-5c1f-505b-8a02-be7463d9edb2",
    		rented_on: 1616803200000,
    		to_return_on: 1617408000000,
    		returned_on: 1616803200000,
    		extended_on: 0,
    		type: "rental",
    		image: "https://www.buergerstiftung-karlsruhe.de/wp-content/uploads/2019/04/5004.jpg",
    		item_id: 5004,
    		item_name: "Hammer",
    		customer_id: 77,
    		customer_name: "Spare",
    		passing_out_employee: "ABC",
    		receiving_employee: "ABC",
    		deposit: 50,
    		deposit_returned: 50,
    		last_update: 1615766400000,
    		remark: ""
    	}
    ];
    var testdata = {
    	docs: docs
    };

    class SelectorBuilder {
      constructor() {
        this.selectors = [];
        this.currentFieldName = "";
      }

      regexIgnoreCaseAndDiactricis(content) {
        // returns a regex with content that has diacricits ignored
        let accentGroups = [
          "aâãäåæ",
          "eéèêë",
          "iíìîï",
          "oóòôõöø",
          "uúùûü",
          "cç",
          "nñ",
          "yýÿ",
        ];

        let regex = content;
        let accentGroup;
        let accent;
        for (accentGroup of accentGroups) {
          for (accent of accentGroup) {
            if (content.includes(accent)) {
              regex = regex.replace(accent, `(?:${accentGroup.split('').join('|')})`);
            }
          }
        }
        return "(?i)" + regex;
      }

      regexIgnoreCase(content) {
        return "(?i)" + content;
      }

      withField(fieldName) {
        this.currentFieldName = fieldName;
        return this;
      }

      withDocType(docType) {
        this.selectors.push({
          type: {
            $eq: docType,
          },
        });
        return this;
      }

      containsIgnoreCase(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $regex: this.regexIgnoreCase(value),
          },
        });
        return this;
      }

      startsWithIgnoreCaseAndDiacritics(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $regex: this.regexIgnoreCaseAndDiactricis("^" + value),
          },
        });
        return this;
      }

      startsWithIgnoreCase(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $regex: this.regexIgnoreCase("^" + value),
          },
        });
        return this;
      }

      startsWithIgnoreCaseAndLeadingZeros(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $regex: this.regexIgnoreCase("^(0+)?" + value),
          },
        });
        return this;
      }

      numericFieldStartsWith(value) {
        value = parseInt(value);
        if (value === 0) return this;

        // e.g. 12 => 120 - 129, 1200 - 1299
        const selectorsForNumbersStartingWith = (factor = 10, selectors = []) => {
          selectors.push({
            $and: [
              {
                [this.currentFieldName]: {
                  $gte: value * factor,
                },
              },
              {
                [this.currentFieldName]: {
                  $lt: value * factor + factor,
                },
              },
            ],
          });
          if (value * factor * 10 > 10000) {
            return selectors;
          } else {
            return selectorsForNumbersStartingWith(factor * 10, selectors);
          }
        };
        this.selectors.push({
          $or: [
            {
              [this.currentFieldName]: {
                $eq: value,
              },
            },
            ...selectorsForNumbersStartingWith(),
          ],
        });
        return this;
      }

      equals(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $eq: value,
          },
        });
        return this;
      }

      isNotEqualTo(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $ne: value,
          },
        });
        return this;
      }

      greaterThan(value) {
        this.selectors.push({
          [this.currentFieldName]: {
            $gt: value,
          },
        });
        return this;
      }

      withAny(anySelectors) {
        this.selectors.push({
          $or: anySelectors,
        });
        return this;
      }

      searchTerm(searchTerm, columns) {
        const formattedSearchTerm = searchTerm.toLowerCase();
        const searchTermWords = formattedSearchTerm
          .split(" ")
          .map((searchTerm) => searchTerm.trim())
          .filter((searchTerm) => searchTerm !== "");

        // e.g. 12 => 120 - 129, 1200 - 1299
        const selectorsForNumbersStartingWith = (
          searchWord,
          column,
          factor = 10,
          selectors = []
        ) => {
          const number = Math.abs(parseInt(searchWord, 10));
          if (number === 0) {
            // 000 -> 0001 - 0009
            // 00 -> 0010 - 0099
            // 0 -> 0001 - 0009
            return [
              {
                $and: [
                  {
                    [column.key]: {
                      $gte: 1000 / Math.pow(10, searchWord.length),
                    },
                  },
                  {
                    [column.key]: {
                      $lt: 1000 / Math.pow(10, searchWord.length - 1),
                    },
                  },
                ],
              },
            ];
          } else {
            selectors.push({
              $and: [
                {
                  [column.key]: {
                    $gte: number * factor,
                  },
                },
                {
                  [column.key]: {
                    $lt: number * factor + factor,
                  },
                },
              ],
            });
          }
          if (number * factor * 10 > 10000) {
            return selectors;
          } else {
            return selectorsForNumbersStartingWith(
              searchWord,
              column,
              factor * 10,
              selectors
            );
          }
        };

        const selectorsForSearchWord = (searchWord) => {
          if (!isNaN(searchWord)) {
            // is number
            let selectors = [];
            columnsToSearch(true).forEach((column) => {
              selectors.push({
                [column.key]: {
                  $eq: parseInt(searchWord, 10),
                },
              });
              selectors = [
                ...selectors,
                ...selectorsForNumbersStartingWith(searchWord, column),
              ];
            });
            return selectors;
          } else {
            // is not a number
            return columnsToSearch(false).map((column) => ({
              [column.key]: {
                $regex:
                  "(?i)" +
                  (column?.search === "from_beginning" ? "^(0+?)?" : "") +
                  searchWord,
              },
            }));
          }
        };

        const columnsToSearch = (numericSearchTerm = false) =>
          columns
            .filter(
              (column) =>
                (!numericSearchTerm && !column.numeric) ||
                (numericSearchTerm && column.numeric)
            )
            .filter((column) => !column.search || column.search !== "exclude");

        this.selectors = [
          {
            $and: searchTermWords.map((searchTermWord) => ({
              $or: selectorsForSearchWord(searchTermWord),
            })),
          },
        ];
        return this;
      }

      build() {
        if (this.selectors.length == 1) {
          return this.selectors[0];
        } else {
          return {
            $and: this.selectors,
          };
        }
      }

      buildSelectors() {
        return this.selectors;
      }
    }

    class MockDatabase {
      onConnectedCallback;
      constructor() {
        this.data = testdata.docs;
        this.writeData(this.data);
      }

      onConnected(onConnectedCallback) {
        this.onConnectedCallback = onConnectedCallback;
      }

      async connect() {
        if (this.onConnectedCallback) this.onConnectedCallback();
      }

      matchesSelector(doc, selector) {
        for (const [selectorKey, selectorObj] of Object.entries(selector)) {
          if (!selector.hasOwnProperty(selectorKey)) {
            continue;
          }
          if (selectorKey === "$or") {
            return selectorObj.some((innerSelector) =>
              this.matchesSelector(doc, innerSelector)
            );
          } else if (selectorKey === "$and") {
            return selectorObj.every((innerSelector) =>
              this.matchesSelector(doc, innerSelector)
            );
          } else {
            let comparator = Object.keys(selectorObj)[0];
            let value = doc[selectorKey];
            let compareToValue = selectorObj[comparator];

            if (comparator === "$eq") {
              return value === compareToValue;
            } else if (comparator === "$ne") {
              return value !== compareToValue;
            } else if (comparator === "$gte") {
              return value >= compareToValue;
            } else if (comparator === "$gt") {
              return value > compareToValue;
            } else if (comparator === "$lte") {
              return value <= compareToValue;
            } else if (comparator === "$lt") {
              return value < compareToValue;
            } else if (comparator === "$exists") {
              return (typeof value !== "undefined") === compareToValue;
            } else if (comparator === "$regex") {
              if (compareToValue.startsWith("(?i)")) {
                compareToValue = new RegExp(
                  compareToValue.replaceAll("(?i)", ""),
                  "i"
                );
              }
              return value && value.match(compareToValue);
            } else {
              console.warn("unknown comparator: " + comparator);
              return false;
            }
          }
        }
      }

      async itemWithIdExists(id) {
        let docs = this.getData().filter(
          (doc) => doc.type === "item" && doc.id === id
        );
        return docs.length > 0;
      }

      async fetchRentalByItemAndCustomerIds(itemId, customerId) {
        let docs = this.getData().filter(
          (doc) =>
            doc.type === "rental" &&
            doc.item_id === itemId &&
            doc.customer_id === customerId
        );
        return docs.length > 0 ? docs[0] : {};
      }

      async query(options) {
        let {
          filters,
          sortBy,
          sortReverse,
          rowsPerPage,
          currentPage,
          searchTerm,
          docType,
          columns,
        } = options;

        let selectors = filters.flatMap((filter) => filter.selectors);
        selectors.push({
          type: {
            $eq: docType,
          },
        });

        // filter
        let dataMatchingFilter = this.getData().filter((doc) =>
          this.matchesSelector(doc, { $and: selectors })
        );
        searchTerm = searchTerm.trim().toLowerCase();
        if (searchTerm.length > 0) {
          dataMatchingFilter = dataMatchingFilter.filter((doc) =>
            searchTerm.split(" ").every((searchWord) =>
              Object.entries(doc)
                .filter(([key, value]) => columns.find((col) => col.key === key))
                .filter(
                  ([key, value]) =>
                    columns.find((col) => col.key === key).search !== "exclude"
                )
                .filter(
                  ([key, value]) =>
                    (columns.find((col) => col.key === key).numeric &&
                      !isNaN(searchWord)) ||
                    (!columns.find((col) => col.key === key).numeric &&
                      isNaN(searchWord))
                )
                .some(([key, value]) =>
                  String(doc[key]).toLowerCase().includes(searchWord)
                )
            )
          );
        }

        // sort
        let sortedData = dataMatchingFilter.sort(function (a, b) {
          let i = 0;
          let result = 0;
          while (i < sortBy.length && result === 0) {
            result =
              a[sortBy[i]] < b[sortBy[i]]
                ? -1
                : a[sortBy[i]] > b[sortBy[i]]
                ? 1
                : 0;
            i++;
          }
          if (sortReverse) {
            result *= -1;
          }
          return result;
        });

        // paginate
        let paginatedData = sortedData.slice(
          rowsPerPage * currentPage,
          rowsPerPage * currentPage + rowsPerPage
        );

        return {
          docs: paginatedData,
          count: Promise.resolve(dataMatchingFilter.length),
        };
      }

      cancelListenerForDocType(docType) {}

      async listenForChanges(onDocsChanged, docType) {}

      async updateDoc(updatedDoc) {
        await this.removeDoc(updatedDoc);
        return await this.createDoc(updatedDoc);
      }

      async removeDoc(docToRemove) {
        this.writeData(this.getData().filter((doc) => doc._id !== docToRemove._id));
      }

      async createDoc(doc) {
        const makeId = () => {
          var result = "";
          var characters =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          var charactersLength = characters.length;
          for (var i = 0; i < 10; i++) {
            result += characters.charAt(
              Math.floor(Math.random() * charactersLength)
            );
          }
          return result;
        };

        if (!doc.hasOwnProperty("_id")) {
          doc["_id"] = makeId();
          doc["_rev"] = makeId();
        }
        this.writeData([...this.getData(), doc]);
        return doc;
      }

      async createIndex(index) {}

      async nextUnusedId(docType) {
        let usedIds = this.getData()
          .filter((doc) => doc.type === docType)
          .map((doc) => doc.id);
        return Math.max(...usedIds) + 1;
      }

      async findCached(options) {
        return this.fetchAllDocsBySelector(options.selector, options.fields).then(
          (docs) => ({
            docs,
          })
        );
      }

      async fetchDocsBySelector(selector, fields) {
        return this.getData()
          .filter((doc) => this.matchesSelector(doc, selector))
          .map((doc) => {
            if (fields) {
              let docWithFields = {};
              fields.forEach((field) => (docWithFields[field] = doc[field]));
              return docWithFields;
            } else {
              return doc;
            }
          });
      }

      async fetchUniqueCustomerFieldValues(field, startsWith, isNumeric = false) {
        let customers = this.getData().filter(
          (doc) =>
            doc.type === "customer" &&
            doc[field] &&
            String(doc[field]).startsWith(String(startsWith))
        );
        const uniqueValues = new Set();
        customers.forEach((customer) => {
          uniqueValues.add(customer[field]);
        });
        return Array.from(uniqueValues).map((uniqueValue) => ({
          [field]: uniqueValue,
        }));
      }

      fetchByType(type) {
        return this.fetchDocsBySelector(
          this.selectorBuilder().withDocType(type).build(),
          ["_id"]
        );
      }

      fetchByIdAndType(id, type) {
        return this.fetchDocsBySelector(
          this.selectorBuilder()
            .withDocType(type)
            .withField("id")
            .equals(parseInt(id))
            .build(),
          ["_id"]
        );
      }

      fetchAllDocsBySelector(selector, fields) {
        return this.fetchDocsBySelector(selector, fields);
      }

      getData() {
        if (localStorage.hasOwnProperty("data")) {
          return JSON.parse(localStorage.getItem("data"));
        } else {
          return [];
        }
      }

      fetchAll() {
        return this.getData();
      }

      writeData(data) {
        localStorage.setItem("data", JSON.stringify(data));
      }

      selectorBuilder() {
        return new SelectorBuilder();
      }
    }

    var Database = new MockDatabase();

    function saveParseTimestampToString(millis) {
      const date = new Date(millis);
      if (isNaN(date) || date.getTime() === 0) return "";
      else
        return `${String(date.getDate()).padStart(2, 0)}.${String(
      date.getMonth() + 1
    ).padStart(2, 0)}.${date.getFullYear()}`;
    }

    function saveParseTimestampToHumanReadableString(millis) {
      const date = new Date(millis);
      let dayDiff = daysBetween(millis, millisAtStartOfToday());

      if (isNaN(date) || date.getTime() === 0) return "";
      else if (dayDiff >= -2 && dayDiff <= 2) {
        switch (dayDiff) {
          case -2:
            return "Vorgestern";
          case -1:
            return "Gestern";
          case 0:
            return "Heute";
          case 1:
            return "Morgen";
          case 2:
            return "Übermorgen";
        }
      } else if (dayDiff >= -7 && dayDiff < 0) {
        return `Vor ${Math.abs(dayDiff)} Tagen`;
      } else if (dayDiff <= 7 && dayDiff > 0) {
        return `In ${dayDiff} Tagen`;
      } else
        return `${String(date.getDate()).padStart(2, 0)}.${String(
      date.getMonth() + 1
    ).padStart(2, 0)}.${date.getFullYear()}`;
    }

    function saveParseStringToBoolean(maybeBoolean) {
      return ["true", "ja"].includes(String(maybeBoolean).toLowerCase());
    }

    function millisAtStartOfDay(millis) {
      var msPerDay = 86400 * 1000;
      return millis - (millis % msPerDay);
    }

    function millisAtStartOfToday() {
      return millisAtStartOfDay(new Date().getTime());
    }

    function daysBetween(date1, date2) {
      // The number of milliseconds in one day
      const ONE_DAY = 1000 * 60 * 60 * 24;
      // Calculate the difference in milliseconds
      const differenceMs = date1 - date2;
      // Convert back to days and return
      return Math.round(differenceMs / ONE_DAY);
    }

    const ColorDefs = Object.freeze({
      HIGHLIGHT_RED: "rgb(250, 45, 30)",
      HIGHLIGHT_GREEN: "rgb(131, 235, 52)",
      HIGHLIGHT_BLUE: "rgb(45, 144, 224)",
      HIGHLIGHT_YELLOW: "rgb(247, 239, 10)",

      ITEM_RESERVED: "rgb(255, 155, 25)",

      RENTAL_RETURNED_TODAY_GREEN: "rgb(214, 252, 208)",
      RENTAL_LATE_RED: "rgb(240, 200, 200)",
      RENTAL_TO_RETURN_TODAY_BLUE: "rgb(160, 200, 250)",

      DEFAULT_ROW_BACKGROUND_ODD: "rgb(255, 255, 255)",
      DEFAULT_ROW_BACKGROUND_EVEN: "rgb(242, 242, 242)",
    });

    const customerColorToDescription = (color) => {
      switch (color) {
        case ColorDefs.HIGHLIGHT_GREEN:
          return "Grün, ist Teil des Teams";
        case ColorDefs.HIGHLIGHT_YELLOW:
          return "Gelb";
        case ColorDefs.HIGHLIGHT_RED:
          return "Rot, ACHTUNG, bitte nachsehen";
        case ColorDefs.HIGHLIGHT_BLUE:
          return "Blau";
      }
      return "unbekannte Markierung, bitte nachsehen";
    };

    const itemColorToDescription = (color) => {
      switch (color) {
        case ColorDefs.HIGHLIGHT_GREEN:
          return "Grün, hängt eventuell vorne im Schaufenster";
        case ColorDefs.HIGHLIGHT_YELLOW:
          return "Gelb, hängt eventuell vorne im Schaufenster";
        case ColorDefs.HIGHLIGHT_RED:
          return "Rot, ACHTUNG, etwas könnte mit dem Gegenstand nicht in Ordnung sein oder muss beachtet werden";
        case ColorDefs.HIGHLIGHT_BLUE:
          return "Blau";
      }
      return "Unbekannte farbliche Markierung, bitte nachsehen";
    };

    const backgroundColor$1 = async (item) => item.highlight;
    const backgroundColorStatus = async (item) =>
      item.status == "reserved" ? ColorDefs.ITEM_RESERVED : item.highlight;

    var itemColumns = [
      {
        title: "Id",
        key: "id",
        numeric: true,
        display: (value) => String(value).padStart(4, "0"),
        search: "from_beginning",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Bild",
        key: "image",
        isImageUrl: true,
        search: "exclude",
        disableSort: true,
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Gegenstand",
        key: "name",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Marke",
        key: "brand",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Typbezeichnung",
        key: "itype",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Kategorie",
        key: "category",
        search: "exclude",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Pfand",
        key: "deposit",
        search: "exclude",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Anzahl Teile",
        key: "parts",
        search: "exclude",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Erfasst am",
        key: "added",
        display: (value) => saveParseTimestampToString(value),
        search: "exclude",
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Beschreibung",
        key: "description",
        search: "exclude",
        disableSort: true,
        backgroundColor: backgroundColor$1,
      },
      {
        title: "Synonyme",
        key: "synonyms",
        disableSort: true,
        backgroundColor: backgroundColor$1,
        hideInTable: true,
      },
      {
        title: "Status",
        key: "status",
        search: "exclude",
        display: (value) => {
          if (value === "deleted") return "gelöscht";
          if (value === "instock") return "verfügbar";
          if (value === "outofstock") return "verliehen";
          if (value === "reserved") return "reserviert";
          if (value === "onbackorder") return "nicht verleihbar";
          if (value === "lost") return "verschollen";
          if (value === "repairing") return "in Reparatur";
          if (value === "forsale") return "zu verkaufen";
        },
        backgroundColor: backgroundColorStatus,
      },

      {
        title: "Anzahl Ausleihen",
        key: "rental_count",
        search: "exclude",
        disableSort: true,
        displayExport: (allDocs, item_id) => allDocs.filter((doc) => doc.type === "rental" && doc.item_id === item_id).length,
        backgroundColor: backgroundColor$1,
      },
    ];

    const backgroundColor = async (customer) => customer.highlight;

    var customerColumns = [
      {
        title: "Id",
        key: "id",
        numeric: true,
        search: "from_beginning",
        backgroundColor,
      },
      {
        title: "Nachname",
        key: "lastname",
        backgroundColor,
      },
      {
        title: "Vorname",
        key: "firstname",
        backgroundColor,
      },
      {
        title: "Straße",
        key: "street",
        search: "exclude",
        backgroundColor,
      },
      {
        title: "Hausnummer",
        key: "house_number",
        search: "exclude",
        disableSort: true,
        backgroundColor,
        hideInTable: true,
      },
      {
        title: "Postleitzahl",
        key: "postal_code",
        search: "exclude",
        backgroundColor,
        hideInTable: true,
      },
      {
        title: "Stadt",
        key: "city",
        search: "exclude",
        backgroundColor,
      },
      {
        title: "Beitritt",
        key: "registration_date",
        display: (value) => saveParseTimestampToString(value),
        search: "exclude",
        backgroundColor,
      },
      {
        title: "Verlängert am",
        key: "renewed_on",
        display: (value) => saveParseTimestampToString(value),
        search: "exclude",
        backgroundColor,
      },
      {
        title: "Bemerkung",
        key: "remark",
        search: "exclude",
        disableSort: true,
        backgroundColor,
      },
      {
        title: "E-Mail",
        key: "email",
        search: "exclude",
        disableSort: true,
        backgroundColor,
      },
      {
        title: "Telefonnummer",
        key: "telephone_number",
        display: (value) => {
          if (!value) return value;
          let formattedValue = value.replace(/ /g, "");
          if (formattedValue.startsWith("+")) {
            formattedValue = formattedValue.replace(
              /(\d{5})(\d{4})(\d{1,})/,
              "$1 $2 $3"
            );
          } else {
            formattedValue = formattedValue.replace(
              /(\d{4})(\d{4})(\d{1,})/,
              "$1 $2 $3"
            );
          }
          return formattedValue;
        },
        search: "exclude",
        disableSort: true,
        backgroundColor,
      },
      {
        title: "Newsletter",
        key: "subscribed_to_newsletter",
        display: (value) => (saveParseStringToBoolean(value) ? "Ja" : "Nein"),
        search: "exclude",
        backgroundColor,
      },
      {
        title: "Aufmerksam geworden",
        key: "heard",
        search: "exclude",
        backgroundColor,
      },
      {
        title: "Aktive Ausleihen",
        key: "active_rental_count",
        search: "exclude",
        disableSort: true,
        displayExport: (allDocs, customer_id) =>
          allDocs.filter(
            (doc) =>
              doc.type === "rental" &&
              doc.customer_id === customer_id &&
              doc.returned_on === 0
          ).length,
        backgroundColor,
      },
      {
        title: "Ausleihen Insgesamt",
        key: "rental_count",
        search: "exclude",
        disableSort: true,
        displayExport: (allDocs, customer_id) =>
          allDocs.filter(
            (doc) => doc.type === "rental" && doc.customer_id === customer_id
          ).length,
        backgroundColor,
      },
    ];

    const hasReturnDate = (rental) => rental.returned_on && rental.returned_on > 0;
    const hasBeenReturnedToday = (rental) =>
      hasReturnDate(rental) && rental.returned_on === millisAtStartOfToday();
    const shouldBeReturnedToday = (rental) =>
      rental.to_return_on &&
      rental.to_return_on === millisAtStartOfToday() &&
      !hasReturnDate(rental);
    const shouldHaveBeenReturnedBeforeTodayAndIsNotReturned = (rental) =>
      rental.to_return_on &&
      (!hasReturnDate(rental) && rental.to_return_on < millisAtStartOfToday());

    const rentalHighlight = async (rental) => {
      if (hasBeenReturnedToday(rental)) {
        return ColorDefs.RENTAL_RETURNED_TODAY_GREEN;
      } else if (shouldBeReturnedToday(rental)) {
        return ColorDefs.RENTAL_TO_RETURN_TODAY_BLUE;
      } else if (shouldHaveBeenReturnedBeforeTodayAndIsNotReturned(rental)) {
        return ColorDefs.RENTAL_LATE_RED;
      }
    };

    const customerHighlight = (rental) => {
      return Promise.resolve(rental.customer_highlight)
    };
    const itemHighlight = (rental) => {
      return Promise.resolve(rental.item_highlight)
    };

    const highlightByPriority = (highlightFunctions) => (rental) =>
      Promise.all(
        highlightFunctions.map((highlightFunction) => highlightFunction(rental))
      ).then((highlightColors) => {
        return highlightColors.find((color) => color)
      });

    var rentalColumns = [
      {
        title: "Bild",
        key: "image",
        search: "exclude",
        isImageUrl: true,
        disableSort: true,
        backgroundColor: highlightByPriority([itemHighlight, rentalHighlight]),
      },
      {
        title: "Gegenstand Nr",
        key: "item_id",
        numeric: true,
        search: "from_beginning",
        display: (value) => String(value).padStart(4, "0"),
        backgroundColor: highlightByPriority([itemHighlight, rentalHighlight]),
      },
      {
        title: "Gegenstand Name",
        key: "item_name",
        backgroundColor: highlightByPriority([itemHighlight, rentalHighlight]),
      },
      {
        title: "Ausgegeben",
        key: "rented_on",
        search: "exclude",
        sort: ["rented_on", "customer_name"],
        display: (value) => saveParseTimestampToHumanReadableString(value),
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Verlängert",
        key: "extended_on",
        search: "exclude",
        display: (value) => saveParseTimestampToHumanReadableString(value),
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Zurückerwartet",
        key: "to_return_on",
        search: "exclude",
        display: (value) => saveParseTimestampToHumanReadableString(value),
        sort: ["returned_on", "to_return_on", "customer_name"],
        backgroundColor: highlightByPriority([rentalHighlight]),
        initialSort: "asc",
      },
      {
        title: "Mitarbeiter",
        search: "exclude",
        key: "passing_out_employee",
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Nutzer-Nr.",
        key: "customer_id",
        numeric: true,
        search: "from_beginning",
        backgroundColor: highlightByPriority([customerHighlight, rentalHighlight]),
      },
      {
        title: "Nutzername",
        key: "customer_name",
        backgroundColor: highlightByPriority([customerHighlight, rentalHighlight]),
      },
      {
        title: "Pfand",
        key: "deposit",
        search: "exclude",
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Pfand zurück",
        key: "deposit_returned",
        search: "exclude",
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Zurückgegeben",
        key: "returned_on",
        search: "exclude",
        display: (value) => saveParseTimestampToHumanReadableString(value),
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Mitarbeiter",
        key: "receiving_employee",
        search: "exclude",
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
      {
        title: "Bemerkung",
        key: "remark",
        search: "exclude",
        disableSort: true,
        backgroundColor: highlightByPriority([rentalHighlight]),
      },
    ];

    /* src/components/TableView/TableToCSVExporter.svelte generated by Svelte v3.42.4 */
    const delimiter = ";";

    function instance$Z($$self, $$props, $$invalidate) {
    	let itemType;
    	let $location;
    	component_subscribe($$self, location$1, $$value => $$invalidate(1, $location = $$value));
    	const columnShouldBeExported = column => !("export" in column && column.export === "exclude");

    	const columns = {
    		rental: rentalColumns.filter(columnShouldBeExported),
    		item: itemColumns.filter(columnShouldBeExported),
    		customer: customerColumns.filter(columnShouldBeExported)
    	};

    	const filenames = {
    		rental: "Leihvorgaenge",
    		item: "Gegenstaende",
    		customer: "Nutzer_innen"
    	};

    	function convertToCSV(items) {
    		const exportableColumns = columns[itemType].filter(col => !col.hasOwnProperty("noExport") || !col.noExport);
    		let csvString = exportableColumns.map(col => col.title).join(delimiter) + "\r\n";

    		items.filter(item => item.type === itemType).forEach(item => {
    			let csvValues = [];

    			for (const column of exportableColumns) {
    				let key = column.key;
    				let value = item.hasOwnProperty(key) ? item[key] : "";

    				// calculate and format value for display
    				if (column.displayExport) {
    					value = column.displayExport(items, item.id);
    				} else if (column.display) {
    					value = column.display(value); // TODO: display might be an async function -> await
    				}

    				// remove csv delimiters and line breaks from data
    				value = String(value).replaceAll(delimiter, "");

    				value = String(value).replaceAll("\r", " ");
    				value = String(value).replaceAll("\n", " ");
    				value = String(value).replaceAll("  ", " ");
    				csvValues.push(value);
    			}

    			csvString += csvValues.join(delimiter) + "\r\n";
    		});

    		return csvString;
    	}

    	const exportCSVFile = async () => {
    		const allItems = await Database.fetchAll();
    		var csv = convertToCSV(allItems);
    		var exportedFilenmae = `${filenames[itemType]}.csv`;
    		var blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    		var link = document.createElement("a");

    		if (link.download !== undefined) {
    			// feature detection
    			// Browsers that support HTML5 download attribute
    			var url = URL.createObjectURL(blob);

    			link.setAttribute("href", url);
    			link.setAttribute("download", exportedFilenmae);
    			link.style.visibility = "hidden";
    			document.body.appendChild(link);
    			link.click();
    			document.body.removeChild(link);
    		} else {
    			alert("Die Export-Funktion wird von diesem Browser nicht untersützt :(");
    		}
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$location*/ 2) {
    			// rental, item or customer
    			itemType = $location.split("/")[1].slice(0, -1);
    		}
    	};

    	return [exportCSVFile, $location];
    }

    class TableToCSVExporter extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$Z, null, safe_not_equal, { exportCSVFile: 0 });
    	}

    	get exportCSVFile() {
    		return this.$$.ctx[0];
    	}
    }

    /** Dispatch event on click outside of node */
    function clickOutside(node) {
      const handleClick = (event) => {
        if (node && !node.contains(event.target) && !event.defaultPrevented) {
          node.dispatchEvent(new CustomEvent("click_outside", node));
        }
      };

      document.addEventListener("click", handleClick, true);

      return {
        destroy() {
          document.removeEventListener("click", handleClick, true);
        },
      };
    }

    /* src/components/Layout/DropDownMenu.svelte generated by Svelte v3.42.4 */

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (30:6) {#each menuItems as menuItem}
    function create_each_block$m(ctx) {
    	let li;
    	let t0_value = /*menuItem*/ ctx[6].title + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[4](/*menuItem*/ ctx[6]);
    	}

    	return {
    		c() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(li, "class", "svelte-6wx36t");
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, t0);
    			append(li, t1);

    			if (!mounted) {
    				dispose = listen(li, "click", click_handler_1);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*menuItems*/ 1 && t0_value !== (t0_value = /*menuItem*/ ctx[6].title + "")) set_data(t0, t0_value);
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$_(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let ul;
    	let mounted;
    	let dispose;
    	let each_value = /*menuItems*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="svelte-6wx36t"><path fill="currentColor" d="M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3z"></path></svg>`;
    			t = space();
    			div1 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div0, "class", "dropbtn svelte-6wx36t");
    			attr(ul, "class", "svelte-6wx36t");
    			set_style(div1, "--max-height", /*show*/ ctx[1] ? `${/*maxHeightPx*/ ctx[2]}px` : '0');
    			attr(div1, "class", "dropdown-content svelte-6wx36t");
    			attr(div2, "class", "dropdown svelte-6wx36t");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t);
    			append(div2, div1);
    			append(div1, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen(div0, "click", /*click_handler*/ ctx[3]),
    					action_destroyer(clickOutside.call(null, div2)),
    					listen(div2, "click_outside", /*click_outside_handler*/ ctx[5])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*show, menuItems*/ 3) {
    				each_value = /*menuItems*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$m(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*show*/ 2) {
    				set_style(div1, "--max-height", /*show*/ ctx[1] ? `${/*maxHeightPx*/ ctx[2]}px` : '0');
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { menuItems = [] } = $$props;
    	let show = false;

    	// animation does not work with auto height
    	let maxHeightPx = menuItems.length * 45;

    	const click_handler = () => $$invalidate(1, show = !show);

    	const click_handler_1 = menuItem => {
    		$$invalidate(1, show = false);
    		menuItem.onClick();
    	};

    	const click_outside_handler = () => $$invalidate(1, show = false);

    	$$self.$$set = $$props => {
    		if ('menuItems' in $$props) $$invalidate(0, menuItems = $$props.menuItems);
    	};

    	return [
    		menuItems,
    		show,
    		maxHeightPx,
    		click_handler,
    		click_handler_1,
    		click_outside_handler
    	];
    }

    class DropDownMenu extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$Y, create_fragment$_, safe_not_equal, { menuItems: 0 });
    	}
    }

    /* src/components/Layout/Navbar.svelte generated by Svelte v3.42.4 */

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (16:4) {#each tabs as tab}
    function create_each_block$l(ctx) {
    	let li;
    	let a;
    	let t_value = /*tab*/ ctx[6].title + "";
    	let t;
    	let a_href_value;
    	let active_action;
    	let link_action;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", a_href_value = /*tab*/ ctx[6].route);
    			attr(a, "class", "svelte-dgsre0");
    			attr(li, "class", "left svelte-dgsre0");
    		},
    		m(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(active_action = active.call(null, a, /*tab*/ ctx[6].route)),
    					action_destroyer(link_action = link.call(null, a))
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*tabs*/ 1 && t_value !== (t_value = /*tab*/ ctx[6].title + "")) set_data(t, t_value);

    			if (dirty & /*tabs*/ 1 && a_href_value !== (a_href_value = /*tab*/ ctx[6].route)) {
    				attr(a, "href", a_href_value);
    			}

    			if (active_action && is_function(active_action.update) && dirty & /*tabs*/ 1) active_action.update.call(null, /*tab*/ ctx[6].route);
    		},
    		d(detaching) {
    			if (detaching) detach(li);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$Z(ctx) {
    	let nav;
    	let ul;
    	let li0;
    	let a;
    	let t1;
    	let t2;
    	let li1;
    	let tabletocsvexporter;
    	let t3;
    	let dropdownmenu;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*tabs*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	let tabletocsvexporter_props = {};
    	tabletocsvexporter = new TableToCSVExporter({ props: tabletocsvexporter_props });
    	/*tabletocsvexporter_binding*/ ctx[2](tabletocsvexporter);

    	dropdownmenu = new DropDownMenu({
    			props: {
    				menuItems: [
    					{
    						title: "Tabelle -> CSV",
    						onClick: /*func*/ ctx[3]
    					},
    					{
    						title: "Logs",
    						onClick: /*func_1*/ ctx[4]
    					},
    					{
    						title: "Einstellungen",
    						onClick: /*func_2*/ ctx[5]
    					}
    				]
    			}
    		});

    	return {
    		c() {
    			nav = element("nav");
    			ul = element("ul");
    			li0 = element("li");
    			a = element("a");
    			a.textContent = `${"Start"}`;
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			li1 = element("li");
    			create_component(tabletocsvexporter.$$.fragment);
    			t3 = space();
    			create_component(dropdownmenu.$$.fragment);
    			attr(a, "href", "/start");
    			attr(a, "class", "svelte-dgsre0");
    			attr(li0, "class", "left svelte-dgsre0");
    			attr(li1, "class", "right svelte-dgsre0");
    			attr(ul, "class", "svelte-dgsre0");
    			attr(nav, "class", "svelte-dgsre0");
    		},
    		m(target, anchor) {
    			insert(target, nav, anchor);
    			append(nav, ul);
    			append(ul, li0);
    			append(li0, a);
    			append(ul, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append(ul, t2);
    			append(ul, li1);
    			mount_component(tabletocsvexporter, li1, null);
    			append(li1, t3);
    			mount_component(dropdownmenu, li1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(active.call(null, a, "/start")),
    					action_destroyer(link.call(null, a))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*tabs*/ 1) {
    				each_value = /*tabs*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, t2);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const tabletocsvexporter_changes = {};
    			tabletocsvexporter.$set(tabletocsvexporter_changes);
    			const dropdownmenu_changes = {};

    			if (dirty & /*tableToCSVExporterRef*/ 2) dropdownmenu_changes.menuItems = [
    				{
    					title: "Tabelle -> CSV",
    					onClick: /*func*/ ctx[3]
    				},
    				{
    					title: "Logs",
    					onClick: /*func_1*/ ctx[4]
    				},
    				{
    					title: "Einstellungen",
    					onClick: /*func_2*/ ctx[5]
    				}
    			];

    			dropdownmenu.$set(dropdownmenu_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(tabletocsvexporter.$$.fragment, local);
    			transition_in(dropdownmenu.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(tabletocsvexporter.$$.fragment, local);
    			transition_out(dropdownmenu.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(nav);
    			destroy_each(each_blocks, detaching);
    			/*tabletocsvexporter_binding*/ ctx[2](null);
    			destroy_component(tabletocsvexporter);
    			destroy_component(dropdownmenu);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { tabs = [] } = $$props;
    	let tableToCSVExporterRef;

    	function tabletocsvexporter_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			tableToCSVExporterRef = $$value;
    			$$invalidate(1, tableToCSVExporterRef);
    		});
    	}

    	const func = () => tableToCSVExporterRef.exportCSVFile();
    	const func_1 = () => replace("/logs");
    	const func_2 = () => replace("/settings");

    	$$self.$$set = $$props => {
    		if ('tabs' in $$props) $$invalidate(0, tabs = $$props.tabs);
    	};

    	return [tabs, tableToCSVExporterRef, tabletocsvexporter_binding, func, func_1, func_2];
    }

    class Navbar extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$X, create_fragment$Z, safe_not_equal, { tabs: 0 });
    	}
    }

    /* src/components/TableView/AddNewDocButton.svelte generated by Svelte v3.42.4 */

    function create_fragment$Y(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.textContent = "+";
    			attr(button, "class", "svelte-x15bm0");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[0]);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$W($$self) {
    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	return [click_handler];
    }

    class AddNewDocButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$W, create_fragment$Y, safe_not_equal, {});
    	}
    }

    function isOutOfViewport (elem) {
        const bounding = elem.getBoundingClientRect();
        const out = {};

        out.top = bounding.top < 0;
        out.left = bounding.left < 0;
        out.bottom =
            bounding.bottom >
            (window.innerHeight || document.documentElement.clientHeight);
        out.right =
            bounding.right >
            (window.innerWidth || document.documentElement.clientWidth);
        out.any = out.top || out.left || out.bottom || out.right;

        return out;
    }

    /* node_modules/svelte-select/src/Item.svelte generated by Svelte v3.42.4 */

    function create_fragment$X(ctx) {
    	let div;
    	let raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "";
    	let div_class_value;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-3e0qet");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*getOptionLabel, item, filterText*/ 7 && raw_value !== (raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "")) div.innerHTML = raw_value;
    			if (dirty & /*itemClasses*/ 8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-3e0qet")) {
    				attr(div, "class", div_class_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { isActive = false } = $$props;
    	let { isFirst = false } = $$props;
    	let { isHover = false } = $$props;
    	let { isSelectable = false } = $$props;
    	let { getOptionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	let { filterText = '' } = $$props;
    	let itemClasses = '';

    	$$self.$$set = $$props => {
    		if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
    		if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    		if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive, isFirst, isHover, item, isSelectable*/ 242) {
    			{
    				const classes = [];

    				if (isActive) {
    					classes.push('active');
    				}

    				if (isFirst) {
    					classes.push('first');
    				}

    				if (isHover) {
    					classes.push('hover');
    				}

    				if (item.isGroupHeader) {
    					classes.push('groupHeader');
    				}

    				if (item.isGroupItem) {
    					classes.push('groupItem');
    				}

    				if (!isSelectable) {
    					classes.push('notSelectable');
    				}

    				$$invalidate(3, itemClasses = classes.join(' '));
    			}
    		}
    	};

    	return [
    		getOptionLabel,
    		item,
    		filterText,
    		itemClasses,
    		isActive,
    		isFirst,
    		isHover,
    		isSelectable
    	];
    }

    class Item extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$V, create_fragment$X, safe_not_equal, {
    			isActive: 4,
    			isFirst: 5,
    			isHover: 6,
    			isSelectable: 7,
    			getOptionLabel: 0,
    			item: 1,
    			filterText: 2
    		});
    	}
    }

    /* node_modules/svelte-select/src/List.svelte generated by Svelte v3.42.4 */

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[41] = list[i];
    	child_ctx[42] = i;
    	return child_ctx;
    }

    // (309:4) {:else}
    function create_else_block$b(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_2(ctx);
    	}

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			if (each_1_else) {
    				each_1_else.c();
    			}
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);

    			if (each_1_else) {
    				each_1_else.m(target, anchor);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/ 114390) {
    				each_value = /*items*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value.length) {
    					each_1_else = create_else_block_2(ctx);
    					each_1_else.c();
    					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
    				} else if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    			if (each_1_else) each_1_else.d(detaching);
    		}
    	};
    }

    // (286:4) {#if isVirtualList}
    function create_if_block$g(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*VirtualList*/ ctx[3];

    	function switch_props(ctx) {
    		return {
    			props: {
    				items: /*items*/ ctx[1],
    				itemHeight: /*itemHeight*/ ctx[8],
    				$$slots: {
    					default: [
    						create_default_slot$2,
    						({ item, i }) => ({ 41: item, 42: i }),
    						({ item, i }) => [0, (item ? 1024 : 0) | (i ? 2048 : 0)]
    					]
    				},
    				$$scope: { ctx }
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 2) switch_instance_changes.items = /*items*/ ctx[1];
    			if (dirty[0] & /*itemHeight*/ 256) switch_instance_changes.itemHeight = /*itemHeight*/ ctx[8];

    			if (dirty[0] & /*Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, items*/ 9814 | dirty[1] & /*$$scope, item, i*/ 11264) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*VirtualList*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (331:8) {:else}
    function create_else_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = !/*hideEmptyState*/ ctx[11] && create_if_block_2$4(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (!/*hideEmptyState*/ ctx[11]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (332:12) {#if !hideEmptyState}
    function create_if_block_2$4(ctx) {
    	let div;
    	let t;

    	return {
    		c() {
    			div = element("div");
    			t = text(/*noOptionsMessage*/ ctx[12]);
    			attr(div, "class", "empty svelte-1uyqfml");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*noOptionsMessage*/ 4096) set_data(t, /*noOptionsMessage*/ ctx[12]);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (313:12) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[4];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[41],
    				filterText: /*filterText*/ ctx[13],
    				getOptionLabel: /*getOptionLabel*/ ctx[6],
    				isFirst: isItemFirst(/*i*/ ctx[42]),
    				isActive: isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]),
    				isSelectable: isItemSelectable(/*item*/ ctx[41])
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler_1() {
    		return /*mouseover_handler_1*/ ctx[29](/*i*/ ctx[42]);
    	}

    	function focus_handler_1() {
    		return /*focus_handler_1*/ ctx[30](/*i*/ ctx[42]);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[31](/*item*/ ctx[41], /*i*/ ctx[42], ...args);
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr(div, "class", "listItem");
    			attr(div, "tabindex", "-1");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div, "mouseover", mouseover_handler_1),
    					listen(div, "focus", focus_handler_1),
    					listen(div, "click", click_handler_1)
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 2) switch_instance_changes.item = /*item*/ ctx[41];
    			if (dirty[0] & /*filterText*/ 8192) switch_instance_changes.filterText = /*filterText*/ ctx[13];
    			if (dirty[0] & /*getOptionLabel*/ 64) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[6];
    			if (dirty[0] & /*items, value, optionIdentifier*/ 1538) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 6) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]);
    			if (dirty[0] & /*items*/ 2) switch_instance_changes.isSelectable = isItemSelectable(/*item*/ ctx[41]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[4])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (311:12) {#if item.isGroupHeader && !item.isSelectable}
    function create_if_block_1$9(ctx) {
    	let div;
    	let t_value = /*getGroupHeaderLabel*/ ctx[7](/*item*/ ctx[41]) + "";
    	let t;

    	return {
    		c() {
    			div = element("div");
    			t = text(t_value);
    			attr(div, "class", "listGroupTitle svelte-1uyqfml");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items*/ 130 && t_value !== (t_value = /*getGroupHeaderLabel*/ ctx[7](/*item*/ ctx[41]) + "")) set_data(t, t_value);
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (310:8) {#each items as item, i}
    function create_each_block$k(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$9, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*item*/ ctx[41].isGroupHeader && !/*item*/ ctx[41].isSelectable) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>
    function create_default_slot$2(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[4];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[41],
    				filterText: /*filterText*/ ctx[13],
    				getOptionLabel: /*getOptionLabel*/ ctx[6],
    				isFirst: isItemFirst(/*i*/ ctx[42]),
    				isActive: isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]),
    				isSelectable: isItemSelectable(/*item*/ ctx[41])
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[26](/*i*/ ctx[42]);
    	}

    	function focus_handler() {
    		return /*focus_handler*/ ctx[27](/*i*/ ctx[42]);
    	}

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[28](/*item*/ ctx[41], /*i*/ ctx[42], ...args);
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "listItem");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div, "mouseover", mouseover_handler),
    					listen(div, "focus", focus_handler),
    					listen(div, "click", click_handler)
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[1] & /*item*/ 1024) switch_instance_changes.item = /*item*/ ctx[41];
    			if (dirty[0] & /*filterText*/ 8192) switch_instance_changes.filterText = /*filterText*/ ctx[13];
    			if (dirty[0] & /*getOptionLabel*/ 64) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[6];
    			if (dirty[1] & /*i*/ 2048) switch_instance_changes.isFirst = isItemFirst(/*i*/ ctx[42]);
    			if (dirty[0] & /*value, optionIdentifier*/ 1536 | dirty[1] & /*item*/ 1024) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[41], /*value*/ ctx[9], /*optionIdentifier*/ ctx[10]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 6 | dirty[1] & /*item, i*/ 3072) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[2], /*item*/ ctx[41], /*i*/ ctx[42], /*items*/ ctx[1]);
    			if (dirty[1] & /*item*/ 1024) switch_instance_changes.isSelectable = isItemSelectable(/*item*/ ctx[41]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[4])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$W(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$g, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isVirtualList*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			div = element("div");
    			if_block.c();
    			attr(div, "class", "listContainer svelte-1uyqfml");
    			attr(div, "style", /*listStyle*/ ctx[14]);
    			toggle_class(div, "virtualList", /*isVirtualList*/ ctx[5]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[32](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window, "keydown", /*handleKeyDown*/ ctx[17]),
    					listen(window, "resize", /*computePlacement*/ ctx[18])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty[0] & /*listStyle*/ 16384) {
    				attr(div, "style", /*listStyle*/ ctx[14]);
    			}

    			if (dirty[0] & /*isVirtualList*/ 32) {
    				toggle_class(div, "virtualList", /*isVirtualList*/ ctx[5]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[32](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function isItemActive(item, value, optionIdentifier) {
    	return value && value[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
    	return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
    	return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
    }

    function isItemSelectable(item) {
    	return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty('selectable'); // Default; if `selectable` was not specified, the object is selectable
    }

    function instance$U($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { VirtualList = null } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { items = [] } = $$props;
    	let { labelIdentifier = 'label' } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		if (option) return option.isCreator
    		? `Create \"${filterText}\"`
    		: option[labelIdentifier];
    	} } = $$props;

    	let { getGroupHeaderLabel = null } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { value = undefined } = $$props;
    	let { optionIdentifier = 'value' } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { noOptionsMessage = 'No options' } = $$props;
    	let { isMulti = false } = $$props;
    	let { activeItemIndex = 0 } = $$props;
    	let { filterText = '' } = $$props;
    	let { parent = null } = $$props;
    	let { listPlacement = null } = $$props;
    	let { listAutoWidth = null } = $$props;
    	let { listOffset = 5 } = $$props;
    	let isScrollingTimer = 0;
    	let isScrolling = false;
    	let prev_items;

    	onMount(() => {
    		if (items.length > 0 && !isMulti && value) {
    			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === value[optionIdentifier]);

    			if (_hoverItemIndex) {
    				$$invalidate(2, hoverItemIndex = _hoverItemIndex);
    			}
    		}

    		scrollToActiveItem('active');

    		container.addEventListener(
    			'scroll',
    			() => {
    				clearTimeout(isScrollingTimer);

    				isScrollingTimer = setTimeout(
    					() => {
    						isScrolling = false;
    					},
    					100
    				);
    			},
    			false
    		);
    	});

    	beforeUpdate(() => {
    		if (!items) $$invalidate(1, items = []);

    		if (items !== prev_items && items.length > 0) {
    			$$invalidate(2, hoverItemIndex = 0);
    		}

    		prev_items = items;
    	});

    	function handleSelect(item) {
    		if (item.isCreator) return;
    		dispatch('itemSelected', item);
    	}

    	function handleHover(i) {
    		if (isScrolling) return;
    		$$invalidate(2, hoverItemIndex = i);
    	}

    	function handleClick(args) {
    		const { item, i, event } = args;
    		event.stopPropagation();
    		if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier]) return closeList();

    		if (item.isCreator) {
    			dispatch('itemCreated', filterText);
    		} else if (isItemSelectable(item)) {
    			$$invalidate(19, activeItemIndex = i);
    			$$invalidate(2, hoverItemIndex = i);
    			handleSelect(item);
    		}
    	}

    	function closeList() {
    		dispatch('closeList');
    	}

    	async function updateHoverItem(increment) {
    		if (isVirtualList) return;
    		let isNonSelectableItem = true;

    		while (isNonSelectableItem) {
    			if (increment > 0 && hoverItemIndex === items.length - 1) {
    				$$invalidate(2, hoverItemIndex = 0);
    			} else if (increment < 0 && hoverItemIndex === 0) {
    				$$invalidate(2, hoverItemIndex = items.length - 1);
    			} else {
    				$$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
    			}

    			isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
    		}

    		await tick();
    		scrollToActiveItem('hover');
    	}

    	function handleKeyDown(e) {
    		switch (e.key) {
    			case 'Escape':
    				e.preventDefault();
    				closeList();
    				break;
    			case 'ArrowDown':
    				e.preventDefault();
    				items.length && updateHoverItem(1);
    				break;
    			case 'ArrowUp':
    				e.preventDefault();
    				items.length && updateHoverItem(-1);
    				break;
    			case 'Enter':
    				e.preventDefault();
    				if (items.length === 0) break;
    				const hoverItem = items[hoverItemIndex];
    				if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
    					closeList();
    					break;
    				}
    				if (hoverItem.isCreator) {
    					dispatch('itemCreated', filterText);
    				} else {
    					$$invalidate(19, activeItemIndex = hoverItemIndex);
    					handleSelect(items[hoverItemIndex]);
    				}
    				break;
    			case 'Tab':
    				e.preventDefault();
    				if (items.length === 0) {
    					return closeList();
    				}
    				if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
    				$$invalidate(19, activeItemIndex = hoverItemIndex);
    				handleSelect(items[hoverItemIndex]);
    				break;
    		}
    	}

    	function scrollToActiveItem(className) {
    		if (isVirtualList || !container) return;
    		let offsetBounding;
    		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

    		if (focusedElemBounding) {
    			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    		}

    		$$invalidate(0, container.scrollTop -= offsetBounding, container);
    	}

    	let listStyle;

    	function computePlacement() {
    		const { top, height, width } = parent.getBoundingClientRect();
    		$$invalidate(14, listStyle = '');
    		$$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? 'auto' : '100%'};`);

    		if (listPlacement === 'top' || listPlacement === 'auto' && isOutOfViewport(parent).bottom) {
    			$$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
    		} else {
    			$$invalidate(14, listStyle += `top:${height + listOffset}px;`);
    		}
    	}

    	const mouseover_handler = i => handleHover(i);
    	const focus_handler = i => handleHover(i);
    	const click_handler = (item, i, event) => handleClick({ item, i, event });
    	const mouseover_handler_1 = i => handleHover(i);
    	const focus_handler_1 = i => handleHover(i);
    	const click_handler_1 = (item, i, event) => handleClick({ item, i, event });

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
    		if ('Item' in $$props) $$invalidate(4, Item$1 = $$props.Item);
    		if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
    		if ('items' in $$props) $$invalidate(1, items = $$props.items);
    		if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
    		if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
    		if ('value' in $$props) $$invalidate(9, value = $$props.value);
    		if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
    		if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
    		if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
    		if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
    		if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
    		if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
    		if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
    		if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
    		if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
    		if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*parent, container*/ 4194305) {
    			{
    				if (parent && container) computePlacement();
    			}
    		}
    	};

    	return [
    		container,
    		items,
    		hoverItemIndex,
    		VirtualList,
    		Item$1,
    		isVirtualList,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		value,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		filterText,
    		listStyle,
    		handleHover,
    		handleClick,
    		handleKeyDown,
    		computePlacement,
    		activeItemIndex,
    		labelIdentifier,
    		isMulti,
    		parent,
    		listPlacement,
    		listAutoWidth,
    		listOffset,
    		mouseover_handler,
    		focus_handler,
    		click_handler,
    		mouseover_handler_1,
    		focus_handler_1,
    		click_handler_1,
    		div_binding
    	];
    }

    class List extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$U,
    			create_fragment$W,
    			safe_not_equal,
    			{
    				container: 0,
    				VirtualList: 3,
    				Item: 4,
    				isVirtualList: 5,
    				items: 1,
    				labelIdentifier: 20,
    				getOptionLabel: 6,
    				getGroupHeaderLabel: 7,
    				itemHeight: 8,
    				hoverItemIndex: 2,
    				value: 9,
    				optionIdentifier: 10,
    				hideEmptyState: 11,
    				noOptionsMessage: 12,
    				isMulti: 21,
    				activeItemIndex: 19,
    				filterText: 13,
    				parent: 22,
    				listPlacement: 23,
    				listAutoWidth: 24,
    				listOffset: 25
    			},
    			null,
    			[-1, -1]
    		);
    	}
    }

    /* node_modules/svelte-select/src/Selection.svelte generated by Svelte v3.42.4 */

    function create_fragment$V(ctx) {
    	let div;
    	let raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "";

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "selection svelte-pu1q1n");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*getSelectionLabel, item*/ 3 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "")) div.innerHTML = raw_value;		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { getSelectionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;

    	$$self.$$set = $$props => {
    		if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    	};

    	return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$T, create_fragment$V, safe_not_equal, { getSelectionLabel: 0, item: 1 });
    	}
    }

    /* node_modules/svelte-select/src/MultiSelection.svelte generated by Svelte v3.42.4 */

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (87:8) {#if !isDisabled && !multiFullItemClearable}
    function create_if_block$f(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*i*/ ctx[11], ...args);
    	}

    	return {
    		c() {
    			div = element("div");
    			div.innerHTML = `<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="svelte-liu9pa"><path d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`;
    			attr(div, "class", "multiSelectItem_clear svelte-liu9pa");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (!mounted) {
    				dispose = listen(div, "click", click_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (77:0) {#each value as item, i}
    function create_each_block$j(ctx) {
    	let div1;
    	let div0;
    	let raw_value = /*getSelectionLabel*/ ctx[4](/*item*/ ctx[9]) + "";
    	let t0;
    	let t1;
    	let div1_class_value;
    	let mounted;
    	let dispose;
    	let if_block = !/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3] && create_if_block$f(ctx);

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[7](/*i*/ ctx[11], ...args);
    	}

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr(div0, "class", "multiSelectItem_label svelte-liu9pa");
    			attr(div1, "class", div1_class_value = "multiSelectItem " + (/*activeValue*/ ctx[1] === /*i*/ ctx[11] ? 'active' : '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-liu9pa");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			div0.innerHTML = raw_value;
    			append(div1, t0);
    			if (if_block) if_block.m(div1, null);
    			append(div1, t1);

    			if (!mounted) {
    				dispose = listen(div1, "click", click_handler_1);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*getSelectionLabel, value*/ 17 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[4](/*item*/ ctx[9]) + "")) div0.innerHTML = raw_value;
    			if (!/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(div1, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*activeValue, isDisabled*/ 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (/*activeValue*/ ctx[1] === /*i*/ ctx[11] ? 'active' : '') + " " + (/*isDisabled*/ ctx[2] ? 'disabled' : '') + " svelte-liu9pa")) {
    				attr(div1, "class", div1_class_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$U(ctx) {
    	let each_1_anchor;
    	let each_value = /*value*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*activeValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, value*/ 63) {
    				each_value = /*value*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    function instance$S($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let { value = [] } = $$props;
    	let { activeValue = undefined } = $$props;
    	let { isDisabled = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { getSelectionLabel = undefined } = $$props;

    	function handleClear(i, event) {
    		event.stopPropagation();
    		dispatch('multiItemClear', { i });
    	}

    	const click_handler = (i, event) => handleClear(i, event);
    	const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
    		if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	return [
    		value,
    		activeValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear,
    		click_handler,
    		click_handler_1
    	];
    }

    class MultiSelection extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$S, create_fragment$U, safe_not_equal, {
    			value: 0,
    			activeValue: 1,
    			isDisabled: 2,
    			multiFullItemClearable: 3,
    			getSelectionLabel: 4
    		});
    	}
    }

    /* node_modules/svelte-select/src/VirtualList.svelte generated by Svelte v3.42.4 */

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes$1 = dirty => ({
    	item: dirty & /*visible*/ 32,
    	i: dirty & /*visible*/ 32,
    	hoverItemIndex: dirty & /*hoverItemIndex*/ 2
    });

    const get_default_slot_context$1 = ctx => ({
    	item: /*row*/ ctx[23].data,
    	i: /*row*/ ctx[23].index,
    	hoverItemIndex: /*hoverItemIndex*/ ctx[1]
    });

    // (154:69) Missing template
    function fallback_block$2(ctx) {
    	let t;

    	return {
    		c() {
    			t = text("Missing template");
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (152:8) {#each visible as row (row.index)}
    function create_each_block$i(key_1, ctx) {
    	let svelte_virtual_list_row;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$1);
    	const default_slot_or_fallback = default_slot || fallback_block$2();

    	return {
    		key: key_1,
    		first: null,
    		c() {
    			svelte_virtual_list_row = element("svelte-virtual-list-row");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-g2cagw");
    			this.first = svelte_virtual_list_row;
    		},
    		m(target, anchor) {
    			insert(target, svelte_virtual_list_row, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svelte_virtual_list_row, null);
    			}

    			append(svelte_virtual_list_row, t);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, visible, hoverItemIndex*/ 16418)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(svelte_virtual_list_row);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};
    }

    function create_fragment$T(ctx) {
    	let svelte_virtual_list_viewport;
    	let svelte_virtual_list_contents;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let svelte_virtual_list_viewport_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visible*/ ctx[5];
    	const get_key = ctx => /*row*/ ctx[23].index;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$i(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
    	}

    	return {
    		c() {
    			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
    			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-g2cagw");
    			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-g2cagw");
    			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].call(svelte_virtual_list_viewport));
    		},
    		m(target, anchor) {
    			insert(target, svelte_virtual_list_viewport, anchor);
    			append(svelte_virtual_list_viewport, svelte_virtual_list_contents);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svelte_virtual_list_contents, null);
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](svelte_virtual_list_contents);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](svelte_virtual_list_viewport);
    			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].bind(svelte_virtual_list_viewport));
    			current = true;

    			if (!mounted) {
    				dispose = listen(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[8]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
    				each_value = /*visible*/ ctx[5];
    				group_outros();
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$i, null, get_each_context$i);
    				check_outros();
    			}

    			if (!current || dirty & /*top*/ 64) {
    				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*bottom*/ 128) {
    				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			}

    			if (!current || dirty & /*height*/ 1) {
    				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(svelte_virtual_list_viewport);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](null);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](null);
    			svelte_virtual_list_viewport_resize_listener();
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { items = undefined } = $$props;
    	let { height = '100%' } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { start = 0 } = $$props;
    	let { end = 0 } = $$props;
    	let height_map = [];
    	let rows;
    	let viewport;
    	let contents;
    	let viewport_height = 0;
    	let visible;
    	let mounted;
    	let top = 0;
    	let bottom = 0;
    	let average_height;

    	async function refresh(items, viewport_height, itemHeight) {
    		const { scrollTop } = viewport;
    		await tick();
    		let content_height = top - scrollTop;
    		let i = start;

    		while (content_height < viewport_height && i < items.length) {
    			let row = rows[i - start];

    			if (!row) {
    				$$invalidate(10, end = i + 1);
    				await tick();
    				row = rows[i - start];
    			}

    			const row_height = height_map[i] = itemHeight || row.offsetHeight;
    			content_height += row_height;
    			i += 1;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = (top + content_height) / end;
    		$$invalidate(7, bottom = remaining * average_height);
    		height_map.length = items.length;
    		if (viewport) $$invalidate(3, viewport.scrollTop = 0, viewport);
    	}

    	async function handle_scroll() {
    		const { scrollTop } = viewport;
    		const old_start = start;

    		for (let v = 0; v < rows.length; v += 1) {
    			height_map[start + v] = itemHeight || rows[v].offsetHeight;
    		}

    		let i = 0;
    		let y = 0;

    		while (i < items.length) {
    			const row_height = height_map[i] || average_height;

    			if (y + row_height > scrollTop) {
    				$$invalidate(9, start = i);
    				$$invalidate(6, top = y);
    				break;
    			}

    			y += row_height;
    			i += 1;
    		}

    		while (i < items.length) {
    			y += height_map[i] || average_height;
    			i += 1;
    			if (y > scrollTop + viewport_height) break;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = y / end;
    		while (i < items.length) height_map[i++] = average_height;
    		$$invalidate(7, bottom = remaining * average_height);

    		if (start < old_start) {
    			await tick();
    			let expected_height = 0;
    			let actual_height = 0;

    			for (let i = start; i < old_start; i += 1) {
    				if (rows[i - start]) {
    					expected_height += height_map[i];
    					actual_height += itemHeight || rows[i - start].offsetHeight;
    				}
    			}

    			const d = actual_height - expected_height;
    			viewport.scrollTo(0, scrollTop + d);
    		}
    	}

    	onMount(() => {
    		rows = contents.getElementsByTagName('svelte-virtual-list-row');
    		$$invalidate(13, mounted = true);
    	});

    	function svelte_virtual_list_contents_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contents = $$value;
    			$$invalidate(4, contents);
    		});
    	}

    	function svelte_virtual_list_viewport_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			viewport = $$value;
    			$$invalidate(3, viewport);
    		});
    	}

    	function svelte_virtual_list_viewport_elementresize_handler() {
    		viewport_height = this.offsetHeight;
    		$$invalidate(2, viewport_height);
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(11, items = $$props.items);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ('start' in $$props) $$invalidate(9, start = $$props.start);
    		if ('end' in $$props) $$invalidate(10, end = $$props.end);
    		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, start, end*/ 3584) {
    			$$invalidate(5, visible = items.slice(start, end).map((data, i) => {
    				return { index: i + start, data };
    			}));
    		}

    		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 14340) {
    			if (mounted) refresh(items, viewport_height, itemHeight);
    		}
    	};

    	return [
    		height,
    		hoverItemIndex,
    		viewport_height,
    		viewport,
    		contents,
    		visible,
    		top,
    		bottom,
    		handle_scroll,
    		start,
    		end,
    		items,
    		itemHeight,
    		mounted,
    		$$scope,
    		slots,
    		svelte_virtual_list_contents_binding,
    		svelte_virtual_list_viewport_binding,
    		svelte_virtual_list_viewport_elementresize_handler
    	];
    }

    class VirtualList extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$R, create_fragment$T, safe_not_equal, {
    			items: 11,
    			height: 0,
    			itemHeight: 12,
    			hoverItemIndex: 1,
    			start: 9,
    			end: 10
    		});
    	}
    }

    /* node_modules/svelte-select/src/ClearIcon.svelte generated by Svelte v3.42.4 */

    function create_fragment$S(ctx) {
    	let svg;
    	let path;

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr(path, "fill", "currentColor");
    			attr(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			attr(svg, "width", "100%");
    			attr(svg, "height", "100%");
    			attr(svg, "viewBox", "-2 -2 50 50");
    			attr(svg, "focusable", "false");
    			attr(svg, "aria-hidden", "true");
    			attr(svg, "role", "presentation");
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    class ClearIcon extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$S, safe_not_equal, {});
    	}
    }

    function debounce$1(func, wait, immediate) {
        let timeout;

        return function executedFunction() {
            let context = this;
            let args = arguments;

            let later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };

            let callNow = immediate && !timeout;

            clearTimeout(timeout);

            timeout = setTimeout(later, wait);

            if (callNow) func.apply(context, args);
        };
    }

    /* node_modules/svelte-select/src/Select.svelte generated by Svelte v3.42.4 */

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[103] = list[i];
    	return child_ctx;
    }

    // (874:8) {#if isFocused}
    function create_if_block_10$1(ctx) {
    	let span0;
    	let t0;
    	let t1;
    	let span1;
    	let t2;

    	return {
    		c() {
    			span0 = element("span");
    			t0 = text(/*ariaSelection*/ ctx[33]);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*ariaContext*/ ctx[32]);
    			attr(span0, "id", "aria-selection");
    			attr(span1, "id", "aria-context");
    		},
    		m(target, anchor) {
    			insert(target, span0, anchor);
    			append(span0, t0);
    			insert(target, t1, anchor);
    			insert(target, span1, anchor);
    			append(span1, t2);
    		},
    		p(ctx, dirty) {
    			if (dirty[1] & /*ariaSelection*/ 4) set_data(t0, /*ariaSelection*/ ctx[33]);
    			if (dirty[1] & /*ariaContext*/ 2) set_data(t2, /*ariaContext*/ ctx[32]);
    		},
    		d(detaching) {
    			if (detaching) detach(span0);
    			if (detaching) detach(t1);
    			if (detaching) detach(span1);
    		}
    	};
    }

    // (882:4) {#if Icon}
    function create_if_block_9$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*iconProps*/ ctx[18]];
    	var switch_value = /*Icon*/ ctx[17];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*iconProps*/ 262144)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[18])])
    			: {};

    			if (switch_value !== (switch_value = /*Icon*/ ctx[17])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (886:4) {#if showMultiSelect}
    function create_if_block_8$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*MultiSelection*/ ctx[26];

    	function switch_props(ctx) {
    		return {
    			props: {
    				value: /*value*/ ctx[2],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[12],
    				activeValue: /*activeValue*/ ctx[30],
    				isDisabled: /*isDisabled*/ ctx[9],
    				multiFullItemClearable: /*multiFullItemClearable*/ ctx[8]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[38]);
    		switch_instance.$on("focus", /*handleFocus*/ ctx[40]);
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*value*/ 4) switch_instance_changes.value = /*value*/ ctx[2];
    			if (dirty[0] & /*getSelectionLabel*/ 4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[12];
    			if (dirty[0] & /*activeValue*/ 1073741824) switch_instance_changes.activeValue = /*activeValue*/ ctx[30];
    			if (dirty[0] & /*isDisabled*/ 512) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[9];
    			if (dirty[0] & /*multiFullItemClearable*/ 256) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ ctx[8];

    			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[26])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[38]);
    					switch_instance.$on("focus", /*handleFocus*/ ctx[40]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (908:4) {#if !isMulti && showSelectedItem}
    function create_if_block_7$1(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Selection*/ ctx[25];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*value*/ ctx[2],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[12]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "selectedItem svelte-b8sh3g");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen(div, "focus", /*handleFocus*/ ctx[40]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*value*/ 4) switch_instance_changes.item = /*value*/ ctx[2];
    			if (dirty[0] & /*getSelectionLabel*/ 4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[12];

    			if (switch_value !== (switch_value = /*Selection*/ ctx[25])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (917:4) {#if showClearIcon}
    function create_if_block_6$1(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*ClearIcon*/ ctx[23];

    	function switch_props(ctx) {
    		return {};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "clearSelect svelte-b8sh3g");
    			attr(div, "aria-hidden", "true");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen(div, "click", prevent_default(/*handleClear*/ ctx[27]));
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (switch_value !== (switch_value = /*ClearIcon*/ ctx[23])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (926:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
    function create_if_block_4$1(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*indicatorSvg*/ ctx[22]) return create_if_block_5$1;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			div = element("div");
    			if_block.c();
    			attr(div, "class", "indicator svelte-b8sh3g");
    			attr(div, "aria-hidden", "true");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if_block.d();
    		}
    	};
    }

    // (930:12) {:else}
    function create_else_block$a(ctx) {
    	let svg;
    	let path;

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
    			attr(svg, "width", "100%");
    			attr(svg, "height", "100%");
    			attr(svg, "viewBox", "0 0 20 20");
    			attr(svg, "focusable", "false");
    			attr(svg, "aria-hidden", "true");
    			attr(svg, "class", "svelte-b8sh3g");
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    // (928:12) {#if indicatorSvg}
    function create_if_block_5$1(ctx) {
    	let html_tag;
    	let html_anchor;

    	return {
    		c() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m(target, anchor) {
    			html_tag.m(/*indicatorSvg*/ ctx[22], target, anchor);
    			insert(target, html_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*indicatorSvg*/ 4194304) html_tag.p(/*indicatorSvg*/ ctx[22]);
    		},
    		d(detaching) {
    			if (detaching) detach(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};
    }

    // (948:4) {#if isWaiting}
    function create_if_block_3$1(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.innerHTML = `<svg class="spinner_icon svelte-b8sh3g" viewBox="25 25 50 50"><circle class="spinner_path svelte-b8sh3g" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`;
    			attr(div, "class", "spinner svelte-b8sh3g");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (964:4) {#if listOpen}
    function create_if_block_2$3(ctx) {
    	let switch_instance;
    	let updating_hoverItemIndex;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*listProps*/ ctx[34]];

    	function switch_instance_hoverItemIndex_binding(value) {
    		/*switch_instance_hoverItemIndex_binding*/ ctx[84](value);
    	}

    	var switch_value = /*List*/ ctx[24];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		if (/*hoverItemIndex*/ ctx[28] !== void 0) {
    			switch_instance_props.hoverItemIndex = /*hoverItemIndex*/ ctx[28];
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind$1(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
    		switch_instance.$on("itemSelected", /*itemSelected*/ ctx[43]);
    		switch_instance.$on("itemCreated", /*itemCreated*/ ctx[44]);
    		switch_instance.$on("closeList", /*closeList*/ ctx[45]);
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = (dirty[1] & /*listProps*/ 8)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*listProps*/ ctx[34])])
    			: {};

    			if (!updating_hoverItemIndex && dirty[0] & /*hoverItemIndex*/ 268435456) {
    				updating_hoverItemIndex = true;
    				switch_instance_changes.hoverItemIndex = /*hoverItemIndex*/ ctx[28];
    				add_flush_callback(() => updating_hoverItemIndex = false);
    			}

    			if (switch_value !== (switch_value = /*List*/ ctx[24])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind$1(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
    					switch_instance.$on("itemSelected", /*itemSelected*/ ctx[43]);
    					switch_instance.$on("itemCreated", /*itemCreated*/ ctx[44]);
    					switch_instance.$on("closeList", /*closeList*/ ctx[45]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (974:4) {#if !isMulti || (isMulti && !showMultiSelect)}
    function create_if_block_1$8(ctx) {
    	let input_1;
    	let input_1_name_value;
    	let input_1_value_value;

    	return {
    		c() {
    			input_1 = element("input");
    			attr(input_1, "name", input_1_name_value = /*inputAttributes*/ ctx[16].name);
    			attr(input_1, "type", "hidden");

    			input_1.value = input_1_value_value = /*value*/ ctx[2]
    			? /*getSelectionLabel*/ ctx[12](/*value*/ ctx[2])
    			: null;

    			attr(input_1, "class", "svelte-b8sh3g");
    		},
    		m(target, anchor) {
    			insert(target, input_1, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*inputAttributes*/ 65536 && input_1_name_value !== (input_1_name_value = /*inputAttributes*/ ctx[16].name)) {
    				attr(input_1, "name", input_1_name_value);
    			}

    			if (dirty[0] & /*value, getSelectionLabel*/ 4100 && input_1_value_value !== (input_1_value_value = /*value*/ ctx[2]
    			? /*getSelectionLabel*/ ctx[12](/*value*/ ctx[2])
    			: null)) {
    				input_1.value = input_1_value_value;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(input_1);
    		}
    	};
    }

    // (981:4) {#if isMulti && showMultiSelect}
    function create_if_block$e(ctx) {
    	let each_1_anchor;
    	let each_value = /*value*/ ctx[2];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*inputAttributes, value, getSelectionLabel*/ 69636) {
    				each_value = /*value*/ ctx[2];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    // (982:8) {#each value as item}
    function create_each_block$h(ctx) {
    	let input_1;
    	let input_1_name_value;
    	let input_1_value_value;

    	return {
    		c() {
    			input_1 = element("input");
    			attr(input_1, "name", input_1_name_value = /*inputAttributes*/ ctx[16].name);
    			attr(input_1, "type", "hidden");

    			input_1.value = input_1_value_value = /*item*/ ctx[103]
    			? /*getSelectionLabel*/ ctx[12](/*item*/ ctx[103])
    			: null;

    			attr(input_1, "class", "svelte-b8sh3g");
    		},
    		m(target, anchor) {
    			insert(target, input_1, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*inputAttributes*/ 65536 && input_1_name_value !== (input_1_name_value = /*inputAttributes*/ ctx[16].name)) {
    				attr(input_1, "name", input_1_name_value);
    			}

    			if (dirty[0] & /*value, getSelectionLabel*/ 4100 && input_1_value_value !== (input_1_value_value = /*item*/ ctx[103]
    			? /*getSelectionLabel*/ ctx[12](/*item*/ ctx[103])
    			: null)) {
    				input_1.value = input_1_value_value;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(input_1);
    		}
    	};
    }

    function create_fragment$R(ctx) {
    	let div;
    	let span;
    	let t0;
    	let t1;
    	let t2;
    	let input_1;
    	let input_1_readonly_value;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isFocused*/ ctx[1] && create_if_block_10$1(ctx);
    	let if_block1 = /*Icon*/ ctx[17] && create_if_block_9$1(ctx);
    	let if_block2 = /*showMultiSelect*/ ctx[35] && create_if_block_8$1(ctx);

    	let input_1_levels = [
    		{
    			readOnly: input_1_readonly_value = !/*isSearchable*/ ctx[13]
    		},
    		/*_inputAttributes*/ ctx[31],
    		{ placeholder: /*placeholderText*/ ctx[36] },
    		{ style: /*inputStyles*/ ctx[14] },
    		{ disabled: /*isDisabled*/ ctx[9] }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	let if_block3 = !/*isMulti*/ ctx[7] && /*showSelectedItem*/ ctx[29] && create_if_block_7$1(ctx);
    	let if_block4 = /*showClearIcon*/ ctx[37] && create_if_block_6$1(ctx);
    	let if_block5 = !/*showClearIcon*/ ctx[37] && (/*showIndicator*/ ctx[20] || /*showChevron*/ ctx[19] && !/*value*/ ctx[2] || !/*isSearchable*/ ctx[13] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[4] && (/*showSelectedItem*/ ctx[29] && !/*isClearable*/ ctx[15] || !/*showSelectedItem*/ ctx[29])) && create_if_block_4$1(ctx);
    	let if_block6 = /*isWaiting*/ ctx[4] && create_if_block_3$1();
    	let if_block7 = /*listOpen*/ ctx[5] && create_if_block_2$3(ctx);
    	let if_block8 = (!/*isMulti*/ ctx[7] || /*isMulti*/ ctx[7] && !/*showMultiSelect*/ ctx[35]) && create_if_block_1$8(ctx);
    	let if_block9 = /*isMulti*/ ctx[7] && /*showMultiSelect*/ ctx[35] && create_if_block$e(ctx);

    	return {
    		c() {
    			div = element("div");
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			input_1 = element("input");
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if (if_block5) if_block5.c();
    			t6 = space();
    			if (if_block6) if_block6.c();
    			t7 = space();
    			if (if_block7) if_block7.c();
    			t8 = space();
    			if (if_block8) if_block8.c();
    			t9 = space();
    			if (if_block9) if_block9.c();
    			attr(span, "aria-live", "polite");
    			attr(span, "aria-atomic", "false");
    			attr(span, "aria-relevant", "additions text");
    			attr(span, "class", "a11yText svelte-b8sh3g");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-b8sh3g", true);
    			attr(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-b8sh3g");
    			attr(div, "style", /*containerStyles*/ ctx[11]);
    			toggle_class(div, "hasError", /*hasError*/ ctx[10]);
    			toggle_class(div, "multiSelect", /*isMulti*/ ctx[7]);
    			toggle_class(div, "disabled", /*isDisabled*/ ctx[9]);
    			toggle_class(div, "focused", /*isFocused*/ ctx[1]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			if (if_block0) if_block0.m(span, null);
    			append(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append(div, t2);
    			append(div, input_1);
    			if (input_1.autofocus) input_1.focus();
    			/*input_1_binding*/ ctx[82](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[3]);
    			append(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			append(div, t4);
    			if (if_block4) if_block4.m(div, null);
    			append(div, t5);
    			if (if_block5) if_block5.m(div, null);
    			append(div, t6);
    			if (if_block6) if_block6.m(div, null);
    			append(div, t7);
    			if (if_block7) if_block7.m(div, null);
    			append(div, t8);
    			if (if_block8) if_block8.m(div, null);
    			append(div, t9);
    			if (if_block9) if_block9.m(div, null);
    			/*div_binding*/ ctx[85](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window, "click", /*handleWindowEvent*/ ctx[41]),
    					listen(window, "focusin", /*handleWindowEvent*/ ctx[41]),
    					listen(window, "keydown", /*handleKeyDown*/ ctx[39]),
    					listen(input_1, "focus", /*handleFocus*/ ctx[40]),
    					listen(input_1, "input", /*input_1_input_handler*/ ctx[83]),
    					listen(div, "click", /*handleClick*/ ctx[42])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (/*isFocused*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_10$1(ctx);
    					if_block0.c();
    					if_block0.m(span, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*Icon*/ ctx[17]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*Icon*/ 131072) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_9$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*showMultiSelect*/ ctx[35]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[1] & /*showMultiSelect*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_8$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				(!current || dirty[0] & /*isSearchable*/ 8192 && input_1_readonly_value !== (input_1_readonly_value = !/*isSearchable*/ ctx[13])) && { readOnly: input_1_readonly_value },
    				dirty[1] & /*_inputAttributes*/ 1 && /*_inputAttributes*/ ctx[31],
    				(!current || dirty[1] & /*placeholderText*/ 32) && { placeholder: /*placeholderText*/ ctx[36] },
    				(!current || dirty[0] & /*inputStyles*/ 16384) && { style: /*inputStyles*/ ctx[14] },
    				(!current || dirty[0] & /*isDisabled*/ 512) && { disabled: /*isDisabled*/ ctx[9] }
    			]));

    			if (dirty[0] & /*filterText*/ 8 && input_1.value !== /*filterText*/ ctx[3]) {
    				set_input_value(input_1, /*filterText*/ ctx[3]);
    			}

    			toggle_class(input_1, "svelte-b8sh3g", true);

    			if (!/*isMulti*/ ctx[7] && /*showSelectedItem*/ ctx[29]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, showSelectedItem*/ 536871040) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_7$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t4);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*showClearIcon*/ ctx[37]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[1] & /*showClearIcon*/ 64) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_6$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t5);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!/*showClearIcon*/ ctx[37] && (/*showIndicator*/ ctx[20] || /*showChevron*/ ctx[19] && !/*value*/ ctx[2] || !/*isSearchable*/ ctx[13] && !/*isDisabled*/ ctx[9] && !/*isWaiting*/ ctx[4] && (/*showSelectedItem*/ ctx[29] && !/*isClearable*/ ctx[15] || !/*showSelectedItem*/ ctx[29]))) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_4$1(ctx);
    					if_block5.c();
    					if_block5.m(div, t6);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*isWaiting*/ ctx[4]) {
    				if (if_block6) ; else {
    					if_block6 = create_if_block_3$1();
    					if_block6.c();
    					if_block6.m(div, t7);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (/*listOpen*/ ctx[5]) {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);

    					if (dirty[0] & /*listOpen*/ 32) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_2$3(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(div, t8);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (!/*isMulti*/ ctx[7] || /*isMulti*/ ctx[7] && !/*showMultiSelect*/ ctx[35]) {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);
    				} else {
    					if_block8 = create_if_block_1$8(ctx);
    					if_block8.c();
    					if_block8.m(div, t9);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}

    			if (/*isMulti*/ ctx[7] && /*showMultiSelect*/ ctx[35]) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);
    				} else {
    					if_block9 = create_if_block$e(ctx);
    					if_block9.c();
    					if_block9.m(div, null);
    				}
    			} else if (if_block9) {
    				if_block9.d(1);
    				if_block9 = null;
    			}

    			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-b8sh3g")) {
    				attr(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*containerStyles*/ 2048) {
    				attr(div, "style", /*containerStyles*/ ctx[11]);
    			}

    			if (dirty[0] & /*containerClasses, hasError*/ 2098176) {
    				toggle_class(div, "hasError", /*hasError*/ ctx[10]);
    			}

    			if (dirty[0] & /*containerClasses, isMulti*/ 2097280) {
    				toggle_class(div, "multiSelect", /*isMulti*/ ctx[7]);
    			}

    			if (dirty[0] & /*containerClasses, isDisabled*/ 2097664) {
    				toggle_class(div, "disabled", /*isDisabled*/ ctx[9]);
    			}

    			if (dirty[0] & /*containerClasses, isFocused*/ 2097154) {
    				toggle_class(div, "focused", /*isFocused*/ ctx[1]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block7);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block7);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			/*input_1_binding*/ ctx[82](null);
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (if_block9) if_block9.d();
    			/*div_binding*/ ctx[85](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function convertStringItemsToObjects(_items) {
    	return _items.map((item, index) => {
    		return { index, value: item, label: `${item}` };
    	});
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let filteredItems;
    	let showSelectedItem;
    	let showClearIcon;
    	let placeholderText;
    	let showMultiSelect;
    	let listProps;
    	let ariaSelection;
    	let ariaContext;
    	const dispatch = createEventDispatcher();
    	let { id = null } = $$props;
    	let { container = undefined } = $$props;
    	let { input = undefined } = $$props;
    	let { isMulti = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { isDisabled = false } = $$props;
    	let { isCreatable = false } = $$props;
    	let { isFocused = false } = $$props;
    	let { value = null } = $$props;
    	let { filterText = '' } = $$props;
    	let { placeholder = 'Select...' } = $$props;
    	let { placeholderAlwaysShow = false } = $$props;
    	let { items = null } = $$props;
    	let { itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
    	let { groupBy = undefined } = $$props;
    	let { groupFilter = groups => groups } = $$props;
    	let { isGroupHeaderSelectable = false } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option[labelIdentifier] || option.id;
    	} } = $$props;

    	let { labelIdentifier = 'label' } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		return option.isCreator
    		? `Create \"${filterText}\"`
    		: option[labelIdentifier];
    	} } = $$props;

    	let { optionIdentifier = 'value' } = $$props;
    	let { loadOptions = undefined } = $$props;
    	let { hasError = false } = $$props;
    	let { containerStyles = '' } = $$props;

    	let { getSelectionLabel = option => {
    		if (option) return option[labelIdentifier]; else return null;
    	} } = $$props;

    	let { createGroupHeaderItem = groupValue => {
    		return { value: groupValue, label: groupValue };
    	} } = $$props;

    	let { createItem = filterText => {
    		return { value: filterText, label: filterText };
    	} } = $$props;

    	const getFilteredItems = () => {
    		return filteredItems;
    	};

    	let { isSearchable = true } = $$props;
    	let { inputStyles = '' } = $$props;
    	let { isClearable = true } = $$props;
    	let { isWaiting = false } = $$props;
    	let { listPlacement = 'auto' } = $$props;
    	let { listOpen = false } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { loadOptionsInterval = 300 } = $$props;
    	let { noOptionsMessage = 'No options' } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { inputAttributes = {} } = $$props;
    	let { listAutoWidth = true } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { Icon = undefined } = $$props;
    	let { iconProps = {} } = $$props;
    	let { showChevron = false } = $$props;
    	let { showIndicator = false } = $$props;
    	let { containerClasses = '' } = $$props;
    	let { indicatorSvg = undefined } = $$props;
    	let { listOffset = 5 } = $$props;
    	let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { List: List$1 = List } = $$props;
    	let { Selection: Selection$1 = Selection } = $$props;
    	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
    	let { VirtualList: VirtualList$1 = VirtualList } = $$props;

    	function filterMethod(args) {
    		if (args.loadOptions && args.filterText.length > 0) return;
    		if (!args.items) return [];

    		if (args.items && args.items.length > 0 && typeof args.items[0] !== 'object') {
    			args.items = convertStringItemsToObjects(args.items);
    		}

    		let filterResults = args.items.filter(item => {
    			let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);

    			if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
    				matchesFilter = !args.value.some(x => {
    					return x[args.optionIdentifier] === item[args.optionIdentifier];
    				});
    			}

    			return matchesFilter;
    		});

    		if (args.groupBy) {
    			filterResults = filterGroupedItems(filterResults);
    		}

    		if (args.isCreatable) {
    			filterResults = addCreatableItem(filterResults, args.filterText);
    		}

    		return filterResults;
    	}

    	function addCreatableItem(_items, _filterText) {
    		if (_filterText.length === 0) return _items;
    		const itemToCreate = createItem(_filterText);
    		if (_items[0] && _filterText === _items[0][labelIdentifier]) return _items;
    		itemToCreate.isCreator = true;
    		return [..._items, itemToCreate];
    	}

    	let { selectedValue = null } = $$props;
    	let activeValue;
    	let prev_value;
    	let prev_filterText;
    	let prev_isFocused;
    	let prev_isMulti;
    	let hoverItemIndex;

    	const getItems = debounce$1(
    		async () => {
    			$$invalidate(4, isWaiting = true);

    			let res = await loadOptions(filterText).catch(err => {
    				console.warn('svelte-select loadOptions error :>> ', err);
    				dispatch('error', { type: 'loadOptions', details: err });
    			});

    			if (res && !res.cancelled) {
    				if (res) {
    					if (res && res.length > 0 && typeof res[0] !== 'object') {
    						res = convertStringItemsToObjects(res);
    					}

    					$$invalidate(81, filteredItems = [...res]);
    					dispatch('loaded', { items: filteredItems });
    				} else {
    					$$invalidate(81, filteredItems = []);
    				}

    				if (isCreatable) {
    					$$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
    				}

    				$$invalidate(4, isWaiting = false);
    				$$invalidate(1, isFocused = true);
    				$$invalidate(5, listOpen = true);
    			}
    		},
    		loadOptionsInterval
    	);

    	function setValue() {
    		if (typeof value === 'string') {
    			$$invalidate(2, value = { [optionIdentifier]: value, label: value });
    		} else if (isMulti && Array.isArray(value) && value.length > 0) {
    			$$invalidate(2, value = value.map(item => typeof item === 'string'
    			? { value: item, label: item }
    			: item));
    		}
    	}

    	let _inputAttributes;

    	function assignInputAttributes() {
    		$$invalidate(31, _inputAttributes = Object.assign(
    			{
    				autocapitalize: 'none',
    				autocomplete: 'off',
    				autocorrect: 'off',
    				spellcheck: false,
    				tabindex: 0,
    				type: 'text',
    				'aria-autocomplete': 'list'
    			},
    			inputAttributes
    		));

    		if (id) {
    			$$invalidate(31, _inputAttributes.id = id, _inputAttributes);
    		}

    		if (!isSearchable) {
    			$$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
    		}
    	}

    	function filterGroupedItems(_items) {
    		const groupValues = [];
    		const groups = {};

    		_items.forEach(item => {
    			const groupValue = groupBy(item);

    			if (!groupValues.includes(groupValue)) {
    				groupValues.push(groupValue);
    				groups[groupValue] = [];

    				if (groupValue) {
    					groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
    						id: groupValue,
    						isGroupHeader: true,
    						isSelectable: isGroupHeaderSelectable
    					}));
    				}
    			}

    			groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    		});

    		const sortedGroupedItems = [];

    		groupFilter(groupValues).forEach(groupValue => {
    			sortedGroupedItems.push(...groups[groupValue]);
    		});

    		return sortedGroupedItems;
    	}

    	function dispatchSelectedItem() {
    		if (isMulti) {
    			if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
    				if (checkValueForDuplicates()) {
    					dispatch('select', value);
    				}
    			}

    			return;
    		}

    		if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
    			dispatch('select', value);
    		}
    	}

    	function setupFocus() {
    		if (isFocused || listOpen) {
    			handleFocus();
    		} else {
    			if (input) input.blur();
    		}
    	}

    	function setupMulti() {
    		if (value) {
    			if (Array.isArray(value)) {
    				$$invalidate(2, value = [...value]);
    			} else {
    				$$invalidate(2, value = [value]);
    			}
    		}
    	}

    	function setupSingle() {
    		if (value) $$invalidate(2, value = null);
    	}

    	function setupFilterText() {
    		if (filterText.length === 0) return;
    		$$invalidate(1, isFocused = true);
    		$$invalidate(5, listOpen = true);

    		if (loadOptions) {
    			getItems();
    		} else {
    			$$invalidate(5, listOpen = true);

    			if (isMulti) {
    				$$invalidate(30, activeValue = undefined);
    			}
    		}
    	}

    	beforeUpdate(async () => {
    		$$invalidate(77, prev_value = value);
    		$$invalidate(78, prev_filterText = filterText);
    		$$invalidate(79, prev_isFocused = isFocused);
    		$$invalidate(80, prev_isMulti = isMulti);
    	});

    	function checkValueForDuplicates() {
    		let noDuplicates = true;

    		if (value) {
    			const ids = [];
    			const uniqueValues = [];

    			value.forEach(val => {
    				if (!ids.includes(val[optionIdentifier])) {
    					ids.push(val[optionIdentifier]);
    					uniqueValues.push(val);
    				} else {
    					noDuplicates = false;
    				}
    			});

    			if (!noDuplicates) $$invalidate(2, value = uniqueValues);
    		}

    		return noDuplicates;
    	}

    	function findItem(selection) {
    		let matchTo = selection
    		? selection[optionIdentifier]
    		: value[optionIdentifier];

    		return items.find(item => item[optionIdentifier] === matchTo);
    	}

    	function updateValueDisplay(items) {
    		if (!items || items.length === 0 || items.some(item => typeof item !== 'object')) return;

    		if (!value || (isMulti
    		? value.some(selection => !selection || !selection[optionIdentifier])
    		: !value[optionIdentifier])) return;

    		if (Array.isArray(value)) {
    			$$invalidate(2, value = value.map(selection => findItem(selection) || selection));
    		} else {
    			$$invalidate(2, value = findItem() || value);
    		}
    	}

    	function handleMultiItemClear(event) {
    		const { detail } = event;
    		const itemToRemove = value[detail ? detail.i : value.length - 1];

    		if (value.length === 1) {
    			$$invalidate(2, value = undefined);
    		} else {
    			$$invalidate(2, value = value.filter(item => {
    				return item !== itemToRemove;
    			}));
    		}

    		dispatch('clear', itemToRemove);
    	}

    	function handleKeyDown(e) {
    		if (!isFocused) return;

    		switch (e.key) {
    			case 'ArrowDown':
    				e.preventDefault();
    				$$invalidate(5, listOpen = true);
    				$$invalidate(30, activeValue = undefined);
    				break;
    			case 'ArrowUp':
    				e.preventDefault();
    				$$invalidate(5, listOpen = true);
    				$$invalidate(30, activeValue = undefined);
    				break;
    			case 'Tab':
    				if (!listOpen) $$invalidate(1, isFocused = false);
    				break;
    			case 'Backspace':
    				if (!isMulti || filterText.length > 0) return;
    				if (isMulti && value && value.length > 0) {
    					handleMultiItemClear(activeValue !== undefined
    					? activeValue
    					: value.length - 1);

    					if (activeValue === 0 || activeValue === undefined) break;
    					$$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
    				}
    				break;
    			case 'ArrowLeft':
    				if (!isMulti || filterText.length > 0) return;
    				if (activeValue === undefined) {
    					$$invalidate(30, activeValue = value.length - 1);
    				} else if (value.length > activeValue && activeValue !== 0) {
    					$$invalidate(30, activeValue -= 1);
    				}
    				break;
    			case 'ArrowRight':
    				if (!isMulti || filterText.length > 0 || activeValue === undefined) return;
    				if (activeValue === value.length - 1) {
    					$$invalidate(30, activeValue = undefined);
    				} else if (activeValue < value.length - 1) {
    					$$invalidate(30, activeValue += 1);
    				}
    				break;
    		}
    	}

    	function handleFocus() {
    		$$invalidate(1, isFocused = true);
    		if (input) input.focus();
    	}

    	function handleWindowEvent(event) {
    		if (!container) return;

    		const eventTarget = event.path && event.path.length > 0
    		? event.path[0]
    		: event.target;

    		if (container.contains(eventTarget)) return;
    		$$invalidate(1, isFocused = false);
    		$$invalidate(5, listOpen = false);
    		$$invalidate(30, activeValue = undefined);
    		if (input) input.blur();
    	}

    	function handleClick() {
    		if (isDisabled) return;
    		$$invalidate(1, isFocused = true);
    		$$invalidate(5, listOpen = !listOpen);
    	}

    	function handleClear() {
    		$$invalidate(2, value = undefined);
    		$$invalidate(5, listOpen = false);
    		dispatch('clear', value);
    		handleFocus();
    	}

    	onMount(() => {
    		if (isFocused && input) input.focus();
    	});

    	function itemSelected(event) {
    		const { detail } = event;

    		if (detail) {
    			$$invalidate(3, filterText = '');
    			const item = Object.assign({}, detail);

    			if (!item.isGroupHeader || item.isSelectable) {
    				if (isMulti) {
    					$$invalidate(2, value = value ? value.concat([item]) : [item]);
    				} else {
    					$$invalidate(2, value = item);
    				}

    				$$invalidate(2, value);

    				setTimeout(() => {
    					$$invalidate(5, listOpen = false);
    					$$invalidate(30, activeValue = undefined);
    				});
    			}
    		}
    	}

    	function itemCreated(event) {
    		const { detail } = event;

    		if (isMulti) {
    			$$invalidate(2, value = value || []);
    			$$invalidate(2, value = [...value, createItem(detail)]);
    		} else {
    			$$invalidate(2, value = createItem(detail));
    		}

    		dispatch('itemCreated', detail);
    		$$invalidate(3, filterText = '');
    		$$invalidate(5, listOpen = false);
    		$$invalidate(30, activeValue = undefined);
    	}

    	function closeList() {
    		$$invalidate(3, filterText = '');
    		$$invalidate(5, listOpen = false);
    	}

    	let { ariaValues = values => {
    		return `Option ${values}, selected.`;
    	} } = $$props;

    	let { ariaListOpen = (label, count) => {
    		return `You are currently focused on option ${label}. There are ${count} results available.`;
    	} } = $$props;

    	let { ariaFocused = () => {
    		return `Select is focused, type to refine list, press down to open the menu.`;
    	} } = $$props;

    	function handleAriaSelection() {
    		let selected = undefined;

    		if (isMulti && value.length > 0) {
    			selected = value.map(v => getSelectionLabel(v)).join(', ');
    		} else {
    			selected = getSelectionLabel(value);
    		}

    		return ariaValues(selected);
    	}

    	function handleAriaContent() {
    		if (!isFocused || !filteredItems || filteredItems.length === 0) return '';
    		let _item = filteredItems[hoverItemIndex];

    		if (listOpen && _item) {
    			let label = getSelectionLabel(_item);
    			let count = filteredItems ? filteredItems.length : 0;
    			return ariaListOpen(label, count);
    		} else {
    			return ariaFocused();
    		}
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(6, input);
    		});
    	}

    	function input_1_input_handler() {
    		filterText = this.value;
    		$$invalidate(3, filterText);
    	}

    	function switch_instance_hoverItemIndex_binding(value) {
    		hoverItemIndex = value;
    		$$invalidate(28, hoverItemIndex);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(46, id = $$props.id);
    		if ('container' in $$props) $$invalidate(0, container = $$props.container);
    		if ('input' in $$props) $$invalidate(6, input = $$props.input);
    		if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
    		if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
    		if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
    		if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
    		if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
    		if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
    		if ('items' in $$props) $$invalidate(50, items = $$props.items);
    		if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
    		if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
    		if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
    		if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
    		if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
    		if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
    		if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
    		if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
    		if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
    		if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
    		if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
    		if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
    		if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
    		if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
    		if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
    		if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
    		if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
    		if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
    		if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
    		if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
    		if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
    		if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
    		if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
    		if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
    		if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    		if ('Item' in $$props) $$invalidate(71, Item$1 = $$props.Item);
    		if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
    		if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
    		if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
    		if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
    		if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
    		if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
    		if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
    		if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*filterText, value, isMulti*/ 140 | $$self.$$.dirty[1] & /*loadOptions, items, optionIdentifier, groupBy, isCreatable*/ 405340160) {
    			$$invalidate(81, filteredItems = filterMethod({
    				loadOptions,
    				filterText,
    				items,
    				value,
    				isMulti,
    				optionIdentifier,
    				groupBy,
    				isCreatable
    			}));
    		}

    		if ($$self.$$.dirty[2] & /*selectedValue*/ 2048) {
    			{
    				if (selectedValue) console.warn('selectedValue is no longer used. Please use value instead.');
    			}
    		}

    		if ($$self.$$.dirty[1] & /*items*/ 524288) {
    			updateValueDisplay(items);
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 4) {
    			{
    				if (value) setValue();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*inputAttributes, isSearchable*/ 73728) {
    			{
    				if (inputAttributes || !isSearchable) assignInputAttributes();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isMulti*/ 128 | $$self.$$.dirty[2] & /*prev_isMulti*/ 262144) {
    			{
    				if (isMulti) {
    					setupMulti();
    				}

    				if (prev_isMulti && !isMulti) {
    					setupSingle();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isMulti, value*/ 132) {
    			{
    				if (isMulti && value && value.length > 1) {
    					checkValueForDuplicates();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 4) {
    			{
    				if (value) dispatchSelectedItem();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value, isMulti*/ 132 | $$self.$$.dirty[2] & /*prev_value*/ 32768) {
    			{
    				if (!value && isMulti && prev_value) {
    					dispatch('select', value);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isFocused*/ 2 | $$self.$$.dirty[2] & /*prev_isFocused*/ 131072) {
    			{
    				if (isFocused !== prev_isFocused) {
    					setupFocus();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*filterText*/ 8 | $$self.$$.dirty[2] & /*prev_filterText*/ 65536) {
    			{
    				if (filterText !== prev_filterText) {
    					setupFilterText();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value, filterText*/ 12) {
    			$$invalidate(29, showSelectedItem = value && filterText.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/ 536904208) {
    			$$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
    		}

    		if ($$self.$$.dirty[0] & /*isMulti, value*/ 132 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/ 393216) {
    			$$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti
    			? placeholder
    			: value ? '' : placeholder);
    		}

    		if ($$self.$$.dirty[0] & /*isMulti, value*/ 132) {
    			$$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
    		}

    		if ($$self.$$.dirty[0] & /*filterText, value, isMulti, container*/ 141 | $$self.$$.dirty[1] & /*optionIdentifier, getGroupHeaderLabel, getOptionLabel*/ 218103808 | $$self.$$.dirty[2] & /*Item, noOptionsMessage, hideEmptyState, isVirtualList, VirtualList, filteredItems, itemHeight, listPlacement, listAutoWidth, listOffset*/ 526326) {
    			$$invalidate(34, listProps = {
    				Item: Item$1,
    				filterText,
    				optionIdentifier,
    				noOptionsMessage,
    				hideEmptyState,
    				isVirtualList,
    				VirtualList: VirtualList$1,
    				value,
    				isMulti,
    				getGroupHeaderLabel,
    				items: filteredItems,
    				itemHeight,
    				getOptionLabel,
    				listPlacement,
    				parent: container,
    				listAutoWidth,
    				listOffset
    			});
    		}

    		if ($$self.$$.dirty[0] & /*value, isMulti*/ 132) {
    			$$invalidate(33, ariaSelection = value ? handleAriaSelection() : '');
    		}

    		if ($$self.$$.dirty[0] & /*hoverItemIndex, isFocused, listOpen*/ 268435490 | $$self.$$.dirty[2] & /*filteredItems*/ 524288) {
    			$$invalidate(32, ariaContext = handleAriaContent());
    		}
    	};

    	return [
    		container,
    		isFocused,
    		value,
    		filterText,
    		isWaiting,
    		listOpen,
    		input,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		inputAttributes,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon$1,
    		List$1,
    		Selection$1,
    		MultiSelection$1,
    		handleClear,
    		hoverItemIndex,
    		showSelectedItem,
    		activeValue,
    		_inputAttributes,
    		ariaContext,
    		ariaSelection,
    		listProps,
    		showMultiSelect,
    		placeholderText,
    		showClearIcon,
    		handleMultiItemClear,
    		handleKeyDown,
    		handleFocus,
    		handleWindowEvent,
    		handleClick,
    		itemSelected,
    		itemCreated,
    		closeList,
    		id,
    		isCreatable,
    		placeholder,
    		placeholderAlwaysShow,
    		items,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		labelIdentifier,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		createGroupHeaderItem,
    		createItem,
    		getFilteredItems,
    		listPlacement,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		listAutoWidth,
    		itemHeight,
    		listOffset,
    		Item$1,
    		VirtualList$1,
    		selectedValue,
    		ariaValues,
    		ariaListOpen,
    		ariaFocused,
    		prev_value,
    		prev_filterText,
    		prev_isFocused,
    		prev_isMulti,
    		filteredItems,
    		input_1_binding,
    		input_1_input_handler,
    		switch_instance_hoverItemIndex_binding,
    		div_binding
    	];
    }

    class Select extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$Q,
    			create_fragment$R,
    			safe_not_equal,
    			{
    				id: 46,
    				container: 0,
    				input: 6,
    				isMulti: 7,
    				multiFullItemClearable: 8,
    				isDisabled: 9,
    				isCreatable: 47,
    				isFocused: 1,
    				value: 2,
    				filterText: 3,
    				placeholder: 48,
    				placeholderAlwaysShow: 49,
    				items: 50,
    				itemFilter: 51,
    				groupBy: 52,
    				groupFilter: 53,
    				isGroupHeaderSelectable: 54,
    				getGroupHeaderLabel: 55,
    				labelIdentifier: 56,
    				getOptionLabel: 57,
    				optionIdentifier: 58,
    				loadOptions: 59,
    				hasError: 10,
    				containerStyles: 11,
    				getSelectionLabel: 12,
    				createGroupHeaderItem: 60,
    				createItem: 61,
    				getFilteredItems: 62,
    				isSearchable: 13,
    				inputStyles: 14,
    				isClearable: 15,
    				isWaiting: 4,
    				listPlacement: 63,
    				listOpen: 5,
    				isVirtualList: 64,
    				loadOptionsInterval: 65,
    				noOptionsMessage: 66,
    				hideEmptyState: 67,
    				inputAttributes: 16,
    				listAutoWidth: 68,
    				itemHeight: 69,
    				Icon: 17,
    				iconProps: 18,
    				showChevron: 19,
    				showIndicator: 20,
    				containerClasses: 21,
    				indicatorSvg: 22,
    				listOffset: 70,
    				ClearIcon: 23,
    				Item: 71,
    				List: 24,
    				Selection: 25,
    				MultiSelection: 26,
    				VirtualList: 72,
    				selectedValue: 73,
    				handleClear: 27,
    				ariaValues: 74,
    				ariaListOpen: 75,
    				ariaFocused: 76
    			},
    			null,
    			[-1, -1, -1, -1]
    		);
    	}

    	get getFilteredItems() {
    		return this.$$.ctx[62];
    	}

    	get handleClear() {
    		return this.$$.ctx[27];
    	}
    }

    /* src/components/Input/SelectInput.svelte generated by Svelte v3.42.4 */

    function create_fragment$Q(ctx) {
    	let select;
    	let current;

    	select = new Select({
    			props: {
    				items: /*selectionOptions*/ ctx[1],
    				inputStyles: /*inputStyles*/ ctx[6],
    				value: /*selectedValuesArray*/ ctx[8].length !== 0
    				? /*selectedValuesArray*/ ctx[8]
    				: undefined,
    				isDisabled: /*disabled*/ ctx[5],
    				isMulti: /*isMulti*/ ctx[2],
    				isCreatable: /*isCreatable*/ ctx[3],
    				isClearable: /*isClearable*/ ctx[4],
    				placeholder: /*placeholder*/ ctx[7]
    			}
    		});

    	select.$on("select", /*select_handler*/ ctx[9]);
    	select.$on("clear", /*clear_handler*/ ctx[10]);

    	return {
    		c() {
    			create_component(select.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(select, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const select_changes = {};
    			if (dirty & /*selectionOptions*/ 2) select_changes.items = /*selectionOptions*/ ctx[1];
    			if (dirty & /*inputStyles*/ 64) select_changes.inputStyles = /*inputStyles*/ ctx[6];

    			if (dirty & /*selectedValuesArray*/ 256) select_changes.value = /*selectedValuesArray*/ ctx[8].length !== 0
    			? /*selectedValuesArray*/ ctx[8]
    			: undefined;

    			if (dirty & /*disabled*/ 32) select_changes.isDisabled = /*disabled*/ ctx[5];
    			if (dirty & /*isMulti*/ 4) select_changes.isMulti = /*isMulti*/ ctx[2];
    			if (dirty & /*isCreatable*/ 8) select_changes.isCreatable = /*isCreatable*/ ctx[3];
    			if (dirty & /*isClearable*/ 16) select_changes.isClearable = /*isClearable*/ ctx[4];
    			if (dirty & /*placeholder*/ 128) select_changes.placeholder = /*placeholder*/ ctx[7];
    			select.$set(select_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(select, detaching);
    		}
    	};
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let selectedValuesArray;
    	let { value = "" } = $$props;
    	let { selectionOptions = [] } = $$props;
    	let { isMulti = true } = $$props;
    	let { isCreatable = true } = $$props;
    	let { isClearable = true } = $$props;
    	let { disabled = false } = $$props;
    	let { inputStyles = "cursor: pointer;" } = $$props;
    	let { placeholder = "Auswählen..." } = $$props;

    	const valuesToOptions = values => {
    		return values.map(value => selectionOptions.find(item => item === value || item.value === value) || value);
    	};

    	const selectedValuesFromString = valueString => {
    		let selectedValues = [];

    		if (valueString !== "") {
    			selectedValues = valuesToOptions(isMulti ? valueString.split(", ") : [valueString]);
    		}

    		if (!isMulti) {
    			selectedValues = selectedValues.length === 0 ? "" : selectedValues[0];
    		}

    		return selectedValues;
    	};

    	const select_handler = event => {
    		let selection = event.detail;

    		if (selection) {
    			if (!Array.isArray(selection)) selection = [selection];
    			$$invalidate(0, value = selection.map(item => item.value).join(", "));
    		} else {
    			$$invalidate(0, value = "");
    		}
    	};

    	const clear_handler = event => $$invalidate(0, value = "");

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('selectionOptions' in $$props) $$invalidate(1, selectionOptions = $$props.selectionOptions);
    		if ('isMulti' in $$props) $$invalidate(2, isMulti = $$props.isMulti);
    		if ('isCreatable' in $$props) $$invalidate(3, isCreatable = $$props.isCreatable);
    		if ('isClearable' in $$props) $$invalidate(4, isClearable = $$props.isClearable);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ('inputStyles' in $$props) $$invalidate(6, inputStyles = $$props.inputStyles);
    		if ('placeholder' in $$props) $$invalidate(7, placeholder = $$props.placeholder);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			$$invalidate(8, selectedValuesArray = selectedValuesFromString(value));
    		}
    	};

    	return [
    		value,
    		selectionOptions,
    		isMulti,
    		isCreatable,
    		isClearable,
    		disabled,
    		inputStyles,
    		placeholder,
    		selectedValuesArray,
    		select_handler,
    		clear_handler
    	];
    }

    class SelectInput extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$P, create_fragment$Q, safe_not_equal, {
    			value: 0,
    			selectionOptions: 1,
    			isMulti: 2,
    			isCreatable: 3,
    			isClearable: 4,
    			disabled: 5,
    			inputStyles: 6,
    			placeholder: 7
    		});
    	}
    }

    /* src/components/TableView/SearchFilterBar.svelte generated by Svelte v3.42.4 */

    function create_fragment$P(ctx) {
    	let div1;
    	let div0;
    	let input;
    	let t;
    	let selectinput;
    	let updating_value;
    	let current;
    	let mounted;
    	let dispose;

    	function selectinput_value_binding(value) {
    		/*selectinput_value_binding*/ ctx[11](value);
    	}

    	let selectinput_props = {
    		selectionOptions: /*filterOptions*/ ctx[1],
    		placeholder: "Filter",
    		isMulti: true,
    		inputStyles: "font-size: 16px; cursor: pointer;",
    		isCreatable: false
    	};

    	if (/*selectedValuesString*/ ctx[2] !== void 0) {
    		selectinput_props.value = /*selectedValuesString*/ ctx[2];
    	}

    	selectinput = new SelectInput({ props: selectinput_props });
    	binding_callbacks.push(() => bind$1(selectinput, 'value', selectinput_value_binding));

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t = space();
    			create_component(selectinput.$$.fragment);
    			attr(input, "class", "searchInput svelte-13z3r12");
    			attr(input, "type", "text");
    			attr(input, "placeholder", "Suche");
    			attr(div0, "class", "searchFilterBar svelte-13z3r12");
    			attr(div1, "class", "container svelte-13z3r12");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, input);
    			/*input_binding*/ ctx[8](input);
    			set_input_value(input, /*undebouncedSearchTerm*/ ctx[4]);
    			append(div0, t);
    			mount_component(selectinput, div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(input, "input", /*input_input_handler*/ ctx[9]),
    					listen(input, "input", /*input_handler*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*undebouncedSearchTerm*/ 16 && input.value !== /*undebouncedSearchTerm*/ ctx[4]) {
    				set_input_value(input, /*undebouncedSearchTerm*/ ctx[4]);
    			}

    			const selectinput_changes = {};
    			if (dirty & /*filterOptions*/ 2) selectinput_changes.selectionOptions = /*filterOptions*/ ctx[1];

    			if (!updating_value && dirty & /*selectedValuesString*/ 4) {
    				updating_value = true;
    				selectinput_changes.value = /*selectedValuesString*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			selectinput.$set(selectinput_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(selectinput.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(selectinput.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			/*input_binding*/ ctx[8](null);
    			destroy_component(selectinput);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$O($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let { filterOptions = [] } = $$props;
    	let { activeFilters = [] } = $$props;
    	let { searchTerm = "" } = $$props;
    	const focusSearchInput = () => searchInputRef.focus();
    	let searchInputRef;
    	let undebouncedSearchTerm = "";
    	let selectedValuesString = "";
    	let timer;

    	const debounce = functionAfterDebounce => {
    		clearTimeout(timer);

    		timer = setTimeout(
    			() => {
    				functionAfterDebounce();
    			},
    			750
    		);
    	};

    	const selectedValuesStringFromActiveFilters = () => {
    		if (selectedValuesString !== activeFilters.join(", ")) {
    			$$invalidate(2, selectedValuesString = activeFilters.join(", "));
    		}
    	};

    	const activeFiltersFromSelectedValuesString = () => {
    		if (selectedValuesString !== activeFilters.join(", ")) {
    			$$invalidate(6, activeFilters = selectedValuesString.split(", ").filter(val => val !== ""));
    			dispatch("filtersChanged", activeFilters);
    		}
    	};

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			searchInputRef = $$value;
    			$$invalidate(3, searchInputRef);
    		});
    	}

    	function input_input_handler() {
    		undebouncedSearchTerm = this.value;
    		($$invalidate(4, undebouncedSearchTerm), $$invalidate(0, searchTerm));
    	}

    	const input_handler = event => debounce(() => $$invalidate(0, searchTerm = event.target.value));

    	function selectinput_value_binding(value) {
    		selectedValuesString = value;
    		$$invalidate(2, selectedValuesString);
    	}

    	$$self.$$set = $$props => {
    		if ('filterOptions' in $$props) $$invalidate(1, filterOptions = $$props.filterOptions);
    		if ('activeFilters' in $$props) $$invalidate(6, activeFilters = $$props.activeFilters);
    		if ('searchTerm' in $$props) $$invalidate(0, searchTerm = $$props.searchTerm);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*searchTerm*/ 1) {
    			$$invalidate(4, undebouncedSearchTerm = searchTerm);
    		}

    		if ($$self.$$.dirty & /*activeFilters*/ 64) {
    			(selectedValuesStringFromActiveFilters());
    		}

    		if ($$self.$$.dirty & /*selectedValuesString*/ 4) {
    			(activeFiltersFromSelectedValuesString());
    		}
    	};

    	return [
    		searchTerm,
    		filterOptions,
    		selectedValuesString,
    		searchInputRef,
    		undebouncedSearchTerm,
    		debounce,
    		activeFilters,
    		focusSearchInput,
    		input_binding,
    		input_input_handler,
    		input_handler,
    		selectinput_value_binding
    	];
    }

    class SearchFilterBar extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$O, create_fragment$P, safe_not_equal, {
    			filterOptions: 1,
    			activeFilters: 6,
    			searchTerm: 0,
    			focusSearchInput: 7
    		});
    	}

    	get focusSearchInput() {
    		return this.$$.ctx[7];
    	}
    }

    const durationUnitRegex = /[a-zA-Z]/;
    const range = (size, startAt = 0) => [...Array(size).keys()].map(i => i + startAt);
    // export const characterRange = (startChar, endChar) =>
    //   String.fromCharCode(
    //     ...range(
    //       endChar.charCodeAt(0) - startChar.charCodeAt(0),
    //       startChar.charCodeAt(0)
    //     )
    //   );
    // export const zip = (arr, ...arrs) =>
    //   arr.map((val, i) => arrs.reduce((list, curr) => [...list, curr[i]], [val]));

    /* node_modules/svelte-loading-spinners/dist/Pulse.svelte generated by Svelte v3.42.4 */

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (45:2) {#each range(3, 0) as version}
    function create_each_block$g(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "cube svelte-446r86");
    			set_style(div, "animation-delay", /*version*/ ctx[6] * (+/*durationNum*/ ctx[5] / 10) + /*durationUnit*/ ctx[4]);
    			set_style(div, "left", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 3 + +/*size*/ ctx[3] / 15) + /*unit*/ ctx[1]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*size, unit*/ 10) {
    				set_style(div, "left", /*version*/ ctx[6] * (+/*size*/ ctx[3] / 3 + +/*size*/ ctx[3] / 15) + /*unit*/ ctx[1]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function create_fragment$O(ctx) {
    	let div;
    	let each_value = range(3, 0);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div, "class", "wrapper svelte-446r86");
    			set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
    			set_style(div, "--color", /*color*/ ctx[0]);
    			set_style(div, "--duration", /*duration*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*range, durationNum, durationUnit, size, unit*/ 58) {
    				each_value = range(3, 0);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*size, unit*/ 10) {
    				set_style(div, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
    			}

    			if (dirty & /*color*/ 1) {
    				set_style(div, "--color", /*color*/ ctx[0]);
    			}

    			if (dirty & /*duration*/ 4) {
    				set_style(div, "--duration", /*duration*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function instance$N($$self, $$props, $$invalidate) {
    	
    	let { color = "#FF3E00" } = $$props;
    	let { unit = "px" } = $$props;
    	let { duration = "1.5s" } = $$props;
    	let { size = "60" } = $$props;
    	let durationUnit = duration.match(durationUnitRegex)[0];
    	let durationNum = duration.replace(durationUnitRegex, "");

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('unit' in $$props) $$invalidate(1, unit = $$props.unit);
    		if ('duration' in $$props) $$invalidate(2, duration = $$props.duration);
    		if ('size' in $$props) $$invalidate(3, size = $$props.size);
    	};

    	return [color, unit, duration, size, durationUnit, durationNum];
    }

    class Pulse extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$N, create_fragment$O, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
    	}
    }

    /* node_modules/svelte-loading-spinners/dist/Diamonds.svelte generated by Svelte v3.42.4 */

    function create_fragment$N(ctx) {
    	let span;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;

    	return {
    		c() {
    			span = element("span");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			attr(div0, "class", "svelte-evhfle");
    			attr(div1, "class", "svelte-evhfle");
    			attr(div2, "class", "svelte-evhfle");
    			set_style(span, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
    			set_style(span, "--color", /*color*/ ctx[0]);
    			set_style(span, "--duration", /*duration*/ ctx[2]);
    			attr(span, "class", "svelte-evhfle");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			append(span, div0);
    			append(span, t0);
    			append(span, div1);
    			append(span, t1);
    			append(span, div2);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*size, unit*/ 10) {
    				set_style(span, "--size", /*size*/ ctx[3] + /*unit*/ ctx[1]);
    			}

    			if (dirty & /*color*/ 1) {
    				set_style(span, "--color", /*color*/ ctx[0]);
    			}

    			if (dirty & /*duration*/ 4) {
    				set_style(span, "--duration", /*duration*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    function instance$M($$self, $$props, $$invalidate) {
    	
    	let { color = "#FF3E00" } = $$props;
    	let { unit = "px" } = $$props;
    	let { duration = "1.5s" } = $$props;
    	let { size = "60" } = $$props;

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('unit' in $$props) $$invalidate(1, unit = $$props.unit);
    		if ('duration' in $$props) $$invalidate(2, duration = $$props.duration);
    		if ('size' in $$props) $$invalidate(3, size = $$props.size);
    	};

    	return [color, unit, duration, size];
    }

    class Diamonds extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$M, create_fragment$N, safe_not_equal, { color: 0, unit: 1, duration: 2, size: 3 });
    	}
    }

    /* src/components/TableView/Pagination.svelte generated by Svelte v3.42.4 */

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (1:0) <script>   import { Diamonds }
    function create_catch_block$3(ctx) {
    	return {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};
    }

    // (51:4) {:then numberOfPages}
    function create_then_block$3(ctx) {
    	let if_block_anchor;
    	let if_block = /*numberOfPages*/ ctx[2] > 1 && create_if_block$d(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (/*numberOfPages*/ ctx[2] > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (52:6) {#if numberOfPages > 1}
    function create_if_block$d(ctx) {
    	let a0;
    	let t1;
    	let t2;
    	let a1;
    	let mounted;
    	let dispose;
    	let each_value = /*pageButtons*/ ctx[3];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	return {
    		c() {
    			a0 = element("a");
    			a0.textContent = "«";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			a1 = element("a");
    			a1.textContent = "»";
    			attr(a0, "href", "#/");
    			attr(a0, "class", "svelte-tkxtr1");
    			attr(a1, "href", "#/");
    			attr(a1, "class", "svelte-tkxtr1");
    		},
    		m(target, anchor) {
    			insert(target, a0, anchor);
    			insert(target, t1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, t2, anchor);
    			insert(target, a1, anchor);

    			if (!mounted) {
    				dispose = [
    					listen(a0, "click", prevent_default(/*click_handler_1*/ ctx[6])),
    					listen(a1, "click", prevent_default(/*click_handler_3*/ ctx[8]))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*pageButtons, currentPage, setPage*/ 25) {
    				each_value = /*pageButtons*/ ctx[3];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t2.parentNode, t2);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(a0);
    			if (detaching) detach(t1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(t2);
    			if (detaching) detach(a1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (65:10) {:else}
    function create_else_block$9(ctx) {
    	let a;
    	let t_value = /*pageButton*/ ctx[10] + "";
    	let t;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", "#/");
    			attr(a, "class", "disabled svelte-tkxtr1");
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);

    			if (!mounted) {
    				dispose = listen(a, "click", prevent_default(/*click_handler*/ ctx[5]));
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*pageButtons*/ 8 && t_value !== (t_value = /*pageButton*/ ctx[10] + "")) set_data(t, t_value);
    		},
    		d(detaching) {
    			if (detaching) detach(a);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (57:10) {#if typeof pageButton === "number"}
    function create_if_block_1$7(ctx) {
    	let a;
    	let t_value = /*pageButton*/ ctx[10] + 1 + "";
    	let t;
    	let a_class_value;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[7](/*pageButton*/ ctx[10]);
    	}

    	return {
    		c() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", "#/");

    			attr(a, "class", a_class_value = "" + (null_to_empty(/*pageButton*/ ctx[10] === /*currentPage*/ ctx[0]
    			? "active"
    			: "") + " svelte-tkxtr1"));
    		},
    		m(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);

    			if (!mounted) {
    				dispose = listen(a, "click", prevent_default(click_handler_2));
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*pageButtons*/ 8 && t_value !== (t_value = /*pageButton*/ ctx[10] + 1 + "")) set_data(t, t_value);

    			if (dirty & /*pageButtons, currentPage*/ 9 && a_class_value !== (a_class_value = "" + (null_to_empty(/*pageButton*/ ctx[10] === /*currentPage*/ ctx[0]
    			? "active"
    			: "") + " svelte-tkxtr1"))) {
    				attr(a, "class", a_class_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(a);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (56:8) {#each pageButtons as pageButton}
    function create_each_block$f(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (typeof /*pageButton*/ ctx[10] === "number") return create_if_block_1$7;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (49:33)        <Diamonds size="100" color="#fc03a9" unit="px" />     {:then numberOfPages}
    function create_pending_block$3(ctx) {
    	let diamonds;
    	let current;

    	diamonds = new Diamonds({
    			props: {
    				size: "100",
    				color: "#fc03a9",
    				unit: "px"
    			}
    		});

    	return {
    		c() {
    			create_component(diamonds.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(diamonds, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(diamonds.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(diamonds.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(diamonds, detaching);
    		}
    	};
    }

    function create_fragment$M(ctx) {
    	let div1;
    	let div0;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$3,
    		then: create_then_block$3,
    		catch: create_catch_block$3,
    		value: 2,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*numberOfPagesPromise*/ ctx[1], info);

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			info.block.c();
    			attr(div0, "class", "pagination svelte-tkxtr1");
    			attr(div1, "class", "container svelte-tkxtr1");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = null;
    			current = true;
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*numberOfPagesPromise*/ 2 && promise !== (promise = /*numberOfPagesPromise*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { numberOfPagesPromise } = $$props;
    	let { currentPage } = $$props;
    	let pageButtons = [];
    	let numberOfPages = 1;

    	function calculatePageButtons(numberOfPages) {
    		if (numberOfPages === 0) {
    			$$invalidate(3, pageButtons = [0]);
    		} else {
    			$$invalidate(3, pageButtons = [
    				currentPage - 2,
    				currentPage - 1,
    				currentPage,
    				currentPage + 1,
    				currentPage + 2
    			]);

    			if (pageButtons[0] >= 3) {
    				$$invalidate(3, pageButtons = [0, "...", ...pageButtons]);
    			} else {
    				while (pageButtons[0] > 0) pageButtons.unshift(pageButtons[0] - 1);
    			}

    			if (numberOfPages - 1 - pageButtons[pageButtons.length - 1] >= 3) {
    				$$invalidate(3, pageButtons = [...pageButtons, "...", numberOfPages - 1]);
    			} else {
    				while (pageButtons[pageButtons.length - 1] < numberOfPages - 1) pageButtons.push(pageButtons[pageButtons.length - 1] + 1);
    			}

    			$$invalidate(3, pageButtons = pageButtons.filter(button => button === "..." || button >= 0 && button < numberOfPages));
    		}
    	}

    	function setPage(page = currentPage) {
    		page = Math.min(page, numberOfPages - 1);
    		page = Math.max(page, 0);
    		$$invalidate(0, currentPage = page);
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler_1 = () => setPage(currentPage - 1);
    	const click_handler_2 = pageButton => setPage(pageButton);
    	const click_handler_3 = () => setPage(currentPage + 1);

    	$$self.$$set = $$props => {
    		if ('numberOfPagesPromise' in $$props) $$invalidate(1, numberOfPagesPromise = $$props.numberOfPagesPromise);
    		if ('currentPage' in $$props) $$invalidate(0, currentPage = $$props.currentPage);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*numberOfPagesPromise*/ 2) {
    			numberOfPagesPromise.then(n => $$invalidate(2, numberOfPages = n));
    		}

    		if ($$self.$$.dirty & /*currentPage, numberOfPages*/ 5) {
    			(calculatePageButtons(numberOfPages));
    		}
    	};

    	return [
    		currentPage,
    		numberOfPagesPromise,
    		numberOfPages,
    		pageButtons,
    		setPage,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Pagination extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$L, create_fragment$M, safe_not_equal, { numberOfPagesPromise: 1, currentPage: 0 });
    	}
    }

    /* src/components/Table/Cell.svelte generated by Svelte v3.42.4 */

    function create_catch_block$2(ctx) {
    	return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
    }

    // (40:37)      {#if isImage}
    function create_then_block$2(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*isImage*/ ctx[1]) return create_if_block$c;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (45:4) {:else}
    function create_else_block$8(ctx) {
    	let div;
    	let t_value = /*value*/ ctx[5] + "";
    	let t;
    	let div_style_value;

    	return {
    		c() {
    			div = element("div");
    			t = text(t_value);
    			attr(div, "class", "cell svelte-1ebmzyw");
    			attr(div, "style", div_style_value = `max-height: ${/*rowHeight*/ ctx[3]}px;`);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*valueFunction*/ 4 && t_value !== (t_value = /*value*/ ctx[5] + "")) set_data(t, t_value);

    			if (dirty & /*rowHeight*/ 8 && div_style_value !== (div_style_value = `max-height: ${/*rowHeight*/ ctx[3]}px;`)) {
    				attr(div, "style", div_style_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (41:4) {#if isImage}
    function create_if_block$c(ctx) {
    	let if_block_anchor;
    	let if_block = /*value*/ ctx[5] && /*value*/ ctx[5] !== "" && create_if_block_1$6(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (/*value*/ ctx[5] && /*value*/ ctx[5] !== "") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (42:6) {#if value && value !== ""}
    function create_if_block_1$6(ctx) {
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*value*/ ctx[5])) attr(img, "src", img_src_value);
    			attr(img, "alt", "item");
    			attr(img, "class", "svelte-1ebmzyw");
    		},
    		m(target, anchor) {
    			insert(target, img, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*valueFunction*/ 4 && !src_url_equal(img.src, img_src_value = /*value*/ ctx[5])) {
    				attr(img, "src", img_src_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(img);
    		}
    	};
    }

    // (1:0) <script>   export let backgroundColor = "white";   export let isImage = false;   export let valueFunction = async () => "";   export let rowHeight = 40;    let fontColor = "black";    function brightnessByColor(color) {     var color = "" + color,       isHEX = color.indexOf("#") == 0,       isRGB = color.indexOf("rgb") == 0;     if (isHEX) {       var m = color         .substr(1)         .match(color.length == 7 ? /(\S{2}
    function create_pending_block$2(ctx) {
    	return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
    }

    function create_fragment$L(ctx) {
    	let td;
    	let promise;
    	let td_style_value;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		value: 5
    	};

    	handle_promise(promise = /*valueFunction*/ ctx[2](), info);

    	return {
    		c() {
    			td = element("td");
    			info.block.c();
    			attr(td, "style", td_style_value = `background-color: ${/*backgroundColor*/ ctx[0]}; color: ${/*fontColor*/ ctx[4]}; height: ${/*rowHeight*/ ctx[3]}px;`);
    			attr(td, "class", "svelte-1ebmzyw");
    		},
    		m(target, anchor) {
    			insert(target, td, anchor);
    			info.block.m(td, info.anchor = null);
    			info.mount = () => td;
    			info.anchor = null;
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*valueFunction*/ 4 && promise !== (promise = /*valueFunction*/ ctx[2]()) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}

    			if (dirty & /*backgroundColor, fontColor, rowHeight*/ 25 && td_style_value !== (td_style_value = `background-color: ${/*backgroundColor*/ ctx[0]}; color: ${/*fontColor*/ ctx[4]}; height: ${/*rowHeight*/ ctx[3]}px;`)) {
    				attr(td, "style", td_style_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(td);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};
    }

    function brightnessByColor(color) {
    	var color = "" + color,
    		isHEX = color.indexOf("#") == 0,
    		isRGB = color.indexOf("rgb") == 0;

    	if (isHEX) {
    		var m = color.substr(1).match(color.length == 7 ? /(\S{2})/g : /(\S{1})/g);
    		if (m) var r = parseInt(m[0], 16), g = parseInt(m[1], 16), b = parseInt(m[2], 16);
    	}

    	if (isRGB) {
    		var m = color.match(/rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/);
    		if (m) var r = m[1], g = m[2], b = m[3];
    	}

    	if (typeof r != "undefined") return (r * 299 + g * 587 + b * 114) / 1000;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { backgroundColor = "white" } = $$props;
    	let { isImage = false } = $$props;
    	let { valueFunction = async () => "" } = $$props;
    	let { rowHeight = 40 } = $$props;
    	let fontColor = "black";

    	$$self.$$set = $$props => {
    		if ('backgroundColor' in $$props) $$invalidate(0, backgroundColor = $$props.backgroundColor);
    		if ('isImage' in $$props) $$invalidate(1, isImage = $$props.isImage);
    		if ('valueFunction' in $$props) $$invalidate(2, valueFunction = $$props.valueFunction);
    		if ('rowHeight' in $$props) $$invalidate(3, rowHeight = $$props.rowHeight);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*backgroundColor*/ 1) {
    			if (brightnessByColor(backgroundColor) < 125) {
    				$$invalidate(4, fontColor = "white"); // adaptive font color for darker highlight
    			}
    		}
    	};

    	return [backgroundColor, isImage, valueFunction, rowHeight, fontColor];
    }

    class Cell extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$K, create_fragment$L, safe_not_equal, {
    			backgroundColor: 0,
    			isImage: 1,
    			valueFunction: 2,
    			rowHeight: 3
    		});
    	}
    }

    /* src/components/Table/Row.svelte generated by Svelte v3.42.4 */

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (36:2) {#each columns as col, i}
    function create_each_block$e(ctx) {
    	let cell;
    	let current;

    	function func() {
    		return /*func*/ ctx[9](/*col*/ ctx[10]);
    	}

    	cell = new Cell({
    			props: {
    				rowHeight: /*rowHeight*/ ctx[2],
    				isImage: /*col*/ ctx[10].isImageUrl,
    				valueFunction: func,
    				backgroundColor: /*cellBackgroundColors*/ ctx[3][/*i*/ ctx[12]]
    			}
    		});

    	return {
    		c() {
    			create_component(cell.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(cell, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const cell_changes = {};
    			if (dirty & /*rowHeight*/ 4) cell_changes.rowHeight = /*rowHeight*/ ctx[2];
    			if (dirty & /*columns*/ 1) cell_changes.isImage = /*col*/ ctx[10].isImageUrl;
    			if (dirty & /*columns, item*/ 3) cell_changes.valueFunction = func;
    			if (dirty & /*cellBackgroundColors*/ 8) cell_changes.backgroundColor = /*cellBackgroundColors*/ ctx[3][/*i*/ ctx[12]];
    			cell.$set(cell_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(cell.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(cell.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(cell, detaching);
    		}
    	};
    }

    function create_fragment$K(ctx) {
    	let tr;
    	let tr_style_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*columns*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(tr, "style", tr_style_value = `height: ${/*rowHeight*/ ctx[2]}px;`);
    			attr(tr, "class", "svelte-xkfbgl");
    		},
    		m(target, anchor) {
    			insert(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen(tr, "click", /*click_handler*/ ctx[8]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*rowHeight, columns, displayValue, item, cellBackgroundColors*/ 31) {
    				each_value = /*columns*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tr, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*rowHeight*/ 4 && tr_style_value !== (tr_style_value = `height: ${/*rowHeight*/ ctx[2]}px;`)) {
    				attr(tr, "style", tr_style_value);
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(tr);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let defaultBackgroundColor;
    	let { columns = [] } = $$props;
    	let { item = {} } = $$props;
    	let { rowHeight = 36 } = $$props;
    	let { cellBackgroundColorsFunction } = $$props;
    	let { evenRowNumber = false } = $$props;

    	const displayValue = async (col, item) => {
    		if (!(col.key in item)) {
    			return "";
    		} else {
    			return col.display
    			? await col.display(item[col.key])
    			: item[col.key];
    		}
    	};

    	let cellBackgroundColors = new Array(columns.length).fill("white");

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const func = col => displayValue(col, item);

    	$$self.$$set = $$props => {
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('item' in $$props) $$invalidate(1, item = $$props.item);
    		if ('rowHeight' in $$props) $$invalidate(2, rowHeight = $$props.rowHeight);
    		if ('cellBackgroundColorsFunction' in $$props) $$invalidate(5, cellBackgroundColorsFunction = $$props.cellBackgroundColorsFunction);
    		if ('evenRowNumber' in $$props) $$invalidate(6, evenRowNumber = $$props.evenRowNumber);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*evenRowNumber*/ 64) {
    			$$invalidate(7, defaultBackgroundColor = evenRowNumber
    			? ColorDefs.DEFAULT_ROW_BACKGROUND_EVEN
    			: ColorDefs.DEFAULT_ROW_BACKGROUND_ODD);
    		}

    		if ($$self.$$.dirty & /*cellBackgroundColorsFunction, item, columns, defaultBackgroundColor*/ 163) {
    			cellBackgroundColorsFunction(item).then(newCellBackgroundColors => {
    				if (!newCellBackgroundColors) newCellBackgroundColors = [];

    				while (newCellBackgroundColors.length < columns.length) {
    					newCellBackgroundColors.push("");
    				}

    				$$invalidate(3, cellBackgroundColors = newCellBackgroundColors.map(newColor => newColor && newColor != ""
    				? newColor
    				: defaultBackgroundColor));
    			});
    		}
    	};

    	return [
    		columns,
    		item,
    		rowHeight,
    		cellBackgroundColors,
    		displayValue,
    		cellBackgroundColorsFunction,
    		evenRowNumber,
    		defaultBackgroundColor,
    		click_handler,
    		func
    	];
    }

    class Row extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$J, create_fragment$K, safe_not_equal, {
    			columns: 0,
    			item: 1,
    			rowHeight: 2,
    			cellBackgroundColorsFunction: 5,
    			evenRowNumber: 6
    		});
    	}
    }

    /* node_modules/fa-svelte/src/Icon.svelte generated by Svelte v3.42.4 */

    function create_fragment$J(ctx) {
    	let svg;
    	let path_1;
    	let svg_class_value;

    	return {
    		c() {
    			svg = svg_element("svg");
    			path_1 = svg_element("path");
    			attr(path_1, "fill", "currentColor");
    			attr(path_1, "d", /*path*/ ctx[0]);
    			attr(svg, "aria-hidden", "true");
    			attr(svg, "class", svg_class_value = "" + (null_to_empty(/*classes*/ ctx[1]) + " svelte-1d15yci"));
    			attr(svg, "role", "img");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "viewBox", /*viewBox*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path_1);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*path*/ 1) {
    				attr(path_1, "d", /*path*/ ctx[0]);
    			}

    			if (dirty & /*classes*/ 2 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classes*/ ctx[1]) + " svelte-1d15yci"))) {
    				attr(svg, "class", svg_class_value);
    			}

    			if (dirty & /*viewBox*/ 4) {
    				attr(svg, "viewBox", /*viewBox*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { icon } = $$props;
    	let path = [];
    	let classes = "";
    	let viewBox = "";

    	$$self.$$set = $$new_props => {
    		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('icon' in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*icon*/ 8) {
    			$$invalidate(2, viewBox = "0 0 " + icon.icon[0] + " " + icon.icon[1]);
    		}

    		$$invalidate(1, classes = "fa-svelte " + ($$props.class ? $$props.class : ""));

    		if ($$self.$$.dirty & /*icon*/ 8) {
    			$$invalidate(0, path = icon.icon[4]);
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [path, classes, viewBox, icon];
    }

    class Icon extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$I, create_fragment$J, safe_not_equal, { icon: 3 });
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var faSort = {};

    (function (exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'sort';
    var width = 320;
    var height = 512;
    var ligatures = [];
    var unicode = 'f0dc';
    var svgPathData = 'M41 288h238c21.4 0 32.1 25.9 17 41L177 448c-9.4 9.4-24.6 9.4-33.9 0L24 329c-15.1-15.1-4.4-41 17-41zm255-105L177 64c-9.4-9.4-24.6-9.4-33.9 0L24 183c-15.1 15.1-4.4 41 17 41h238c21.4 0 32.1-25.9 17-41z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faSort = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    }(faSort));

    var faSortDown = {};

    (function (exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'sort-down';
    var width = 320;
    var height = 512;
    var ligatures = [];
    var unicode = 'f0dd';
    var svgPathData = 'M41 288h238c21.4 0 32.1 25.9 17 41L177 448c-9.4 9.4-24.6 9.4-33.9 0L24 329c-15.1-15.1-4.4-41 17-41z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faSortDown = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    }(faSortDown));

    var faSortUp = {};

    (function (exports) {
    Object.defineProperty(exports, '__esModule', { value: true });
    var prefix = 'fas';
    var iconName = 'sort-up';
    var width = 320;
    var height = 512;
    var ligatures = [];
    var unicode = 'f0de';
    var svgPathData = 'M279 224H41c-21.4 0-32.1-25.9-17-41L143 64c9.4-9.4 24.6-9.4 33.9 0l119 119c15.2 15.1 4.5 41-16.9 41z';

    exports.definition = {
      prefix: prefix,
      iconName: iconName,
      icon: [
        width,
        height,
        ligatures,
        unicode,
        svgPathData
      ]};

    exports.faSortUp = exports.definition;
    exports.prefix = prefix;
    exports.iconName = iconName;
    exports.width = width;
    exports.height = height;
    exports.ligatures = ligatures;
    exports.unicode = unicode;
    exports.svgPathData = svgPathData;
    }(faSortUp));

    /* src/components/Table/Header.svelte generated by Svelte v3.42.4 */

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (23:6) {:else}
    function create_else_block$7(ctx) {
    	let th;
    	let t0_value = /*col*/ ctx[7].title + "";
    	let t0;
    	let t1;
    	let span0;
    	let icon0;
    	let t2;
    	let span1;
    	let icon1;
    	let t3;
    	let span2;
    	let icon2;
    	let t4;
    	let current;
    	let mounted;
    	let dispose;
    	icon0 = new Icon({ props: { icon: faSort.faSort } });
    	icon1 = new Icon({ props: { icon: faSortUp.faSortUp } });
    	icon2 = new Icon({ props: { icon: faSortDown.faSortDown } });

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[5](/*col*/ ctx[7]);
    	}

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*col*/ ctx[7]);
    	}

    	return {
    		c() {
    			th = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			span0 = element("span");
    			create_component(icon0.$$.fragment);
    			t2 = space();
    			span1 = element("span");
    			create_component(icon1.$$.fragment);
    			t3 = space();
    			span2 = element("span");
    			create_component(icon2.$$.fragment);
    			t4 = space();
    			attr(span0, "class", "sort-indicator svelte-whzxrs");
    			toggle_class(span0, "visible", /*mouseOverColHeader*/ ctx[2][/*col*/ ctx[7].key]);
    			attr(span1, "class", "sort-indicator-up svelte-whzxrs");
    			toggle_class(span1, "visible", /*indicateSort*/ ctx[1][/*i*/ ctx[9]] === "up" && !/*mouseOverColHeader*/ ctx[2][/*col*/ ctx[7].key]);
    			attr(span2, "class", "sort-indicator-down svelte-whzxrs");
    			toggle_class(span2, "visible", /*indicateSort*/ ctx[1][/*i*/ ctx[9]] === "down" && !/*mouseOverColHeader*/ ctx[2][/*col*/ ctx[7].key]);
    			attr(th, "class", "clickable svelte-whzxrs");
    		},
    		m(target, anchor) {
    			insert(target, th, anchor);
    			append(th, t0);
    			append(th, t1);
    			append(th, span0);
    			mount_component(icon0, span0, null);
    			append(th, t2);
    			append(th, span1);
    			mount_component(icon1, span1, null);
    			append(th, t3);
    			append(th, span2);
    			mount_component(icon2, span2, null);
    			append(th, t4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(th, "mouseout", /*mouseout_handler*/ ctx[4]),
    					listen(th, "mouseover", mouseover_handler),
    					listen(th, "click", click_handler)
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*columns*/ 1) && t0_value !== (t0_value = /*col*/ ctx[7].title + "")) set_data(t0, t0_value);

    			if (dirty & /*mouseOverColHeader, columns*/ 5) {
    				toggle_class(span0, "visible", /*mouseOverColHeader*/ ctx[2][/*col*/ ctx[7].key]);
    			}

    			if (dirty & /*indicateSort, mouseOverColHeader, columns*/ 7) {
    				toggle_class(span1, "visible", /*indicateSort*/ ctx[1][/*i*/ ctx[9]] === "up" && !/*mouseOverColHeader*/ ctx[2][/*col*/ ctx[7].key]);
    			}

    			if (dirty & /*indicateSort, mouseOverColHeader, columns*/ 7) {
    				toggle_class(span2, "visible", /*indicateSort*/ ctx[1][/*i*/ ctx[9]] === "down" && !/*mouseOverColHeader*/ ctx[2][/*col*/ ctx[7].key]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			transition_in(icon2.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			transition_out(icon2.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(th);
    			destroy_component(icon0);
    			destroy_component(icon1);
    			destroy_component(icon2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (19:6) {#if col.disableSort}
    function create_if_block$b(ctx) {
    	let th;
    	let t0_value = /*col*/ ctx[7].title + "";
    	let t0;
    	let t1;

    	return {
    		c() {
    			th = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(th, "class", "svelte-whzxrs");
    		},
    		m(target, anchor) {
    			insert(target, th, anchor);
    			append(th, t0);
    			append(th, t1);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*columns*/ 1 && t0_value !== (t0_value = /*col*/ ctx[7].title + "")) set_data(t0, t0_value);
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(th);
    		}
    	};
    }

    // (18:4) {#each columns as col, i}
    function create_each_block$d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*col*/ ctx[7].disableSort) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    function create_fragment$I(ctx) {
    	let thead;
    	let tr;
    	let current;
    	let each_value = /*columns*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			thead = element("thead");
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(tr, "class", "svelte-whzxrs");
    		},
    		m(target, anchor) {
    			insert(target, thead, anchor);
    			append(thead, tr);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*columns, mouseOverColHeader, dispatch, indicateSort, faSortDown, faSortUp, faSort*/ 15) {
    				each_value = /*columns*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tr, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(thead);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function instance$H($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();
    	let { columns = [] } = $$props;
    	let { indicateSort = [] } = $$props;
    	let mouseOverColHeader = {};
    	const mouseout_handler = () => $$invalidate(2, mouseOverColHeader = {});

    	const mouseover_handler = col => {
    		$$invalidate(2, mouseOverColHeader = {});
    		$$invalidate(2, mouseOverColHeader[col.key] = true, mouseOverColHeader);
    	};

    	const click_handler = col => dispatch("colHeaderClicked", col);

    	$$self.$$set = $$props => {
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('indicateSort' in $$props) $$invalidate(1, indicateSort = $$props.indicateSort);
    	};

    	return [
    		columns,
    		indicateSort,
    		mouseOverColHeader,
    		dispatch,
    		mouseout_handler,
    		mouseover_handler,
    		click_handler
    	];
    }

    class Header extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$H, create_fragment$I, safe_not_equal, { columns: 0, indicateSort: 1 });
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function sineInOut(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }

    /* src/components/LoadingAnimation.svelte generated by Svelte v3.42.4 */

    function create_if_block_1$5(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "fullscreenoverlay svelte-pq99q7");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (23:2) {#if text}
    function create_if_block$a(ctx) {
    	let h1;
    	let t;

    	return {
    		c() {
    			h1 = element("h1");
    			t = text(/*text*/ ctx[0]);
    			attr(h1, "class", "svelte-pq99q7");
    		},
    		m(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);
    		},
    		d(detaching) {
    			if (detaching) detach(h1);
    		}
    	};
    }

    function create_fragment$H(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let pulse;
    	let div_resize_listener;
    	let div_intro;
    	let current;
    	let if_block0 = /*fullScreenOverlay*/ ctx[1] && create_if_block_1$5();
    	let if_block1 = /*text*/ ctx[0] && create_if_block$a(ctx);

    	pulse = new Pulse({
    			props: {
    				size: "120",
    				color: /*color*/ ctx[3],
    				unit: "px"
    			}
    		});

    	return {
    		c() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(pulse.$$.fragment);
    			attr(div, "class", "container svelte-pq99q7");
    			set_style(div, "--container-height", /*containerHeight*/ ctx[4] + "px");
    			set_style(div, "--color", /*color*/ ctx[3]);
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[5].call(div));
    			toggle_class(div, "positionFixed", /*positionFixed*/ ctx[2]);
    		},
    		m(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t0, anchor);
    			insert(target, div, anchor);
    			if (if_block1) if_block1.m(div, null);
    			append(div, t1);
    			mount_component(pulse, div, null);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[5].bind(div));
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (/*fullScreenOverlay*/ ctx[1]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$5();
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*text*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$a(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const pulse_changes = {};
    			if (dirty & /*color*/ 8) pulse_changes.color = /*color*/ ctx[3];
    			pulse.$set(pulse_changes);

    			if (!current || dirty & /*containerHeight*/ 16) {
    				set_style(div, "--container-height", /*containerHeight*/ ctx[4] + "px");
    			}

    			if (!current || dirty & /*color*/ 8) {
    				set_style(div, "--color", /*color*/ ctx[3]);
    			}

    			if (dirty & /*positionFixed*/ 4) {
    				toggle_class(div, "positionFixed", /*positionFixed*/ ctx[2]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(pulse.$$.fragment, local);

    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 800 });
    					div_intro.start();
    				});
    			}

    			current = true;
    		},
    		o(local) {
    			transition_out(pulse.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach(t0);
    			if (detaching) detach(div);
    			if (if_block1) if_block1.d();
    			destroy_component(pulse);
    			div_resize_listener();
    		}
    	};
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { text } = $$props;
    	let { fullScreenOverlay = false } = $$props;
    	let { positionFixed = true } = $$props;
    	let { color = "#fc03a9" } = $$props;
    	let containerHeight;

    	function div_elementresize_handler() {
    		containerHeight = this.clientHeight;
    		$$invalidate(4, containerHeight);
    	}

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('fullScreenOverlay' in $$props) $$invalidate(1, fullScreenOverlay = $$props.fullScreenOverlay);
    		if ('positionFixed' in $$props) $$invalidate(2, positionFixed = $$props.positionFixed);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    	};

    	return [
    		text,
    		fullScreenOverlay,
    		positionFixed,
    		color,
    		containerHeight,
    		div_elementresize_handler
    	];
    }

    class LoadingAnimation extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$G, create_fragment$H, safe_not_equal, {
    			text: 0,
    			fullScreenOverlay: 1,
    			positionFixed: 2,
    			color: 3
    		});
    	}
    }

    /* src/components/Table/Table.svelte generated by Svelte v3.42.4 */

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (34:4) {:catch error}
    function create_catch_block$1(ctx) {
    	let p;
    	let raw_value = /*onLoadDataErrorText*/ ctx[5](/*error*/ ctx[13]) + "";

    	return {
    		c() {
    			p = element("p");
    			attr(p, "class", "error svelte-1cbtbnv");
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    			p.innerHTML = raw_value;
    		},
    		p(ctx, dirty) {
    			if (dirty & /*onLoadDataErrorText, loadData*/ 40 && raw_value !== (raw_value = /*onLoadDataErrorText*/ ctx[5](/*error*/ ctx[13]) + "")) p.innerHTML = raw_value;		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (21:4) {:then data}
    function create_then_block$1(ctx) {
    	let tbody;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let tbody_intro;
    	let current;
    	let each_value = /*data*/ ctx[9];
    	const get_key = ctx => /*row*/ ctx[10]._id;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	return {
    		c() {
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    		},
    		m(target, anchor) {
    			insert(target, tbody, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (dirty & /*cellBackgroundColorsFunction, columns, loadData, rowHeight, dispatch*/ 79) {
    				each_value = /*data*/ ctx[9];
    				group_outros();
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$c, null, get_each_context$c);
    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			if (!tbody_intro) {
    				add_render_callback(() => {
    					tbody_intro = create_in_transition(tbody, fade, {});
    					tbody_intro.start();
    				});
    			}

    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};
    }

    // (23:8) {#each data as row, i (row._id)}
    function create_each_block$c(key_1, ctx) {
    	let first;
    	let row;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*row*/ ctx[10]);
    	}

    	row = new Row({
    			props: {
    				cellBackgroundColorsFunction: /*cellBackgroundColorsFunction*/ ctx[2],
    				columns: /*columns*/ ctx[0],
    				item: /*row*/ ctx[10],
    				rowHeight: /*rowHeight*/ ctx[1],
    				evenRowNumber: /*i*/ ctx[12] % 2 == 0
    			}
    		});

    	row.$on("click", click_handler);

    	return {
    		key: key_1,
    		first: null,
    		c() {
    			first = empty();
    			create_component(row.$$.fragment);
    			this.first = first;
    		},
    		m(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const row_changes = {};
    			if (dirty & /*cellBackgroundColorsFunction*/ 4) row_changes.cellBackgroundColorsFunction = /*cellBackgroundColorsFunction*/ ctx[2];
    			if (dirty & /*columns*/ 1) row_changes.columns = /*columns*/ ctx[0];
    			if (dirty & /*loadData*/ 8) row_changes.item = /*row*/ ctx[10];
    			if (dirty & /*rowHeight*/ 2) row_changes.rowHeight = /*rowHeight*/ ctx[1];
    			if (dirty & /*loadData*/ 8) row_changes.evenRowNumber = /*i*/ ctx[12] % 2 == 0;
    			row.$set(row_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(first);
    			destroy_component(row, detaching);
    		}
    	};
    }

    // (19:21)        <LoadingAnimation />     {:then data}
    function create_pending_block$1(ctx) {
    	let loadinganimation;
    	let current;
    	loadinganimation = new LoadingAnimation({});

    	return {
    		c() {
    			create_component(loadinganimation.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(loadinganimation, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(loadinganimation.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(loadinganimation.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(loadinganimation, detaching);
    		}
    	};
    }

    function create_fragment$G(ctx) {
    	let div;
    	let table;
    	let header;
    	let t;
    	let promise;
    	let current;

    	header = new Header({
    			props: {
    				columns: /*columns*/ ctx[0],
    				indicateSort: /*indicateSort*/ ctx[4]
    			}
    		});

    	header.$on("colHeaderClicked", /*colHeaderClicked_handler*/ ctx[7]);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 9,
    		error: 13,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*loadData*/ ctx[3], info);

    	return {
    		c() {
    			div = element("div");
    			table = element("table");
    			create_component(header.$$.fragment);
    			t = space();
    			info.block.c();
    			attr(table, "class", "svelte-1cbtbnv");
    			attr(div, "class", "tablecontainer svelte-1cbtbnv");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, table);
    			mount_component(header, table, null);
    			append(table, t);
    			info.block.m(table, info.anchor = null);
    			info.mount = () => table;
    			info.anchor = null;
    			current = true;
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const header_changes = {};
    			if (dirty & /*columns*/ 1) header_changes.columns = /*columns*/ ctx[0];
    			if (dirty & /*indicateSort*/ 16) header_changes.indicateSort = /*indicateSort*/ ctx[4];
    			header.$set(header_changes);
    			info.ctx = ctx;

    			if (dirty & /*loadData*/ 8 && promise !== (promise = /*loadData*/ ctx[3]) && handle_promise(promise, info)) ; else {
    				update_await_block_branch(info, ctx, dirty);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(info.block);
    			current = true;
    		},
    		o(local) {
    			transition_out(header.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(header);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { columns = [] } = $$props;
    	let { rowHeight = 40 } = $$props;
    	let { cellBackgroundColorsFunction } = $$props;
    	let { loadData } = $$props;
    	let { indicateSort = {} } = $$props;
    	let { onLoadDataErrorText = () => "Fehler" } = $$props;
    	const dispatch = createEventDispatcher();

    	function colHeaderClicked_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = row => dispatch("rowClicked", row);

    	$$self.$$set = $$props => {
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('rowHeight' in $$props) $$invalidate(1, rowHeight = $$props.rowHeight);
    		if ('cellBackgroundColorsFunction' in $$props) $$invalidate(2, cellBackgroundColorsFunction = $$props.cellBackgroundColorsFunction);
    		if ('loadData' in $$props) $$invalidate(3, loadData = $$props.loadData);
    		if ('indicateSort' in $$props) $$invalidate(4, indicateSort = $$props.indicateSort);
    		if ('onLoadDataErrorText' in $$props) $$invalidate(5, onLoadDataErrorText = $$props.onLoadDataErrorText);
    	};

    	return [
    		columns,
    		rowHeight,
    		cellBackgroundColorsFunction,
    		loadData,
    		indicateSort,
    		onLoadDataErrorText,
    		dispatch,
    		colHeaderClicked_handler,
    		click_handler
    	];
    }

    class Table extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$F, create_fragment$G, safe_not_equal, {
    			columns: 0,
    			rowHeight: 1,
    			cellBackgroundColorsFunction: 2,
    			loadData: 3,
    			indicateSort: 4,
    			onLoadDataErrorText: 5
    		});
    	}
    }

    /* node_modules/svelte-simple-modal/src/Modal.svelte generated by Svelte v3.42.4 */

    const { window: window_1$2 } = globals;

    function create_if_block$9(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let t;
    	let div0;
    	let switch_instance;
    	let div0_class_value;
    	let div1_class_value;
    	let div1_aria_label_value;
    	let div1_aria_labelledby_value;
    	let div1_transition;
    	let div2_class_value;
    	let div3_class_value;
    	let div3_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*state*/ ctx[1].closeButton && create_if_block_1$4(ctx);
    	var switch_value = /*Component*/ ctx[2];

    	function switch_props(ctx) {
    		return {};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	return {
    		c() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div0, "class", div0_class_value = "" + (null_to_empty(/*state*/ ctx[1].classContent) + " svelte-g4wg3a"));
    			attr(div0, "style", /*cssContent*/ ctx[9]);
    			toggle_class(div0, "content", !/*unstyled*/ ctx[0]);
    			attr(div1, "class", div1_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindow) + " svelte-g4wg3a"));
    			attr(div1, "role", "dialog");
    			attr(div1, "aria-modal", "true");

    			attr(div1, "aria-label", div1_aria_label_value = /*state*/ ctx[1].ariaLabelledBy
    			? null
    			: /*state*/ ctx[1].ariaLabel || null);

    			attr(div1, "aria-labelledby", div1_aria_labelledby_value = /*state*/ ctx[1].ariaLabelledBy || null);
    			attr(div1, "style", /*cssWindow*/ ctx[8]);
    			toggle_class(div1, "window", !/*unstyled*/ ctx[0]);
    			attr(div2, "class", div2_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindowWrap) + " svelte-g4wg3a"));
    			attr(div2, "style", /*cssWindowWrap*/ ctx[7]);
    			toggle_class(div2, "wrap", !/*unstyled*/ ctx[0]);
    			attr(div3, "class", div3_class_value = "" + (null_to_empty(/*state*/ ctx[1].classBg) + " svelte-g4wg3a"));
    			attr(div3, "style", /*cssBg*/ ctx[6]);
    			toggle_class(div3, "bg", !/*unstyled*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			append(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			append(div1, t);
    			append(div1, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			/*div1_binding*/ ctx[48](div1);
    			/*div2_binding*/ ctx[49](div2);
    			/*div3_binding*/ ctx[50](div3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div1, "introstart", function () {
    						if (is_function(/*onOpen*/ ctx[13])) /*onOpen*/ ctx[13].apply(this, arguments);
    					}),
    					listen(div1, "outrostart", function () {
    						if (is_function(/*onClose*/ ctx[14])) /*onClose*/ ctx[14].apply(this, arguments);
    					}),
    					listen(div1, "introend", function () {
    						if (is_function(/*onOpened*/ ctx[15])) /*onOpened*/ ctx[15].apply(this, arguments);
    					}),
    					listen(div1, "outroend", function () {
    						if (is_function(/*onClosed*/ ctx[16])) /*onClosed*/ ctx[16].apply(this, arguments);
    					}),
    					listen(div3, "mousedown", /*handleOuterMousedown*/ ctx[20]),
    					listen(div3, "mouseup", /*handleOuterMouseup*/ ctx[21])
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*state*/ ctx[1].closeButton) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*state*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (switch_value !== (switch_value = /*Component*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*state*/ ctx[1].classContent) + " svelte-g4wg3a"))) {
    				attr(div0, "class", div0_class_value);
    			}

    			if (!current || dirty[0] & /*cssContent*/ 512) {
    				attr(div0, "style", /*cssContent*/ ctx[9]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div0, "content", !/*unstyled*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindow) + " svelte-g4wg3a"))) {
    				attr(div1, "class", div1_class_value);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div1_aria_label_value !== (div1_aria_label_value = /*state*/ ctx[1].ariaLabelledBy
    			? null
    			: /*state*/ ctx[1].ariaLabel || null)) {
    				attr(div1, "aria-label", div1_aria_label_value);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = /*state*/ ctx[1].ariaLabelledBy || null)) {
    				attr(div1, "aria-labelledby", div1_aria_labelledby_value);
    			}

    			if (!current || dirty[0] & /*cssWindow*/ 256) {
    				attr(div1, "style", /*cssWindow*/ ctx[8]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div1, "window", !/*unstyled*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindowWrap) + " svelte-g4wg3a"))) {
    				attr(div2, "class", div2_class_value);
    			}

    			if (!current || dirty[0] & /*cssWindowWrap*/ 128) {
    				attr(div2, "style", /*cssWindowWrap*/ ctx[7]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div2, "wrap", !/*unstyled*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div3_class_value !== (div3_class_value = "" + (null_to_empty(/*state*/ ctx[1].classBg) + " svelte-g4wg3a"))) {
    				attr(div3, "class", div3_class_value);
    			}

    			if (!current || dirty[0] & /*cssBg*/ 64) {
    				attr(div3, "style", /*cssBg*/ ctx[6]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div3, "bg", !/*unstyled*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[12], /*state*/ ctx[1].transitionWindowProps, true);
    				div1_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[11], /*state*/ ctx[1].transitionBgProps, true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[12], /*state*/ ctx[1].transitionWindowProps, false);
    			div1_transition.run(0);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[11], /*state*/ ctx[1].transitionBgProps, false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div3);
    			if (if_block) if_block.d();
    			if (switch_instance) destroy_component(switch_instance);
    			/*div1_binding*/ ctx[48](null);
    			if (detaching && div1_transition) div1_transition.end();
    			/*div2_binding*/ ctx[49](null);
    			/*div3_binding*/ ctx[50](null);
    			if (detaching && div3_transition) div3_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (433:8) {#if state.closeButton}
    function create_if_block_1$4(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*state*/ 2) show_if = !!/*isFunction*/ ctx[17](/*state*/ ctx[1].closeButton);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (436:10) {:else}
    function create_else_block$6(ctx) {
    	let button;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			attr(button, "class", button_class_value = "" + (null_to_empty(/*state*/ ctx[1].classCloseButton) + " svelte-g4wg3a"));
    			attr(button, "aria-label", "Close modal");
    			attr(button, "style", /*cssCloseButton*/ ctx[10]);
    			toggle_class(button, "close", !/*unstyled*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*close*/ ctx[18]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*state*/ 2 && button_class_value !== (button_class_value = "" + (null_to_empty(/*state*/ ctx[1].classCloseButton) + " svelte-g4wg3a"))) {
    				attr(button, "class", button_class_value);
    			}

    			if (dirty[0] & /*cssCloseButton*/ 1024) {
    				attr(button, "style", /*cssCloseButton*/ ctx[10]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(button, "close", !/*unstyled*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (434:10) {#if isFunction(state.closeButton)}
    function create_if_block_2$2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*state*/ ctx[1].closeButton;

    	function switch_props(ctx) {
    		return { props: { onClose: /*close*/ ctx[18] } };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (switch_value !== (switch_value = /*state*/ ctx[1].closeButton)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    function create_fragment$F(ctx) {
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*Component*/ ctx[2] && create_if_block$9(ctx);
    	const default_slot_template = /*#slots*/ ctx[47].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[46], null);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen(window_1$2, "keydown", /*handleKeydown*/ ctx[19]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (/*Component*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*Component*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[46],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[46], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(t);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function bind(Component, props = {}) {
    	return function ModalComponent(options) {
    		return new Component({
    				...options,
    				props: { ...props, ...options.props }
    			});
    	};
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	const dispatch = createEventDispatcher();
    	const baseSetContext = setContext;
    	let { show = null } = $$props;
    	let { key = 'simple-modal' } = $$props;
    	let { ariaLabel = null } = $$props;
    	let { ariaLabelledBy = null } = $$props;
    	let { closeButton = true } = $$props;
    	let { closeOnEsc = true } = $$props;
    	let { closeOnOuterClick = true } = $$props;
    	let { styleBg = {} } = $$props;
    	let { styleWindowWrap = {} } = $$props;
    	let { styleWindow = {} } = $$props;
    	let { styleContent = {} } = $$props;
    	let { styleCloseButton = {} } = $$props;
    	let { classBg = null } = $$props;
    	let { classWindowWrap = null } = $$props;
    	let { classWindow = null } = $$props;
    	let { classContent = null } = $$props;
    	let { classCloseButton = null } = $$props;
    	let { unstyled = false } = $$props;
    	let { setContext: setContext$1 = baseSetContext } = $$props;
    	let { transitionBg = fade } = $$props;
    	let { transitionBgProps = { duration: 250 } } = $$props;
    	let { transitionWindow = transitionBg } = $$props;
    	let { transitionWindowProps = transitionBgProps } = $$props;
    	let { disableFocusTrap = false } = $$props;

    	const defaultState = {
    		ariaLabel,
    		ariaLabelledBy,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		classBg,
    		classWindowWrap,
    		classWindow,
    		classContent,
    		classCloseButton,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		disableFocusTrap,
    		unstyled
    	};

    	let state = { ...defaultState };
    	let Component = null;
    	let background;
    	let wrap;
    	let modalWindow;
    	let scrollY;
    	let cssBg;
    	let cssWindowWrap;
    	let cssWindow;
    	let cssContent;
    	let cssCloseButton;
    	let currentTransitionBg;
    	let currentTransitionWindow;
    	let prevBodyPosition;
    	let prevBodyOverflow;
    	let prevBodyWidth;
    	let outerClickTarget;
    	const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();

    	const toCssString = props => props
    	? Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, '')
    	: '';

    	const isFunction = f => !!(f && f.constructor && f.call && f.apply);

    	const updateStyleTransition = () => {
    		$$invalidate(6, cssBg = toCssString(Object.assign(
    			{},
    			{
    				width: window.innerWidth,
    				height: window.innerHeight
    			},
    			state.styleBg
    		)));

    		$$invalidate(7, cssWindowWrap = toCssString(state.styleWindowWrap));
    		$$invalidate(8, cssWindow = toCssString(state.styleWindow));
    		$$invalidate(9, cssContent = toCssString(state.styleContent));
    		$$invalidate(10, cssCloseButton = toCssString(state.styleCloseButton));
    		$$invalidate(11, currentTransitionBg = state.transitionBg);
    		$$invalidate(12, currentTransitionWindow = state.transitionWindow);
    	};

    	const toVoid = () => {
    		
    	};

    	let onOpen = toVoid;
    	let onClose = toVoid;
    	let onOpened = toVoid;
    	let onClosed = toVoid;

    	const open = (NewComponent, newProps = {}, options = {}, callback = {}) => {
    		$$invalidate(2, Component = bind(NewComponent, newProps));
    		$$invalidate(1, state = { ...defaultState, ...options });
    		updateStyleTransition();
    		disableScroll();

    		$$invalidate(13, onOpen = event => {
    			if (callback.onOpen) callback.onOpen(event);

    			/**
     * The open event is fired right before the modal opens
     * @event {void} open
     */
    			dispatch('open');

    			/**
     * The opening event is fired right before the modal opens
     * @event {void} opening
     * @deprecated Listen to the `open` event instead
     */
    			dispatch('opening'); // Deprecated. Do not use!
    		});

    		$$invalidate(14, onClose = event => {
    			if (callback.onClose) callback.onClose(event);

    			/**
     * The close event is fired right before the modal closes
     * @event {void} close
     */
    			dispatch('close');

    			/**
     * The closing event is fired right before the modal closes
     * @event {void} closing
     * @deprecated Listen to the `close` event instead
     */
    			dispatch('closing'); // Deprecated. Do not use!
    		});

    		$$invalidate(15, onOpened = event => {
    			if (callback.onOpened) callback.onOpened(event);

    			/**
     * The opened event is fired after the modal's opening transition
     * @event {void} opened
     */
    			dispatch('opened');
    		});

    		$$invalidate(16, onClosed = event => {
    			if (callback.onClosed) callback.onClosed(event);

    			/**
     * The closed event is fired after the modal's closing transition
     * @event {void} closed
     */
    			dispatch('closed');
    		});
    	};

    	const close = (callback = {}) => {
    		if (!Component) return;
    		$$invalidate(14, onClose = callback.onClose || onClose);
    		$$invalidate(16, onClosed = callback.onClosed || onClosed);
    		$$invalidate(2, Component = null);
    		enableScroll();
    	};

    	const handleKeydown = event => {
    		if (state.closeOnEsc && Component && event.key === 'Escape') {
    			event.preventDefault();
    			close();
    		}

    		if (Component && event.key === 'Tab' && !state.disableFocusTrap) {
    			// trap focus
    			const nodes = modalWindow.querySelectorAll('*');

    			const tabbable = Array.from(nodes).filter(node => node.tabIndex >= 0).sort((a, b) => a.tabIndex - b.tabIndex);
    			let index = tabbable.indexOf(document.activeElement);
    			if (index === -1 && event.shiftKey) index = 0;
    			index += tabbable.length + (event.shiftKey ? -1 : 1);
    			index %= tabbable.length;
    			tabbable[index].focus();
    			event.preventDefault();
    		}
    	};

    	const handleOuterMousedown = event => {
    		if (state.closeOnOuterClick && (event.target === background || event.target === wrap)) outerClickTarget = event.target;
    	};

    	const handleOuterMouseup = event => {
    		if (state.closeOnOuterClick && event.target === outerClickTarget) {
    			event.preventDefault();
    			close();
    		}
    	};

    	const disableScroll = () => {
    		scrollY = window.scrollY;
    		prevBodyPosition = document.body.style.position;
    		prevBodyOverflow = document.body.style.overflow;
    		prevBodyWidth = document.body.style.width;
    		document.body.style.position = 'fixed';
    		document.body.style.top = `-${scrollY}px`;
    		document.body.style.overflow = 'hidden';
    		document.body.style.width = '100%';
    	};

    	const enableScroll = () => {
    		document.body.style.position = prevBodyPosition || '';
    		document.body.style.top = '';
    		document.body.style.overflow = prevBodyOverflow || '';
    		document.body.style.width = prevBodyWidth || '';
    		window.scrollTo(0, scrollY);
    	};

    	setContext$1(key, { open, close });
    	let isMounted = false;

    	onDestroy(() => {
    		if (isMounted) close();
    	});

    	onMount(() => {
    		$$invalidate(45, isMounted = true);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			modalWindow = $$value;
    			$$invalidate(5, modalWindow);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrap = $$value;
    			$$invalidate(4, wrap);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			background = $$value;
    			$$invalidate(3, background);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('show' in $$props) $$invalidate(22, show = $$props.show);
    		if ('key' in $$props) $$invalidate(23, key = $$props.key);
    		if ('ariaLabel' in $$props) $$invalidate(24, ariaLabel = $$props.ariaLabel);
    		if ('ariaLabelledBy' in $$props) $$invalidate(25, ariaLabelledBy = $$props.ariaLabelledBy);
    		if ('closeButton' in $$props) $$invalidate(26, closeButton = $$props.closeButton);
    		if ('closeOnEsc' in $$props) $$invalidate(27, closeOnEsc = $$props.closeOnEsc);
    		if ('closeOnOuterClick' in $$props) $$invalidate(28, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ('styleBg' in $$props) $$invalidate(29, styleBg = $$props.styleBg);
    		if ('styleWindowWrap' in $$props) $$invalidate(30, styleWindowWrap = $$props.styleWindowWrap);
    		if ('styleWindow' in $$props) $$invalidate(31, styleWindow = $$props.styleWindow);
    		if ('styleContent' in $$props) $$invalidate(32, styleContent = $$props.styleContent);
    		if ('styleCloseButton' in $$props) $$invalidate(33, styleCloseButton = $$props.styleCloseButton);
    		if ('classBg' in $$props) $$invalidate(34, classBg = $$props.classBg);
    		if ('classWindowWrap' in $$props) $$invalidate(35, classWindowWrap = $$props.classWindowWrap);
    		if ('classWindow' in $$props) $$invalidate(36, classWindow = $$props.classWindow);
    		if ('classContent' in $$props) $$invalidate(37, classContent = $$props.classContent);
    		if ('classCloseButton' in $$props) $$invalidate(38, classCloseButton = $$props.classCloseButton);
    		if ('unstyled' in $$props) $$invalidate(0, unstyled = $$props.unstyled);
    		if ('setContext' in $$props) $$invalidate(39, setContext$1 = $$props.setContext);
    		if ('transitionBg' in $$props) $$invalidate(40, transitionBg = $$props.transitionBg);
    		if ('transitionBgProps' in $$props) $$invalidate(41, transitionBgProps = $$props.transitionBgProps);
    		if ('transitionWindow' in $$props) $$invalidate(42, transitionWindow = $$props.transitionWindow);
    		if ('transitionWindowProps' in $$props) $$invalidate(43, transitionWindowProps = $$props.transitionWindowProps);
    		if ('disableFocusTrap' in $$props) $$invalidate(44, disableFocusTrap = $$props.disableFocusTrap);
    		if ('$$scope' in $$props) $$invalidate(46, $$scope = $$props.$$scope);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*show*/ 4194304 | $$self.$$.dirty[1] & /*isMounted*/ 16384) {
    			{
    				if (isMounted) {
    					if (isFunction(show)) {
    						open(show);
    					} else {
    						close();
    					}
    				}
    			}
    		}
    	};

    	return [
    		unstyled,
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		isFunction,
    		close,
    		handleKeydown,
    		handleOuterMousedown,
    		handleOuterMouseup,
    		show,
    		key,
    		ariaLabel,
    		ariaLabelledBy,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		classBg,
    		classWindowWrap,
    		classWindow,
    		classContent,
    		classCloseButton,
    		setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		disableFocusTrap,
    		isMounted,
    		$$scope,
    		slots,
    		div1_binding,
    		div2_binding,
    		div3_binding
    	];
    }

    class Modal extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$E,
    			create_fragment$F,
    			safe_not_equal,
    			{
    				show: 22,
    				key: 23,
    				ariaLabel: 24,
    				ariaLabelledBy: 25,
    				closeButton: 26,
    				closeOnEsc: 27,
    				closeOnOuterClick: 28,
    				styleBg: 29,
    				styleWindowWrap: 30,
    				styleWindow: 31,
    				styleContent: 32,
    				styleCloseButton: 33,
    				classBg: 34,
    				classWindowWrap: 35,
    				classWindow: 36,
    				classContent: 37,
    				classCloseButton: 38,
    				unstyled: 0,
    				setContext: 39,
    				transitionBg: 40,
    				transitionBgProps: 41,
    				transitionWindow: 42,
    				transitionWindowProps: 43,
    				disableFocusTrap: 44
    			},
    			null,
    			[-1, -1, -1]
    		);
    	}
    }

    /* src/components/Input/Button.svelte generated by Svelte v3.42.4 */

    function create_fragment$E(ctx) {
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			t = text(/*text*/ ctx[0]);
    			set_style(button, "--color", "var(--" + /*color*/ ctx[1] + ")");
    			attr(button, "class", "svelte-144mn5m");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);

    			if (dirty & /*color*/ 2) {
    				set_style(button, "--color", "var(--" + /*color*/ ctx[1] + ")");
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { text } = $$props;
    	let { color = "blue" } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    	};

    	return [text, color, click_handler];
    }

    class Button extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$D, create_fragment$E, safe_not_equal, { text: 0, color: 1 });
    	}
    }

    /* src/components/TableView/PopupFormular/Footer.svelte generated by Svelte v3.42.4 */

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[4] = list;
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (10:0) {#if loadingText}
    function create_if_block$8(ctx) {
    	let loadinganimation;
    	let current;

    	loadinganimation = new LoadingAnimation({
    			props: {
    				text: /*loadingText*/ ctx[1],
    				color: "white",
    				fullScreenOverlay: true
    			}
    		});

    	return {
    		c() {
    			create_component(loadinganimation.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(loadinganimation, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const loadinganimation_changes = {};
    			if (dirty & /*loadingText*/ 2) loadinganimation_changes.text = /*loadingText*/ ctx[1];
    			loadinganimation.$set(loadinganimation_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(loadinganimation.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(loadinganimation.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(loadinganimation, detaching);
    		}
    	};
    }

    // (14:2) {#each buttons.filter((button) => !button.hidden) as button}
    function create_each_block$b(ctx) {
    	let button;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[2](/*button*/ ctx[3], /*each_value*/ ctx[4], /*button_index*/ ctx[5], ...args);
    	}

    	button = new Button({
    			props: {
    				type: "button",
    				disabled: /*button*/ ctx[3].disabled ?? false,
    				text: /*button*/ ctx[3].text,
    				color: /*button*/ ctx[3].color ?? "blue"
    			}
    		});

    	button.$on("click", click_handler);

    	return {
    		c() {
    			create_component(button.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};
    			if (dirty & /*buttons*/ 1) button_changes.disabled = /*button*/ ctx[3].disabled ?? false;
    			if (dirty & /*buttons*/ 1) button_changes.text = /*button*/ ctx[3].text;
    			if (dirty & /*buttons*/ 1) button_changes.color = /*button*/ ctx[3].color ?? "blue";
    			button.$set(button_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(button, detaching);
    		}
    	};
    }

    function create_fragment$D(ctx) {
    	let t;
    	let div;
    	let current;
    	let if_block = /*loadingText*/ ctx[1] && create_if_block$8(ctx);
    	let each_value = /*buttons*/ ctx[0].filter(func$2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div, "class", "footer svelte-iinr0q");
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t, anchor);
    			insert(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (/*loadingText*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*loadingText*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*buttons, loadingText*/ 3) {
    				each_value = /*buttons*/ ctx[0].filter(func$2);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(t);
    			if (detaching) detach(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    const func$2 = button => !button.hidden;

    function instance$C($$self, $$props, $$invalidate) {
    	let { buttons = [] } = $$props;
    	let loadingText;

    	const click_handler = async (button, each_value, button_index, event) => {
    		$$invalidate(0, each_value[button_index].disabled = true, buttons);
    		$$invalidate(1, loadingText = button.loadingText);
    		await button.onClick();
    		$$invalidate(1, loadingText = false);
    		$$invalidate(0, each_value[button_index].disabled = false, buttons);
    	};

    	$$self.$$set = $$props => {
    		if ('buttons' in $$props) $$invalidate(0, buttons = $$props.buttons);
    	};

    	return [buttons, loadingText, click_handler];
    }

    class Footer extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$C, create_fragment$D, safe_not_equal, { buttons: 0 });
    	}
    }

    /* src/components/TableView/PopupFormular/InputGroup.svelte generated by Svelte v3.42.4 */

    function create_fragment$C(ctx) {
    	let div1;
    	let div0;
    	let h3;
    	let t0;
    	let t1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			h3 = element("h3");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			attr(h3, "class", "svelte-rb892u");
    			attr(div0, "class", "group svelte-rb892u");
    			attr(div1, "class", "outerbox svelte-rb892u");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, h3);
    			append(h3, t0);
    			append(div0, t1);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { title = "" } = $$props;

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	return [title, $$scope, slots];
    }

    class InputGroup extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$B, create_fragment$C, safe_not_equal, { title: 0 });
    	}
    }

    /* src/components/TableView/PopupFormular/Formular.svelte generated by Svelte v3.42.4 */

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[24] = list;
    	child_ctx[25] = i;
    	return child_ctx;
    }

    // (92:16) {#if input.label && input.label.length > 0}
    function create_if_block_1$3(ctx) {
    	let div;
    	let label;
    	let t_value = /*input*/ ctx[23].label + "";
    	let t;
    	let label_for_value;

    	return {
    		c() {
    			div = element("div");
    			label = element("label");
    			t = text(t_value);
    			attr(label, "for", label_for_value = /*input*/ ctx[23].id);
    			attr(label, "class", "svelte-cqmlvo");
    			attr(div, "class", "col-label svelte-cqmlvo");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, label);
    			append(label, t);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*groupedInputs, groups*/ 20 && t_value !== (t_value = /*input*/ ctx[23].label + "")) set_data(t, t_value);

    			if (dirty & /*groupedInputs, groups*/ 20 && label_for_value !== (label_for_value = /*input*/ ctx[23].id)) {
    				attr(label, "for", label_for_value);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    // (106:18) {:else}
    function create_else_block$5(ctx) {
    	let switch_instance;
    	let updating_value;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*input*/ ctx[23].props, { id: /*input*/ ctx[23].id }];

    	function switch_instance_value_binding(value) {
    		/*switch_instance_value_binding*/ ctx[14](value, /*input*/ ctx[23]);
    	}

    	var switch_value = /*input*/ ctx[23].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		if (/*doc*/ ctx[0][/*input*/ ctx[23].id] !== void 0) {
    			switch_instance_props.value = /*doc*/ ctx[0][/*input*/ ctx[23].id];
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind$1(switch_instance, 'value', switch_instance_value_binding));
    		switch_instance.$on("change", /*change_handler_1*/ ctx[15]);
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;

    			const switch_instance_changes = (dirty & /*groupedInputs, groups, isHidden*/ 148)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*input*/ ctx[23].props), { id: /*input*/ ctx[23].id }])
    			: {};

    			if (!updating_value && dirty & /*doc, groupedInputs, groups, isHidden*/ 149) {
    				updating_value = true;
    				switch_instance_changes.value = /*doc*/ ctx[0][/*input*/ ctx[23].id];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (switch_value !== (switch_value = /*input*/ ctx[23].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind$1(switch_instance, 'value', switch_instance_value_binding));
    					switch_instance.$on("change", /*change_handler_1*/ ctx[15]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (98:18) {#if input.nobind}
    function create_if_block$7(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			value: /*doc*/ ctx[0][/*input*/ ctx[23].id]
    		},
    		/*input*/ ctx[23].props,
    		{ id: /*input*/ ctx[23].id }
    	];

    	var switch_value = /*input*/ ctx[23].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return { props: switch_instance_props };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("change", /*change_handler*/ ctx[13]);
    	}

    	return {
    		c() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*doc, groupedInputs, groups, isHidden*/ 149)
    			? get_spread_update(switch_instance_spread_levels, [
    					{
    						value: /*doc*/ ctx[0][/*input*/ ctx[23].id]
    					},
    					dirty & /*groupedInputs, groups, isHidden*/ 148 && get_spread_object(/*input*/ ctx[23].props),
    					dirty & /*groupedInputs, groups, isHidden*/ 148 && { id: /*input*/ ctx[23].id }
    				])
    			: {};

    			if (switch_value !== (switch_value = /*input*/ ctx[23].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("change", /*change_handler*/ ctx[13]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    // (90:12) {#each groupedInputs[group].filter((input) => !isHidden(input)) as input}
    function create_each_block_1$2(ctx) {
    	let row;
    	let t;
    	let div;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let if_block0 = /*input*/ ctx[23].label && /*input*/ ctx[23].label.length > 0 && create_if_block_1$3(ctx);
    	const if_block_creators = [create_if_block$7, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*input*/ ctx[23].nobind) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			row = element("row");
    			if (if_block0) if_block0.c();
    			t = space();
    			div = element("div");
    			if_block1.c();
    			attr(div, "class", "col-input svelte-cqmlvo");
    			attr(row, "class", "svelte-cqmlvo");
    		},
    		m(target, anchor) {
    			insert(target, row, anchor);
    			if (if_block0) if_block0.m(row, null);
    			append(row, t);
    			append(row, div);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (/*input*/ ctx[23].label && /*input*/ ctx[23].label.length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(row, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div, null);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(row);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    		}
    	};
    }

    // (89:10) <InputGroup title={group}>
    function create_default_slot$1(ctx) {
    	let t;
    	let current;
    	let each_value_1 = /*groupedInputs*/ ctx[2][/*group*/ ctx[20]].filter(/*func_1*/ ctx[12]);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, t, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (dirty & /*groupedInputs, groups, isHidden, doc, formRef*/ 151) {
    				each_value_1 = /*groupedInputs*/ ctx[2][/*group*/ ctx[20]].filter(/*func_1*/ ctx[12]);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(t);
    		}
    	};
    }

    // (88:8) {#each groups.filter( (group) => groupedInputs[group].some((input) => !isHidden(input)) ) as group}
    function create_each_block$a(ctx) {
    	let inputgroup;
    	let current;

    	inputgroup = new InputGroup({
    			props: {
    				title: /*group*/ ctx[20],
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			}
    		});

    	return {
    		c() {
    			create_component(inputgroup.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(inputgroup, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const inputgroup_changes = {};
    			if (dirty & /*groups, groupedInputs*/ 20) inputgroup_changes.title = /*group*/ ctx[20];

    			if (dirty & /*$$scope, groupedInputs, groups, doc, formRef*/ 67108887) {
    				inputgroup_changes.$$scope = { dirty, ctx };
    			}

    			inputgroup.$set(inputgroup_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(inputgroup.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(inputgroup.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(inputgroup, detaching);
    		}
    	};
    }

    function create_fragment$B(ctx) {
    	let div3;
    	let h1;
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let form;
    	let t2;
    	let div2;
    	let footer;
    	let current;
    	let each_value = /*groups*/ ctx[4].filter(/*func*/ ctx[11]);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	footer = new Footer({
    			props: {
    				buttons: /*footerButtonsWithContext*/ ctx[6]
    			}
    		});

    	return {
    		c() {
    			div3 = element("div");
    			h1 = element("h1");
    			t0 = text(/*title*/ ctx[3]);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			form = element("form");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			div2 = element("div");
    			create_component(footer.$$.fragment);
    			attr(h1, "class", "header svelte-cqmlvo");
    			attr(form, "autocomplete", "off");
    			attr(form, "onsubmit", "event.preventDefault()");
    			attr(div0, "class", "content svelte-cqmlvo");
    			attr(div1, "class", "contentContainer svelte-cqmlvo");
    			attr(div2, "class", "footer svelte-cqmlvo");
    			attr(div3, "class", "container svelte-cqmlvo");
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, h1);
    			append(h1, t0);
    			append(div3, t1);
    			append(div3, div1);
    			append(div1, div0);
    			append(div0, form);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(form, null);
    			}

    			/*form_binding*/ ctx[16](form);
    			/*div0_binding*/ ctx[17](div0);
    			append(div3, t2);
    			append(div3, div2);
    			mount_component(footer, div2, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 8) set_data(t0, /*title*/ ctx[3]);

    			if (dirty & /*groups, groupedInputs, isHidden, doc, formRef*/ 151) {
    				each_value = /*groups*/ ctx[4].filter(/*func*/ ctx[11]);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(form, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const footer_changes = {};
    			if (dirty & /*footerButtonsWithContext*/ 64) footer_changes.buttons = /*footerButtonsWithContext*/ ctx[6];
    			footer.$set(footer_changes);
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div3);
    			destroy_each(each_blocks, detaching);
    			/*form_binding*/ ctx[16](null);
    			/*div0_binding*/ ctx[17](null);
    			destroy_component(footer);
    		}
    	};
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { config = {} } = $$props;
    	let { doc = {} } = $$props;
    	let { createNew = false } = $$props;
    	let { closePopup } = $$props;
    	let groupedInputs = [];
    	let title = "";
    	let groups = [];
    	let inputContainer;
    	let footerButtonsWithContext;
    	let contextVars = {};
    	let formRef;

    	const injectContext = val => {
    		if (typeof val === "function") {
    			return val({
    				doc,
    				form: formRef,
    				createNew,
    				closePopup,
    				updateDoc: updatedDoc => $$invalidate(0, doc = { ...doc, ...updatedDoc }),
    				container: inputContainer,
    				contextVars
    			});
    		} else {
    			return val;
    		}
    	};

    	const isHidden = input => input.hidden && injectContext(input.hidden);

    	onMount(() => {
    		if (config.onMount) {
    			injectContext(config.onMount)();
    		}

    		$$invalidate(3, title = injectContext(config.title));

    		let inputs = config.inputs.map(input => ({
    			...input,
    			props: (() => {
    				let props = {};
    				Object.keys(input.props ?? []).forEach(propKey => props[propKey] = injectContext(input.props[propKey]));
    				return props;
    			})()
    		}));

    		$$invalidate(4, groups = [...new Set(inputs.map(input => input.group))]);
    		groups.forEach(group => $$invalidate(2, groupedInputs[group] = inputs.filter(input => input.group === group), groupedInputs));

    		if (createNew) {
    			// load initial values (e.g. first unused id when creating a new customer)
    			Object.keys(config.initialValues).forEach(async key => {
    				$$invalidate(0, doc[key] = await config.initialValues[key](), doc);
    			});
    		}
    	});

    	afterUpdate(() => {
    		let inputElements = inputContainer.querySelectorAll("input,textarea");

    		for (var i = 0; i < inputElements.length; i++) {
    			inputElements[i].setAttribute("tabindex", i + 1);
    		}
    	});

    	const func = group => groupedInputs[group].some(input => !isHidden(input));
    	const func_1 = input => !isHidden(input);
    	const change_handler = () => $$invalidate(1, formRef.wasChecked = false, formRef);

    	function switch_instance_value_binding(value, input) {
    		if ($$self.$$.not_equal(doc[input.id], value)) {
    			doc[input.id] = value;
    			$$invalidate(0, doc);
    		}
    	}

    	const change_handler_1 = () => $$invalidate(1, formRef.wasChecked = false, formRef);

    	function form_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			formRef = $$value;
    			$$invalidate(1, formRef);
    		});
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputContainer = $$value;
    			$$invalidate(5, inputContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('config' in $$props) $$invalidate(8, config = $$props.config);
    		if ('doc' in $$props) $$invalidate(0, doc = $$props.doc);
    		if ('createNew' in $$props) $$invalidate(9, createNew = $$props.createNew);
    		if ('closePopup' in $$props) $$invalidate(10, closePopup = $$props.closePopup);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*doc, config*/ 257) {
    			// needs to be reactive so that the injected context is updated when doc changes
    			($$invalidate(6, footerButtonsWithContext = injectContext(config.footerButtons)));
    		}

    		if ($$self.$$.dirty & /*formRef, config*/ 258) {
    			($$invalidate(6, footerButtonsWithContext = injectContext(config.footerButtons)));
    		}
    	};

    	return [
    		doc,
    		formRef,
    		groupedInputs,
    		title,
    		groups,
    		inputContainer,
    		footerButtonsWithContext,
    		isHidden,
    		config,
    		createNew,
    		closePopup,
    		func,
    		func_1,
    		change_handler,
    		switch_instance_value_binding,
    		change_handler_1,
    		form_binding,
    		div0_binding
    	];
    }

    class Formular extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$A, create_fragment$B, safe_not_equal, {
    			config: 8,
    			doc: 0,
    			createNew: 9,
    			closePopup: 10
    		});
    	}
    }

    /* src/components/TableView/PopupFormular/PopupFormular.svelte generated by Svelte v3.42.4 */

    function create_fragment$A(ctx) {
    	let modal_1;
    	let current;

    	modal_1 = new Modal({
    			props: {
    				show: /*$modal*/ ctx[1],
    				closeButton: false,
    				closeOnEsc: true,
    				closeOnOuterClick: false,
    				styleWindow: {
    					width: "55rem",
    					"max-width": "90%",
    					height: "100%",
    					overflow: "hidden",
    					"margin-top": 0,
    					"margin-bottom": 0
    				},
    				styleContent: {
    					height: "100%",
    					padding: 0,
    					overflow: "hidden",
    					margin: 0
    				}
    			}
    		});

    	modal_1.$on("close", function () {
    		if (is_function(/*onClose*/ ctx[0])) /*onClose*/ ctx[0].apply(this, arguments);
    	});

    	return {
    		c() {
    			create_component(modal_1.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(modal_1, target, anchor);
    			current = true;
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const modal_1_changes = {};
    			if (dirty & /*$modal*/ 2) modal_1_changes.show = /*$modal*/ ctx[1];
    			modal_1.$set(modal_1_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(modal_1.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(modal_1.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(modal_1, detaching);
    		}
    	};
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let $modal;
    	const modal = writable();
    	component_subscribe($$self, modal, value => $$invalidate(1, $modal = value));
    	let onClose;

    	function show(
    		props,
    	onCloseCallback = () => {
    			
    		}
    	) {
    		props["closePopup"] = () => modal.set(null);
    		$$invalidate(0, onClose = onCloseCallback);
    		modal.set(bind(Formular, props));
    	}

    	return [onClose, $modal, modal, show];
    }

    class PopupFormular extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$z, create_fragment$A, safe_not_equal, { show: 3 });
    	}

    	get show() {
    		return this.$$.ctx[3];
    	}
    }

    var logger = {exports: {}};

    /*!
     * js-logger - http://github.com/jonnyreeves/js-logger
     * Jonny Reeves, http://jonnyreeves.co.uk/
     * js-logger may be freely distributed under the MIT license.
     */

    (function (module) {
    (function (global) {

    	// Top level module for the global, static logger instance.
    	var Logger = { };

    	// For those that are at home that are keeping score.
    	Logger.VERSION = "1.6.1";

    	// Function which handles all incoming log messages.
    	var logHandler;

    	// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.
    	var contextualLoggersByNameMap = {};

    	// Polyfill for ES5's Function.bind.
    	var bind = function(scope, func) {
    		return function() {
    			return func.apply(scope, arguments);
    		};
    	};

    	// Super exciting object merger-matron 9000 adding another 100 bytes to your download.
    	var merge = function () {
    		var args = arguments, target = args[0], key, i;
    		for (i = 1; i < args.length; i++) {
    			for (key in args[i]) {
    				if (!(key in target) && args[i].hasOwnProperty(key)) {
    					target[key] = args[i][key];
    				}
    			}
    		}
    		return target;
    	};

    	// Helper to define a logging level object; helps with optimisation.
    	var defineLogLevel = function(value, name) {
    		return { value: value, name: name };
    	};

    	// Predefined logging levels.
    	Logger.TRACE = defineLogLevel(1, 'TRACE');
    	Logger.DEBUG = defineLogLevel(2, 'DEBUG');
    	Logger.INFO = defineLogLevel(3, 'INFO');
    	Logger.TIME = defineLogLevel(4, 'TIME');
    	Logger.WARN = defineLogLevel(5, 'WARN');
    	Logger.ERROR = defineLogLevel(8, 'ERROR');
    	Logger.OFF = defineLogLevel(99, 'OFF');

    	// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently
    	// of each other.
    	var ContextualLogger = function(defaultContext) {
    		this.context = defaultContext;
    		this.setLevel(defaultContext.filterLevel);
    		this.log = this.info;  // Convenience alias.
    	};

    	ContextualLogger.prototype = {
    		// Changes the current logging level for the logging instance.
    		setLevel: function (newLevel) {
    			// Ensure the supplied Level object looks valid.
    			if (newLevel && "value" in newLevel) {
    				this.context.filterLevel = newLevel;
    			}
    		},
    		
    		// Gets the current logging level for the logging instance
    		getLevel: function () {
    			return this.context.filterLevel;
    		},

    		// Is the logger configured to output messages at the supplied level?
    		enabledFor: function (lvl) {
    			var filterLevel = this.context.filterLevel;
    			return lvl.value >= filterLevel.value;
    		},

    		trace: function () {
    			this.invoke(Logger.TRACE, arguments);
    		},

    		debug: function () {
    			this.invoke(Logger.DEBUG, arguments);
    		},

    		info: function () {
    			this.invoke(Logger.INFO, arguments);
    		},

    		warn: function () {
    			this.invoke(Logger.WARN, arguments);
    		},

    		error: function () {
    			this.invoke(Logger.ERROR, arguments);
    		},

    		time: function (label) {
    			if (typeof label === 'string' && label.length > 0) {
    				this.invoke(Logger.TIME, [ label, 'start' ]);
    			}
    		},

    		timeEnd: function (label) {
    			if (typeof label === 'string' && label.length > 0) {
    				this.invoke(Logger.TIME, [ label, 'end' ]);
    			}
    		},

    		// Invokes the logger callback if it's not being filtered.
    		invoke: function (level, msgArgs) {
    			if (logHandler && this.enabledFor(level)) {
    				logHandler(msgArgs, merge({ level: level }, this.context));
    			}
    		}
    	};

    	// Protected instance which all calls to the to level `Logger` module will be routed through.
    	var globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });

    	// Configure the global Logger instance.
    	(function() {
    		// Shortcut for optimisers.
    		var L = Logger;

    		L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
    		L.trace = bind(globalLogger, globalLogger.trace);
    		L.debug = bind(globalLogger, globalLogger.debug);
    		L.time = bind(globalLogger, globalLogger.time);
    		L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
    		L.info = bind(globalLogger, globalLogger.info);
    		L.warn = bind(globalLogger, globalLogger.warn);
    		L.error = bind(globalLogger, globalLogger.error);

    		// Don't forget the convenience alias!
    		L.log = L.info;
    	}());

    	// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments
    	// object with the supplied log messages and the second being a context object which contains a hash of stateful
    	// parameters which the logging function can consume.
    	Logger.setHandler = function (func) {
    		logHandler = func;
    	};

    	// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.
    	// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).
    	Logger.setLevel = function(level) {
    		// Set the globalLogger's level.
    		globalLogger.setLevel(level);

    		// Apply this level to all registered contextual loggers.
    		for (var key in contextualLoggersByNameMap) {
    			if (contextualLoggersByNameMap.hasOwnProperty(key)) {
    				contextualLoggersByNameMap[key].setLevel(level);
    			}
    		}
    	};

    	// Gets the global logging filter level
    	Logger.getLevel = function() {
    		return globalLogger.getLevel();
    	};

    	// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,
    	// default context and log handler.
    	Logger.get = function (name) {
    		// All logger instances are cached so they can be configured ahead of use.
    		return contextualLoggersByNameMap[name] ||
    			(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));
    	};

    	// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will
    	// write to the window's console object (if present); the optional options object can be used to customise the
    	// formatter used to format each log message.
    	Logger.createDefaultHandler = function (options) {
    		options = options || {};

    		options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
    			// Prepend the logger's name to the log message for easy identification.
    			if (context.name) {
    				messages.unshift("[" + context.name + "]");
    			}
    		};

    		// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments
    		// that don't offer a native console method.
    		var timerStartTimeByLabelMap = {};

    		// Support for IE8+ (and other, slightly more sane environments)
    		var invokeConsoleMethod = function (hdlr, messages) {
    			Function.prototype.apply.call(hdlr, console, messages);
    		};

    		// Check for the presence of a logger.
    		if (typeof console === "undefined") {
    			return function () { /* no console */ };
    		}

    		return function(messages, context) {
    			// Convert arguments object to Array.
    			messages = Array.prototype.slice.call(messages);

    			var hdlr = console.log;
    			var timerLabel;

    			if (context.level === Logger.TIME) {
    				timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];

    				if (messages[1] === 'start') {
    					if (console.time) {
    						console.time(timerLabel);
    					}
    					else {
    						timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
    					}
    				}
    				else {
    					if (console.timeEnd) {
    						console.timeEnd(timerLabel);
    					}
    					else {
    						invokeConsoleMethod(hdlr, [ timerLabel + ': ' +
    							(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);
    					}
    				}
    			}
    			else {
    				// Delegate through to custom warn/error loggers if present on the console.
    				if (context.level === Logger.WARN && console.warn) {
    					hdlr = console.warn;
    				} else if (context.level === Logger.ERROR && console.error) {
    					hdlr = console.error;
    				} else if (context.level === Logger.INFO && console.info) {
    					hdlr = console.info;
    				} else if (context.level === Logger.DEBUG && console.debug) {
    					hdlr = console.debug;
    				} else if (context.level === Logger.TRACE && console.trace) {
    					hdlr = console.trace;
    				}

    				options.formatter(messages, context);
    				invokeConsoleMethod(hdlr, messages);
    			}
    		};
    	};

    	// Configure and example a Default implementation which writes to the `window.console` (if present).  The
    	// `options` hash can be used to configure the default logLevel and provide a custom message formatter.
    	Logger.useDefaults = function(options) {
    		Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);
    		Logger.setHandler(Logger.createDefaultHandler(options));
    	};

    	// Createa an alias to useDefaults to avoid reaking a react-hooks rule.
    	Logger.setDefaults = Logger.useDefaults;

    	// Export to popular environments boilerplate.
    	if (module.exports) {
    		module.exports = Logger;
    	}
    	else {
    		Logger._prevLogger = global.Logger;

    		Logger.noConflict = function () {
    			global.Logger = Logger._prevLogger;
    			return Logger;
    		};

    		global.Logger = Logger;
    	}
    }(commonjsGlobal));
    }(logger));

    var Logger = logger.exports;

    /* src/components/TableView/TableView.svelte generated by Svelte v3.42.4 */

    const { window: window_1$1 } = globals;

    function create_fragment$z(ctx) {
    	let popupformular;
    	let t0;
    	let searchfilterbar;
    	let updating_searchTerm;
    	let t1;
    	let table;
    	let t2;
    	let pagination;
    	let updating_currentPage;
    	let t3;
    	let addnewdocbutton;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[20]);
    	let popupformular_props = {};
    	popupformular = new PopupFormular({ props: popupformular_props });
    	/*popupformular_binding*/ ctx[21](popupformular);

    	function searchfilterbar_searchTerm_binding(value) {
    		/*searchfilterbar_searchTerm_binding*/ ctx[22](value);
    	}

    	let searchfilterbar_props = {
    		filterOptions: Object.keys(/*filters*/ ctx[0].filters).map(func$1),
    		activeFilters: /*activeFilters*/ ctx[6]
    	};

    	if (/*searchTerm*/ ctx[3] !== void 0) {
    		searchfilterbar_props.searchTerm = /*searchTerm*/ ctx[3];
    	}

    	searchfilterbar = new SearchFilterBar({ props: searchfilterbar_props });
    	binding_callbacks.push(() => bind$1(searchfilterbar, 'searchTerm', searchfilterbar_searchTerm_binding));
    	/*searchfilterbar_binding*/ ctx[23](searchfilterbar);
    	searchfilterbar.$on("filtersChanged", /*filtersChanged_handler*/ ctx[24]);

    	table = new Table({
    			props: {
    				rowHeight,
    				columns: /*columnsToDisplay*/ ctx[2],
    				loadData: /*tableData*/ ctx[12],
    				cellBackgroundColorsFunction: /*func_1*/ ctx[25],
    				indicateSort: /*indicateSort*/ ctx[15],
    				onLoadDataErrorText: func_2
    			}
    		});

    	table.$on("rowClicked", /*rowClicked_handler*/ ctx[26]);
    	table.$on("colHeaderClicked", /*colHeaderClicked_handler*/ ctx[27]);

    	function pagination_currentPage_binding(value) {
    		/*pagination_currentPage_binding*/ ctx[28](value);
    	}

    	let pagination_props = {
    		numberOfPagesPromise: /*numberOfPagesPromise*/ ctx[13]
    	};

    	if (/*currentPage*/ ctx[4] !== void 0) {
    		pagination_props.currentPage = /*currentPage*/ ctx[4];
    	}

    	pagination = new Pagination({ props: pagination_props });
    	binding_callbacks.push(() => bind$1(pagination, 'currentPage', pagination_currentPage_binding));
    	addnewdocbutton = new AddNewDocButton({});
    	addnewdocbutton.$on("click", /*click_handler*/ ctx[29]);

    	return {
    		c() {
    			create_component(popupformular.$$.fragment);
    			t0 = space();
    			create_component(searchfilterbar.$$.fragment);
    			t1 = space();
    			create_component(table.$$.fragment);
    			t2 = space();
    			create_component(pagination.$$.fragment);
    			t3 = space();
    			create_component(addnewdocbutton.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(popupformular, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(searchfilterbar, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(table, target, anchor);
    			insert(target, t2, anchor);
    			mount_component(pagination, target, anchor);
    			insert(target, t3, anchor);
    			mount_component(addnewdocbutton, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen(window_1$1, "resize", /*onwindowresize*/ ctx[20]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			const popupformular_changes = {};
    			popupformular.$set(popupformular_changes);
    			const searchfilterbar_changes = {};
    			if (dirty[0] & /*filters*/ 1) searchfilterbar_changes.filterOptions = Object.keys(/*filters*/ ctx[0].filters).map(func$1);
    			if (dirty[0] & /*activeFilters*/ 64) searchfilterbar_changes.activeFilters = /*activeFilters*/ ctx[6];

    			if (!updating_searchTerm && dirty[0] & /*searchTerm*/ 8) {
    				updating_searchTerm = true;
    				searchfilterbar_changes.searchTerm = /*searchTerm*/ ctx[3];
    				add_flush_callback(() => updating_searchTerm = false);
    			}

    			searchfilterbar.$set(searchfilterbar_changes);
    			const table_changes = {};
    			if (dirty[0] & /*columnsToDisplay*/ 4) table_changes.columns = /*columnsToDisplay*/ ctx[2];
    			if (dirty[0] & /*tableData*/ 4096) table_changes.loadData = /*tableData*/ ctx[12];
    			if (dirty[0] & /*columnsToDisplay*/ 4) table_changes.cellBackgroundColorsFunction = /*func_1*/ ctx[25];
    			if (dirty[0] & /*indicateSort*/ 32768) table_changes.indicateSort = /*indicateSort*/ ctx[15];
    			table.$set(table_changes);
    			const pagination_changes = {};
    			if (dirty[0] & /*numberOfPagesPromise*/ 8192) pagination_changes.numberOfPagesPromise = /*numberOfPagesPromise*/ ctx[13];

    			if (!updating_currentPage && dirty[0] & /*currentPage*/ 16) {
    				updating_currentPage = true;
    				pagination_changes.currentPage = /*currentPage*/ ctx[4];
    				add_flush_callback(() => updating_currentPage = false);
    			}

    			pagination.$set(pagination_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(popupformular.$$.fragment, local);
    			transition_in(searchfilterbar.$$.fragment, local);
    			transition_in(table.$$.fragment, local);
    			transition_in(pagination.$$.fragment, local);
    			transition_in(addnewdocbutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(popupformular.$$.fragment, local);
    			transition_out(searchfilterbar.$$.fragment, local);
    			transition_out(table.$$.fragment, local);
    			transition_out(pagination.$$.fragment, local);
    			transition_out(addnewdocbutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			/*popupformular_binding*/ ctx[21](null);
    			destroy_component(popupformular, detaching);
    			if (detaching) detach(t0);
    			/*searchfilterbar_binding*/ ctx[23](null);
    			destroy_component(searchfilterbar, detaching);
    			if (detaching) detach(t1);
    			destroy_component(table, detaching);
    			if (detaching) detach(t2);
    			destroy_component(pagination, detaching);
    			if (detaching) detach(t3);
    			destroy_component(addnewdocbutton, detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    const rowHeight = 40;
    let rowsPerPage = 25; // maxRowsThatMightFitOnPage();
    const func$1 = filter => ({ value: filter, label: filter });

    const func_2 = error => {
    	if (error.status === 401) {
    		return "Benutzername oder Passwort für die Datenbank ist nicht korrekt. Bitte in den Einstellungen (Zahnrad rechts oben) überprüfen.";
    	} else {
    		return `Keine Verbindung zur Datenbank. <br />${error.hasOwnProperty("message") ? error.message : ""}`;
    	}
    };

    function instance$y($$self, $$props, $$invalidate) {
    	let { columns = [] } = $$props;
    	let { filters = {} } = $$props;
    	let { docType = "" } = $$props;
    	let { inputs = [] } = $$props;
    	let { onData = null } = $$props;
    	let columnsToDisplay = [];
    	let popupIsOpen = false;
    	let refreshWhenPopupCloses = false;

    	const onPopupClosed = () => {
    		$$invalidate(9, popupIsOpen = false);
    		if (refreshWhenPopupCloses) refresh();
    	};

    	const refresh = () => {
    		if (!popupIsOpen) {
    			refreshWhenPopupCloses = false;

    			$$invalidate(12, tableData = Database.query(
    				{
    					filters: activeFilters.map(filterName => filters.filters[filterName]),
    					columns,
    					searchTerm,
    					currentPage,
    					rowsPerPage,
    					sortBy: sort,
    					sortReverse,
    					docType
    				},
    				// query again if a doc was created / deleted / updated
    				refresh
    			).then(data => {
    				searchInputRef?.focusSearchInput();

    				$$invalidate(13, numberOfPagesPromise = data.count.then(count => {
    					const rowsOnLastPage = count % rowsPerPage;
    					let numberOfPages = (count - rowsOnLastPage) / rowsPerPage;
    					if (rowsOnLastPage > 0) numberOfPages += 1;
    					return numberOfPages;
    				}));

    				return data.docs;
    			}).then(data => {
    				return onData ? onData(data) : data;
    			}).catch(error => {
    				Logger.error(error);

    				// catch again in html
    				throw error;
    			}));
    		} else {
    			refreshWhenPopupCloses = true;
    		}
    	};

    	const goToFirstPage = () => {
    		if (currentPage !== 0) {
    			$$invalidate(4, currentPage = 0);
    		}
    	};

    	let actualRowsFittingOnPage = false;
    	let popupFormular;
    	let searchInputRef;
    	let tableData = Promise.resolve();

    	let numberOfPagesPromise = new Promise(() => {
    			
    		});

    	let searchTerm = "";
    	let currentPage = 0;
    	let innerHeight = window.innerHeight;
    	let activeFilters = filters.activeByDefault;
    	let sortByColKey = "id";
    	let sortReverse;
    	let sort;
    	let indicateSort;

    	afterUpdate(async () => {
    		if (actualRowsFittingOnPage === false) {
    			await tableData;
    			const paginationElement = document.querySelector(".pagination");
    			const tableHeaderElement = document.querySelector("thead");
    			const tableRowElement = document.querySelector("tbody tr");
    			const rowBorderSpacing = 1;

    			if (paginationElement && tableHeaderElement && tableRowElement) {
    				let tableBodyHeight = window.innerHeight - paginationElement.offsetHeight - tableHeaderElement.getBoundingClientRect().bottom;
    				actualRowsFittingOnPage = Math.floor(tableBodyHeight / (tableRowElement.getBoundingClientRect().height + rowBorderSpacing));
    				//rowsPerPage = actualRowsFittingOnPage;
    			}
    		}
    	});

    	onDestroy(() => {
    		Database.cancelListenerForDocType(docType);
    	});

    	const shouldBeSortedByInitially = col => "initialSort" in col;

    	const setInitialSortCol = () => {
    		$$invalidate(7, sortByColKey = columns.find(shouldBeSortedByInitially)
    		? columns.find(shouldBeSortedByInitially).key
    		: sortByColKey);

    		const col = columns.find(col => col.key === sortByColKey);
    		$$invalidate(14, sort = col.sort ? col.sort : [sortByColKey]);
    	};

    	const setInitialSortDirection = () => $$invalidate(8, sortReverse = columns.some(shouldBeSortedByInitially)
    	? columns.find(shouldBeSortedByInitially).initialSort === "desc"
    	: false);

    	activeFilters = filters.activeByDefault;
    	setInitialSortCol();
    	setInitialSortDirection();

    	function onwindowresize() {
    		$$invalidate(5, innerHeight = window_1$1.innerHeight);
    	}

    	function popupformular_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			popupFormular = $$value;
    			$$invalidate(10, popupFormular);
    		});
    	}

    	function searchfilterbar_searchTerm_binding(value) {
    		searchTerm = value;
    		$$invalidate(3, searchTerm);
    	}

    	function searchfilterbar_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			searchInputRef = $$value;
    			$$invalidate(11, searchInputRef);
    		});
    	}

    	const filtersChanged_handler = event => {
    		if (JSON.stringify(event.detail) !== JSON.stringify(activeFilters)) {
    			$$invalidate(6, activeFilters = event.detail);
    		}
    	};

    	const func_1 = customer => Promise.all(columnsToDisplay.map(column => column.backgroundColor(customer)));

    	const rowClicked_handler = event => {
    		$$invalidate(9, popupIsOpen = true);

    		popupFormular.show(
    			{
    				doc: event.detail,
    				createNew: false,
    				config: inputs
    			},
    			onPopupClosed
    		);
    	};

    	const colHeaderClicked_handler = event => {
    		if (sortByColKey == event.detail.key) $$invalidate(8, sortReverse = !sortReverse); else $$invalidate(8, sortReverse = false);
    		$$invalidate(7, sortByColKey = event.detail.key);
    		const col = columnsToDisplay.find(col => col.key === sortByColKey);
    		$$invalidate(14, sort = col.sort ?? [sortByColKey]);
    	};

    	function pagination_currentPage_binding(value) {
    		currentPage = value;
    		$$invalidate(4, currentPage);
    	}

    	const click_handler = () => {
    		$$invalidate(9, popupIsOpen = true);
    		popupFormular.show({ createNew: true, config: inputs }, onPopupClosed);
    	};

    	$$self.$$set = $$props => {
    		if ('columns' in $$props) $$invalidate(17, columns = $$props.columns);
    		if ('filters' in $$props) $$invalidate(0, filters = $$props.filters);
    		if ('docType' in $$props) $$invalidate(18, docType = $$props.docType);
    		if ('inputs' in $$props) $$invalidate(1, inputs = $$props.inputs);
    		if ('onData' in $$props) $$invalidate(19, onData = $$props.onData);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*columns*/ 131072) {
    			$$invalidate(2, columnsToDisplay = columns.filter(column => !column.hideInTable));
    		}

    		if ($$self.$$.dirty[0] & /*innerHeight*/ 32) {
    			(actualRowsFittingOnPage = false);
    		}

    		if ($$self.$$.dirty[0] & /*sortByColKey, sortReverse, searchTerm, activeFilters*/ 456) {
    			(goToFirstPage());
    		}

    		if ($$self.$$.dirty[0] & /*currentPage, sortByColKey, sortReverse, searchTerm, activeFilters, innerHeight*/ 504) {
    			(refresh());
    		}

    		if ($$self.$$.dirty[0] & /*columnsToDisplay, sortByColKey, sortReverse*/ 388) {
    			$$invalidate(15, indicateSort = columnsToDisplay.map(col => {
    				if (col.key === sortByColKey) {
    					return sortReverse ? "up" : "down";
    				} else {
    					return "";
    				}
    			}));
    		}
    	};

    	return [
    		filters,
    		inputs,
    		columnsToDisplay,
    		searchTerm,
    		currentPage,
    		innerHeight,
    		activeFilters,
    		sortByColKey,
    		sortReverse,
    		popupIsOpen,
    		popupFormular,
    		searchInputRef,
    		tableData,
    		numberOfPagesPromise,
    		sort,
    		indicateSort,
    		onPopupClosed,
    		columns,
    		docType,
    		onData,
    		onwindowresize,
    		popupformular_binding,
    		searchfilterbar_searchTerm_binding,
    		searchfilterbar_binding,
    		filtersChanged_handler,
    		func_1,
    		rowClicked_handler,
    		colHeaderClicked_handler,
    		pagination_currentPage_binding,
    		click_handler
    	];
    }

    class TableView extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$y,
    			create_fragment$z,
    			safe_not_equal,
    			{
    				columns: 17,
    				filters: 0,
    				docType: 18,
    				inputs: 1,
    				onData: 19
    			},
    			null,
    			[-1, -1]
    		);
    	}
    }

    const defaultSettings = {
      couchdbHost: "127.0.0.1",
      couchdbHTTPS: false,
      couchdbPort: "5984",
      couchdbUser: "user",
      couchdbPassword: "password",
      couchdbName: "leihlokal_test",
      wcUrl: "https://www.buergerstiftung-karlsruhe.de/wp-json/wc/v3",
      wcKey: "",
      wcSecret: "",
    };

    const settingsKeys = Object.keys(defaultSettings);

    const readFromLocalStorage = () => {
      let settings = defaultSettings;
      settingsKeys.forEach((key) => {
        if (localStorage.hasOwnProperty(key)) {
          if (localStorage.getItem(key) === "true") {
            settings[key] = true;
          } else if (localStorage.getItem(key) === "false") {
            settings[key] = false;
          } else {
            settings[key] = localStorage.getItem(key);
          }
        }
      });
      return settings;
    };

    const writeToLocalStorage = (settings) => {
      for (const [key, value] of Object.entries(settings)) {
        localStorage.setItem(key, String(value));
      }
    };

    const createStore$1 = () => {
      const data = readFromLocalStorage();
      //if sub is broken, sets value to current local storage value
      const store = writable(data, () => {
        const unsubscribe = store.subscribe((value) => {
          writeToLocalStorage(value);
        });
        return unsubscribe;
      });
      return store;
    };

    const settingsStore = createStore$1();

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
        if (a === b || a !== a)
            return () => a;
        const type = typeof a;
        if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
            throw new Error('Cannot interpolate values of different type');
        }
        if (Array.isArray(a)) {
            const arr = b.map((bi, i) => {
                return get_interpolator(a[i], bi);
            });
            return t => arr.map(fn => fn(t));
        }
        if (type === 'object') {
            if (!a || !b)
                throw new Error('Object cannot be null');
            if (is_date(a) && is_date(b)) {
                a = a.getTime();
                b = b.getTime();
                const delta = b - a;
                return t => new Date(a + t * delta);
            }
            const keys = Object.keys(b);
            const interpolators = {};
            keys.forEach(key => {
                interpolators[key] = get_interpolator(a[key], b[key]);
            });
            return t => {
                const result = {};
                keys.forEach(key => {
                    result[key] = interpolators[key](t);
                });
                return result;
            };
        }
        if (type === 'number') {
            const delta = b - a;
            return t => a + t * delta;
        }
        throw new Error(`Cannot interpolate ${type} values`);
    }
    function tweened(value, defaults = {}) {
        const store = writable(value);
        let task;
        let target_value = value;
        function set(new_value, opts) {
            if (value == null) {
                store.set(value = new_value);
                return Promise.resolve();
            }
            target_value = new_value;
            let previous_task = task;
            let started = false;
            let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
            if (duration === 0) {
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                store.set(value = target_value);
                return Promise.resolve();
            }
            const start = now() + delay;
            let fn;
            task = loop(now => {
                if (now < start)
                    return true;
                if (!started) {
                    fn = interpolate(value, new_value);
                    if (typeof duration === 'function')
                        duration = duration(value, new_value);
                    started = true;
                }
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                const elapsed = now - start;
                if (elapsed > duration) {
                    store.set(value = new_value);
                    return false;
                }
                // @ts-ignore
                store.set(value = fn(easing(elapsed / duration)));
                return true;
            });
            return task.promise;
        }
        return {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe
        };
    }

    const createStyle = ({
      from = 0,
      to = 1,
      reverse = false,
      duration = 300,
      delay = 0,
      css = {},
      onChange = () => false,
      onEnd = () => false,
      easing
    }) => {
      const animation = tweened(reverse ? to : from, {
        duration,
        delay,
        easing
      });
      animation.subscribe(t => {
        let newStyle = "";
        for (let item in css) {
          const {
            input,
            output,
            onComplete = () => false,
            beforeStart = () => false
          } = css[item];
          const inRange = input.filter(i => i <= t).reverse()[0];
          const index = input.indexOf(inRange);
          let val;
          if (!inRange && inRange !== 0) {
            val = output[0];
            beforeStart();
          } else {
            if (input.length - 1 === index) {
              val = output[output.length - 1];
              input[input.length - 1] <= t && onComplete();
            } else {
              const endRange = input[index + 1];
              const percent = ((t - inRange) * 100) / (endRange - inRange);
              const firstItem = output[index];
              const lastItem = output[index + 1];
              if (typeof lastItem === "object") {
                val = "";
                lastItem.map(i => {
                  val += firstItem + ((i - firstItem) * percent) / 100;
                  val += " ";
                });
              } else {
                val = firstItem + ((lastItem - firstItem) * percent) / 100;
              }
            }
          }
          newStyle += `${item}: ${val};`;
        }
        onChange(newStyle);
        if (t === to || t === from) {
          onEnd();
        }
      });
      return {
        play: () => animation.set(to),
        reverse: () => animation.set(from)
      };
    };

    /* node_modules/svelte-checkbox/Checkbox.svelte generated by Svelte v3.42.4 */

    function create_fragment$y(ctx) {
    	let div;
    	let input;
    	let t;
    	let svg;
    	let rect0;
    	let rect1;
    	let path;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			svg = svg_element("svg");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			path = svg_element("path");
    			attr(input, "id", /*labelId*/ ctx[4]);
    			attr(input, "type", "checkbox");
    			attr(input, "name", /*name*/ ctx[2]);
    			attr(input, "class", "svelte-d8g7vy");
    			attr(rect0, "class", "checkbox__border svelte-d8g7vy");
    			attr(rect0, "rx", "15%");
    			attr(rect1, "class", "checkbox__border -active svelte-d8g7vy");
    			attr(rect1, "style", /*borderStyle*/ ctx[8]);
    			attr(rect1, "rx", "15%");
    			attr(path, "style", /*checkStyle*/ ctx[9]);
    			attr(path, "class", "checkbox__check svelte-d8g7vy");
    			attr(path, "d", "M 89.5 13 L 46 71 L 28 54");
    			attr(svg, "class", "checkbox__svg svelte-d8g7vy");
    			attr(svg, "preserveAspectRatio", "none");
    			attr(svg, "viewBox", "0 0 100 100");
    			attr(div, "id", /*id*/ ctx[3]);
    			attr(div, "class", div_class_value = "checkbox " + /*$$props*/ ctx[11].class + " svelte-d8g7vy");
    			set_style(div, "width", /*size*/ ctx[1]);
    			set_style(div, "height", /*size*/ ctx[1]);
    			toggle_class(div, "-changeBg", /*changeBg*/ ctx[7]);
    			toggle_class(div, "-checked", /*checked*/ ctx[0] || !/*canChange*/ ctx[6]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, input);
    			append(div, t);
    			append(div, svg);
    			append(svg, rect0);
    			append(svg, rect1);
    			append(svg, path);
    			/*div_binding*/ ctx[15](div);

    			if (!mounted) {
    				dispose = listen(input, "change", /*handleChange*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*labelId*/ 16) {
    				attr(input, "id", /*labelId*/ ctx[4]);
    			}

    			if (dirty & /*name*/ 4) {
    				attr(input, "name", /*name*/ ctx[2]);
    			}

    			if (dirty & /*borderStyle*/ 256) {
    				attr(rect1, "style", /*borderStyle*/ ctx[8]);
    			}

    			if (dirty & /*checkStyle*/ 512) {
    				attr(path, "style", /*checkStyle*/ ctx[9]);
    			}

    			if (dirty & /*id*/ 8) {
    				attr(div, "id", /*id*/ ctx[3]);
    			}

    			if (dirty & /*$$props*/ 2048 && div_class_value !== (div_class_value = "checkbox " + /*$$props*/ ctx[11].class + " svelte-d8g7vy")) {
    				attr(div, "class", div_class_value);
    			}

    			if (dirty & /*size*/ 2) {
    				set_style(div, "width", /*size*/ ctx[1]);
    			}

    			if (dirty & /*size*/ 2) {
    				set_style(div, "height", /*size*/ ctx[1]);
    			}

    			if (dirty & /*$$props, changeBg*/ 2176) {
    				toggle_class(div, "-changeBg", /*changeBg*/ ctx[7]);
    			}

    			if (dirty & /*$$props, checked, canChange*/ 2113) {
    				toggle_class(div, "-checked", /*checked*/ ctx[0] || !/*canChange*/ ctx[6]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    			/*div_binding*/ ctx[15](null);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let self, canChange = true, changeBg = false, borderStyle, checkStyle;
    	let { checked = false, size = "3rem", name = "", id = "", labelId = "", duration = 900, primaryColor = "#242432", secondaryColor = "#d8d8ea" } = $$props;
    	const dispatch = createEventDispatcher();

    	const animationOptions = {
    		to: 100,
    		duration,
    		easing: sineInOut,
    		reverse: checked
    	};

    	const borderAnimation = createStyle({
    		...animationOptions,
    		duration,
    		css: {
    			"stroke-dashoffset": {
    				input: [0, 45, 75],
    				output: [342, -150, -307],
    				onComplete: () => $$invalidate(7, changeBg = true)
    			},
    			"stroke-dasharray": {
    				input: [0, 45, 75],
    				output: [342, 154, [0, 310]]
    			},
    			opacity: { input: [0, 5], output: [0, 1] }
    		},
    		onChange: style => $$invalidate(8, borderStyle = style),
    		onEnd: () => $$invalidate(6, canChange = true)
    	});

    	const checkAnimation = createStyle({
    		...animationOptions,
    		css: {
    			"stroke-dashoffset": {
    				input: [65, 100],
    				output: [300, 144],
    				beforeStart: () => $$invalidate(7, changeBg = false)
    			},
    			"stroke-dasharray": { input: [65, 100], output: [100, 84] }
    		},
    		onChange: style => $$invalidate(9, checkStyle = style)
    	});

    	const handleChange = () => {
    		if (!canChange) return false;

    		if (checked) {
    			borderAnimation.reverse();
    			checkAnimation.reverse();
    		} else {
    			borderAnimation.play();
    			checkAnimation.play();
    		}

    		$$invalidate(6, canChange = false);
    		$$invalidate(0, checked = !checked);
    		dispatch("change", checked);
    	};

    	const setProp = (prop, val) => self.style.setProperty(prop, val);

    	onMount(() => {
    		setProp("--checkbox-color-primary", primaryColor);
    		setProp("--checkbox-color-secondary", secondaryColor);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			self = $$value;
    			$$invalidate(5, self);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
    		if ('name' in $$new_props) $$invalidate(2, name = $$new_props.name);
    		if ('id' in $$new_props) $$invalidate(3, id = $$new_props.id);
    		if ('labelId' in $$new_props) $$invalidate(4, labelId = $$new_props.labelId);
    		if ('duration' in $$new_props) $$invalidate(12, duration = $$new_props.duration);
    		if ('primaryColor' in $$new_props) $$invalidate(13, primaryColor = $$new_props.primaryColor);
    		if ('secondaryColor' in $$new_props) $$invalidate(14, secondaryColor = $$new_props.secondaryColor);
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		checked,
    		size,
    		name,
    		id,
    		labelId,
    		self,
    		canChange,
    		changeBg,
    		borderStyle,
    		checkStyle,
    		handleChange,
    		$$props,
    		duration,
    		primaryColor,
    		secondaryColor,
    		div_binding
    	];
    }

    class Checkbox extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$x, create_fragment$y, safe_not_equal, {
    			checked: 0,
    			size: 1,
    			name: 2,
    			id: 3,
    			labelId: 4,
    			duration: 12,
    			primaryColor: 13,
    			secondaryColor: 14
    		});
    	}
    }

    /* src/components/Input/SettingsFormular.svelte generated by Svelte v3.42.4 */

    function create_fragment$x(ctx) {
    	let div32;
    	let div31;
    	let div1;
    	let t1;
    	let div4;
    	let div2;
    	let t3;
    	let div3;
    	let input0;
    	let t4;
    	let div7;
    	let div5;
    	let t6;
    	let div6;
    	let checkbox;
    	let updating_checked;
    	let t7;
    	let div10;
    	let div8;
    	let t9;
    	let div9;
    	let input1;
    	let t10;
    	let div13;
    	let div11;
    	let t12;
    	let div12;
    	let input2;
    	let t13;
    	let div16;
    	let div14;
    	let t15;
    	let div15;
    	let input3;
    	let t16;
    	let div19;
    	let div17;
    	let t18;
    	let div18;
    	let input4;
    	let t19;
    	let div21;
    	let t21;
    	let div24;
    	let div22;
    	let t23;
    	let div23;
    	let input5;
    	let t24;
    	let div27;
    	let div25;
    	let t26;
    	let div26;
    	let input6;
    	let t27;
    	let div30;
    	let div28;
    	let t29;
    	let div29;
    	let input7;
    	let current;
    	let mounted;
    	let dispose;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[2](value);
    	}

    	let checkbox_props = { size: "2rem" };

    	if (/*$settingsStore*/ ctx[0].couchdbHTTPS !== void 0) {
    		checkbox_props.checked = /*$settingsStore*/ ctx[0].couchdbHTTPS;
    	}

    	checkbox = new Checkbox({ props: checkbox_props });
    	binding_callbacks.push(() => bind$1(checkbox, 'checked', checkbox_checked_binding));

    	return {
    		c() {
    			div32 = element("div");
    			div31 = element("div");
    			div1 = element("div");
    			div1.innerHTML = `<div class="col-25 svelte-wezv84"><h2 class="svelte-wezv84">Datenbank</h2></div>`;
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div2.innerHTML = `<label for="couchdbhost" class="svelte-wezv84">Host</label>`;
    			t3 = space();
    			div3 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div7 = element("div");
    			div5 = element("div");
    			div5.innerHTML = `<label for="couchdbhost" class="svelte-wezv84">HTTPS</label>`;
    			t6 = space();
    			div6 = element("div");
    			create_component(checkbox.$$.fragment);
    			t7 = space();
    			div10 = element("div");
    			div8 = element("div");
    			div8.innerHTML = `<label for="couchdbport" class="svelte-wezv84">Port</label>`;
    			t9 = space();
    			div9 = element("div");
    			input1 = element("input");
    			t10 = space();
    			div13 = element("div");
    			div11 = element("div");
    			div11.innerHTML = `<label for="couchdbuser" class="svelte-wezv84">Benutzername</label>`;
    			t12 = space();
    			div12 = element("div");
    			input2 = element("input");
    			t13 = space();
    			div16 = element("div");
    			div14 = element("div");
    			div14.innerHTML = `<label for="couchdbpassword" class="svelte-wezv84">Passwort</label>`;
    			t15 = space();
    			div15 = element("div");
    			input3 = element("input");
    			t16 = space();
    			div19 = element("div");
    			div17 = element("div");
    			div17.innerHTML = `<label for="couchdbhost" class="svelte-wezv84">Datenbank</label>`;
    			t18 = space();
    			div18 = element("div");
    			input4 = element("input");
    			t19 = space();
    			div21 = element("div");
    			div21.innerHTML = `<div class="col-25 svelte-wezv84"><h2 class="svelte-wezv84">WooCommerce</h2></div>`;
    			t21 = space();
    			div24 = element("div");
    			div22 = element("div");
    			div22.innerHTML = `<label for="wcurl" class="svelte-wezv84">URL</label>`;
    			t23 = space();
    			div23 = element("div");
    			input5 = element("input");
    			t24 = space();
    			div27 = element("div");
    			div25 = element("div");
    			div25.innerHTML = `<label for="wckey" class="svelte-wezv84">API Key</label>`;
    			t26 = space();
    			div26 = element("div");
    			input6 = element("input");
    			t27 = space();
    			div30 = element("div");
    			div28 = element("div");
    			div28.innerHTML = `<label for="wcsecret" class="svelte-wezv84">Secret</label>`;
    			t29 = space();
    			div29 = element("div");
    			input7 = element("input");
    			attr(div1, "class", "row svelte-wezv84");
    			attr(div2, "class", "col-25 svelte-wezv84");
    			attr(input0, "id", "couchdbhost");
    			attr(input0, "type", "text");
    			attr(input0, "placeholder", "127.0.0.1");
    			attr(input0, "class", "svelte-wezv84");
    			attr(div3, "class", "col-75 svelte-wezv84");
    			attr(div4, "class", "row svelte-wezv84");
    			attr(div5, "class", "col-25 svelte-wezv84");
    			attr(div6, "class", "col-75 svelte-wezv84");
    			attr(div7, "class", "row svelte-wezv84");
    			attr(div8, "class", "col-25 svelte-wezv84");
    			attr(input1, "id", "couchdbport");
    			attr(input1, "type", "text");
    			attr(input1, "placeholder", "6984");
    			attr(input1, "class", "svelte-wezv84");
    			attr(div9, "class", "col-75 svelte-wezv84");
    			attr(div10, "class", "row svelte-wezv84");
    			attr(div11, "class", "col-25 svelte-wezv84");
    			attr(input2, "id", "couchdbuser");
    			attr(input2, "type", "text");
    			attr(input2, "placeholder", "Benutzername");
    			attr(input2, "class", "svelte-wezv84");
    			attr(div12, "class", "col-75 svelte-wezv84");
    			attr(div13, "class", "row svelte-wezv84");
    			attr(div14, "class", "col-25 svelte-wezv84");
    			attr(input3, "id", "couchdbpassword");
    			attr(input3, "type", "password");
    			attr(input3, "placeholder", "Passwort");
    			attr(input3, "class", "svelte-wezv84");
    			attr(div15, "class", "col-75 svelte-wezv84");
    			attr(div16, "class", "row svelte-wezv84");
    			attr(div17, "class", "col-25 svelte-wezv84");
    			attr(input4, "id", "couchdbname");
    			attr(input4, "type", "text");
    			attr(input4, "placeholder", "Datenbank Name");
    			attr(input4, "class", "svelte-wezv84");
    			attr(div18, "class", "col-75 svelte-wezv84");
    			attr(div19, "class", "row svelte-wezv84");
    			attr(div21, "class", "row svelte-wezv84");
    			attr(div22, "class", "col-25 svelte-wezv84");
    			attr(input5, "id", "wcurl");
    			attr(input5, "type", "text");
    			attr(input5, "placeholder", "https://");
    			attr(input5, "class", "svelte-wezv84");
    			attr(div23, "class", "col-75 svelte-wezv84");
    			attr(div24, "class", "row svelte-wezv84");
    			attr(div25, "class", "col-25 svelte-wezv84");
    			attr(input6, "id", "wckey");
    			attr(input6, "type", "text");
    			attr(input6, "placeholder", "API Key");
    			attr(input6, "class", "svelte-wezv84");
    			attr(div26, "class", "col-75 svelte-wezv84");
    			attr(div27, "class", "row svelte-wezv84");
    			attr(div28, "class", "col-25 svelte-wezv84");
    			attr(input7, "id", "wcsecret");
    			attr(input7, "type", "password");
    			attr(input7, "placeholder", "Secret");
    			attr(input7, "class", "svelte-wezv84");
    			attr(div29, "class", "col-75 svelte-wezv84");
    			attr(div30, "class", "row svelte-wezv84");
    			attr(div31, "class", "content svelte-wezv84");
    			attr(div32, "class", "container svelte-wezv84");
    		},
    		m(target, anchor) {
    			insert(target, div32, anchor);
    			append(div32, div31);
    			append(div31, div1);
    			append(div31, t1);
    			append(div31, div4);
    			append(div4, div2);
    			append(div4, t3);
    			append(div4, div3);
    			append(div3, input0);
    			set_input_value(input0, /*$settingsStore*/ ctx[0].couchdbHost);
    			append(div31, t4);
    			append(div31, div7);
    			append(div7, div5);
    			append(div7, t6);
    			append(div7, div6);
    			mount_component(checkbox, div6, null);
    			append(div31, t7);
    			append(div31, div10);
    			append(div10, div8);
    			append(div10, t9);
    			append(div10, div9);
    			append(div9, input1);
    			set_input_value(input1, /*$settingsStore*/ ctx[0].couchdbPort);
    			append(div31, t10);
    			append(div31, div13);
    			append(div13, div11);
    			append(div13, t12);
    			append(div13, div12);
    			append(div12, input2);
    			set_input_value(input2, /*$settingsStore*/ ctx[0].couchdbUser);
    			append(div31, t13);
    			append(div31, div16);
    			append(div16, div14);
    			append(div16, t15);
    			append(div16, div15);
    			append(div15, input3);
    			set_input_value(input3, /*$settingsStore*/ ctx[0].couchdbPassword);
    			append(div31, t16);
    			append(div31, div19);
    			append(div19, div17);
    			append(div19, t18);
    			append(div19, div18);
    			append(div18, input4);
    			set_input_value(input4, /*$settingsStore*/ ctx[0].couchdbName);
    			append(div31, t19);
    			append(div31, div21);
    			append(div31, t21);
    			append(div31, div24);
    			append(div24, div22);
    			append(div24, t23);
    			append(div24, div23);
    			append(div23, input5);
    			set_input_value(input5, /*$settingsStore*/ ctx[0].wcUrl);
    			append(div31, t24);
    			append(div31, div27);
    			append(div27, div25);
    			append(div27, t26);
    			append(div27, div26);
    			append(div26, input6);
    			set_input_value(input6, /*$settingsStore*/ ctx[0].wcKey);
    			append(div31, t27);
    			append(div31, div30);
    			append(div30, div28);
    			append(div30, t29);
    			append(div30, div29);
    			append(div29, input7);
    			set_input_value(input7, /*$settingsStore*/ ctx[0].wcSecret);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(input0, "input", /*input0_input_handler*/ ctx[1]),
    					listen(input1, "input", /*input1_input_handler*/ ctx[3]),
    					listen(input2, "input", /*input2_input_handler*/ ctx[4]),
    					listen(input3, "input", /*input3_input_handler*/ ctx[5]),
    					listen(input4, "input", /*input4_input_handler*/ ctx[6]),
    					listen(input5, "input", /*input5_input_handler*/ ctx[7]),
    					listen(input6, "input", /*input6_input_handler*/ ctx[8]),
    					listen(input7, "input", /*input7_input_handler*/ ctx[9])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$settingsStore*/ 1 && input0.value !== /*$settingsStore*/ ctx[0].couchdbHost) {
    				set_input_value(input0, /*$settingsStore*/ ctx[0].couchdbHost);
    			}

    			const checkbox_changes = {};

    			if (!updating_checked && dirty & /*$settingsStore*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*$settingsStore*/ ctx[0].couchdbHTTPS;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);

    			if (dirty & /*$settingsStore*/ 1 && input1.value !== /*$settingsStore*/ ctx[0].couchdbPort) {
    				set_input_value(input1, /*$settingsStore*/ ctx[0].couchdbPort);
    			}

    			if (dirty & /*$settingsStore*/ 1 && input2.value !== /*$settingsStore*/ ctx[0].couchdbUser) {
    				set_input_value(input2, /*$settingsStore*/ ctx[0].couchdbUser);
    			}

    			if (dirty & /*$settingsStore*/ 1 && input3.value !== /*$settingsStore*/ ctx[0].couchdbPassword) {
    				set_input_value(input3, /*$settingsStore*/ ctx[0].couchdbPassword);
    			}

    			if (dirty & /*$settingsStore*/ 1 && input4.value !== /*$settingsStore*/ ctx[0].couchdbName) {
    				set_input_value(input4, /*$settingsStore*/ ctx[0].couchdbName);
    			}

    			if (dirty & /*$settingsStore*/ 1 && input5.value !== /*$settingsStore*/ ctx[0].wcUrl) {
    				set_input_value(input5, /*$settingsStore*/ ctx[0].wcUrl);
    			}

    			if (dirty & /*$settingsStore*/ 1 && input6.value !== /*$settingsStore*/ ctx[0].wcKey) {
    				set_input_value(input6, /*$settingsStore*/ ctx[0].wcKey);
    			}

    			if (dirty & /*$settingsStore*/ 1 && input7.value !== /*$settingsStore*/ ctx[0].wcSecret) {
    				set_input_value(input7, /*$settingsStore*/ ctx[0].wcSecret);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div32);
    			destroy_component(checkbox);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $settingsStore;
    	component_subscribe($$self, settingsStore, $$value => $$invalidate(0, $settingsStore = $$value));
    	let prevValue;
    	let timer;

    	const debounce = functionAfterDebounce => {
    		clearTimeout(timer);

    		timer = setTimeout(
    			() => {
    				functionAfterDebounce();
    			},
    			750
    		);
    	};

    	const onSettingsChanged = () => {
    		localStorage.removeItem("stats");
    		Database.connect();
    		success("Einstellungen gespeichert!", 1500);
    	};

    	const unsubscribe = settingsStore.subscribe(value => {
    		if (prevValue && JSON.stringify(value) !== JSON.stringify(prevValue)) {
    			debounce(onSettingsChanged);
    		}

    		prevValue = JSON.parse(JSON.stringify(value));
    	});

    	onDestroy(unsubscribe);

    	function input0_input_handler() {
    		$settingsStore.couchdbHost = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function checkbox_checked_binding(value) {
    		if ($$self.$$.not_equal($settingsStore.couchdbHTTPS, value)) {
    			$settingsStore.couchdbHTTPS = value;
    			settingsStore.set($settingsStore);
    		}
    	}

    	function input1_input_handler() {
    		$settingsStore.couchdbPort = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function input2_input_handler() {
    		$settingsStore.couchdbUser = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function input3_input_handler() {
    		$settingsStore.couchdbPassword = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function input4_input_handler() {
    		$settingsStore.couchdbName = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function input5_input_handler() {
    		$settingsStore.wcUrl = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function input6_input_handler() {
    		$settingsStore.wcKey = this.value;
    		settingsStore.set($settingsStore);
    	}

    	function input7_input_handler() {
    		$settingsStore.wcSecret = this.value;
    		settingsStore.set($settingsStore);
    	}

    	return [
    		$settingsStore,
    		input0_input_handler,
    		checkbox_checked_binding,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler
    	];
    }

    class SettingsFormular extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$w, create_fragment$x, safe_not_equal, {});
    	}
    }

    /* src/components/Input/ButtonTight.svelte generated by Svelte v3.42.4 */

    function create_fragment$w(ctx) {
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			t = text(/*text*/ ctx[0]);
    			attr(button, "class", "button-tight svelte-jklzts");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { text } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    	};

    	return [text, click_handler];
    }

    class ButtonTight extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$v, create_fragment$w, safe_not_equal, { text: 0 });
    	}
    }

    /* src/components/Input/TextInput.svelte generated by Svelte v3.42.4 */

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i][0];
    	child_ctx[19] = list[i][1];
    	return child_ctx;
    }

    // (47:0) {:else}
    function create_else_block$4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			input = element("input");
    			attr(input, "type", "text");
    			attr(input, "id", /*id*/ ctx[1]);
    			attr(input, "name", /*id*/ ctx[1]);
    			input.readOnly = /*readonly*/ ctx[2];
    			input.disabled = /*disabled*/ ctx[5];
    			input.required = /*required*/ ctx[3];
    			attr(input, "pattern", /*pattern*/ ctx[4]);
    			attr(input, "class", "svelte-15cwqkh");
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);
    			set_input_value(input, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen(input, "input", /*input_input_handler*/ ctx[15]),
    					listen(input, "keydown", keydown_handler),
    					listen(input, "input", /*input_handler_1*/ ctx[16])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*id*/ 2) {
    				attr(input, "id", /*id*/ ctx[1]);
    			}

    			if (dirty & /*id*/ 2) {
    				attr(input, "name", /*id*/ ctx[1]);
    			}

    			if (dirty & /*readonly*/ 4) {
    				input.readOnly = /*readonly*/ ctx[2];
    			}

    			if (dirty & /*disabled*/ 32) {
    				input.disabled = /*disabled*/ ctx[5];
    			}

    			if (dirty & /*required*/ 8) {
    				input.required = /*required*/ ctx[3];
    			}

    			if (dirty & /*pattern*/ 16) {
    				attr(input, "pattern", /*pattern*/ ctx[4]);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (31:0) {#if multiline}
    function create_if_block$6(ctx) {
    	let textarea;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			textarea = element("textarea");
    			attr(textarea, "type", "text");
    			attr(textarea, "id", /*id*/ ctx[1]);
    			attr(textarea, "name", /*id*/ ctx[1]);
    			textarea.readOnly = /*readonly*/ ctx[2];
    			textarea.disabled = /*disabled*/ ctx[5];
    			textarea.required = /*required*/ ctx[3];
    			attr(textarea, "pattern", /*pattern*/ ctx[4]);
    			attr(textarea, "class", "svelte-15cwqkh");
    		},
    		m(target, anchor) {
    			insert(target, textarea, anchor);
    			/*textarea_binding*/ ctx[12](textarea);
    			set_input_value(textarea, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen(textarea, "input", /*textarea_input_handler*/ ctx[13]),
    					listen(textarea, "input", /*input_handler*/ ctx[14])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*id*/ 2) {
    				attr(textarea, "id", /*id*/ ctx[1]);
    			}

    			if (dirty & /*id*/ 2) {
    				attr(textarea, "name", /*id*/ ctx[1]);
    			}

    			if (dirty & /*readonly*/ 4) {
    				textarea.readOnly = /*readonly*/ ctx[2];
    			}

    			if (dirty & /*disabled*/ 32) {
    				textarea.disabled = /*disabled*/ ctx[5];
    			}

    			if (dirty & /*required*/ 8) {
    				textarea.required = /*required*/ ctx[3];
    			}

    			if (dirty & /*pattern*/ 16) {
    				attr(textarea, "pattern", /*pattern*/ ctx[4]);
    			}

    			if (dirty & /*value*/ 1) {
    				set_input_value(textarea, /*value*/ ctx[0]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(textarea);
    			/*textarea_binding*/ ctx[12](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (63:0) {#each Object.entries(quickset) as [target, text]}
    function create_each_block$9(ctx) {
    	let buttontight;
    	let current;

    	function click_handler() {
    		return /*click_handler*/ ctx[17](/*target*/ ctx[18]);
    	}

    	buttontight = new ButtonTight({ props: { text: /*text*/ ctx[19] } });
    	buttontight.$on("click", click_handler);

    	return {
    		c() {
    			create_component(buttontight.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(buttontight, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const buttontight_changes = {};
    			if (dirty & /*quickset*/ 128) buttontight_changes.text = /*text*/ ctx[19];
    			buttontight.$set(buttontight_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(buttontight.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(buttontight.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(buttontight, detaching);
    		}
    	};
    }

    function create_fragment$v(ctx) {
    	let t;
    	let each_1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*multiline*/ ctx[6]) return create_if_block$6;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value = Object.entries(/*quickset*/ ctx[7]);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}

    			if (dirty & /*Object, quickset, value*/ 129) {
    				each_value = Object.entries(/*quickset*/ ctx[7]);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    const keydown_handler = event => event.key === "Enter" ? event.preventDefault() : event;

    function instance$u($$self, $$props, $$invalidate) {
    	let { id = "" } = $$props;
    	let { readonly = false } = $$props;
    	let { value = "" } = $$props;
    	let { required = false } = $$props;
    	let { pattern = null } = $$props;
    	let { disabled = false } = $$props;
    	let { multiline = false } = $$props;
    	let { onlyNumbers = false } = $$props;
    	let { quickset = {} } = $$props;
    	let textAreaRef;
    	const dispatch = createEventDispatcher();

    	const resizeTextArea = () => {
    		if (textAreaRef) {
    			$$invalidate(8, textAreaRef.style.height = "10px", textAreaRef); // for shrinking
    			$$invalidate(8, textAreaRef.style.height = textAreaRef.scrollHeight + "px", textAreaRef);
    		}
    	};

    	onMount(resizeTextArea);

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textAreaRef = $$value;
    			$$invalidate(8, textAreaRef);
    		});
    	}

    	function textarea_input_handler() {
    		value = this.value;
    		($$invalidate(0, value), $$invalidate(11, onlyNumbers));
    	}

    	const input_handler = event => {
    		resizeTextArea();
    		dispatch("change", event.target.value);
    	};

    	function input_input_handler() {
    		value = this.value;
    		($$invalidate(0, value), $$invalidate(11, onlyNumbers));
    	}

    	const input_handler_1 = event => dispatch("change", event.target.value);

    	const click_handler = target => {
    		$$invalidate(0, value = target);
    	};

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('readonly' in $$props) $$invalidate(2, readonly = $$props.readonly);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('required' in $$props) $$invalidate(3, required = $$props.required);
    		if ('pattern' in $$props) $$invalidate(4, pattern = $$props.pattern);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ('multiline' in $$props) $$invalidate(6, multiline = $$props.multiline);
    		if ('onlyNumbers' in $$props) $$invalidate(11, onlyNumbers = $$props.onlyNumbers);
    		if ('quickset' in $$props) $$invalidate(7, quickset = $$props.quickset);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*onlyNumbers, value*/ 2049) {
    			if (onlyNumbers && typeof value !== "number" && value !== "") {
    				$$invalidate(0, value = parseInt(value));
    			}
    		}
    	};

    	return [
    		value,
    		id,
    		readonly,
    		required,
    		pattern,
    		disabled,
    		multiline,
    		quickset,
    		textAreaRef,
    		dispatch,
    		resizeTextArea,
    		onlyNumbers,
    		textarea_binding,
    		textarea_input_handler,
    		input_handler,
    		input_input_handler,
    		input_handler_1,
    		click_handler
    	];
    }

    class TextInput extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$u, create_fragment$v, safe_not_equal, {
    			id: 1,
    			readonly: 2,
    			value: 0,
    			required: 3,
    			pattern: 4,
    			disabled: 5,
    			multiline: 6,
    			onlyNumbers: 11,
    			quickset: 7
    		});
    	}
    }

    /* node_modules/simple-svelte-autocomplete/src/SimpleAutocomplete.svelte generated by Svelte v3.42.4 */

    const get_no_results_slot_changes = dirty => ({
    	noResultsText: dirty[0] & /*noResultsText*/ 2048
    });

    const get_no_results_slot_context = ctx => ({ noResultsText: /*noResultsText*/ ctx[11] });

    const get_create_slot_changes = dirty => ({
    	createText: dirty[0] & /*createText*/ 16384
    });

    const get_create_slot_context = ctx => ({ createText: /*createText*/ ctx[14] });

    const get_loading_slot_changes = dirty => ({
    	loadingText: dirty[0] & /*loadingText*/ 4096
    });

    const get_loading_slot_context = ctx => ({ loadingText: /*loadingText*/ ctx[12] });

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[116] = list[i];
    	child_ctx[118] = i;
    	return child_ctx;
    }

    const get_item_slot_changes = dirty => ({
    	item: dirty[1] & /*filteredListItems*/ 1,
    	label: dirty[1] & /*filteredListItems*/ 1
    });

    const get_item_slot_context = ctx => ({
    	item: /*listItem*/ ctx[116].item,
    	label: /*listItem*/ ctx[116].highlighted
    	? /*listItem*/ ctx[116].highlighted
    	: /*listItem*/ ctx[116].label
    });

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[119] = list[i];
    	return child_ctx;
    }

    const get_tag_slot_changes = dirty => ({
    	label: dirty[0] & /*selectedItem*/ 2,
    	item: dirty[0] & /*selectedItem*/ 2
    });

    const get_tag_slot_context = ctx => ({
    	label: /*safeLabelFunction*/ ctx[38](/*tagItem*/ ctx[119]),
    	item: /*tagItem*/ ctx[119],
    	unselectItem: /*unselectItem*/ ctx[45]
    });

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[118] = list[i];
    	return child_ctx;
    }

    // (1023:39) 
    function create_if_block_11(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*selectedItem*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*valueFunction, selectedItem*/ 18 | dirty[1] & /*safeLabelFunction*/ 128) {
    				each_value_2 = /*selectedItem*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    // (1021:4) {#if !multiple && value}
    function create_if_block_10(ctx) {
    	let option;
    	let t;

    	return {
    		c() {
    			option = element("option");
    			t = text(/*text*/ ctx[3]);
    			option.__value = /*value*/ ctx[2];
    			option.value = option.__value;
    			option.selected = true;
    			attr(option, "class", "svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*text*/ 8) set_data(t, /*text*/ ctx[3]);

    			if (dirty[0] & /*value*/ 4) {
    				option.__value = /*value*/ ctx[2];
    				option.value = option.__value;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(option);
    		}
    	};
    }

    // (1024:6) {#each selectedItem as i}
    function create_each_block_2(ctx) {
    	let option;
    	let t0_value = /*safeLabelFunction*/ ctx[38](/*i*/ ctx[118]) + "";
    	let t0;
    	let t1;
    	let option_value_value;

    	return {
    		c() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			option.__value = option_value_value = /*valueFunction*/ ctx[4](/*i*/ ctx[118], true);
    			option.value = option.__value;
    			option.selected = true;
    			attr(option, "class", "svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t0);
    			append(option, t1);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*selectedItem*/ 2 && t0_value !== (t0_value = /*safeLabelFunction*/ ctx[38](/*i*/ ctx[118]) + "")) set_data(t0, t0_value);

    			if (dirty[0] & /*valueFunction, selectedItem*/ 18 && option_value_value !== (option_value_value = /*valueFunction*/ ctx[4](/*i*/ ctx[118], true))) {
    				option.__value = option_value_value;
    				option.value = option.__value;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(option);
    		}
    	};
    }

    // (1032:4) {#if multiple && selectedItem}
    function create_if_block_9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*selectedItem*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*selectedItem*/ 2 | dirty[1] & /*unselectItem, safeLabelFunction*/ 16512 | dirty[2] & /*$$scope*/ 1048576) {
    				each_value_1 = /*selectedItem*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    // (1034:90)            
    function fallback_block_4(ctx) {
    	let div;
    	let span0;
    	let t0_value = /*safeLabelFunction*/ ctx[38](/*tagItem*/ ctx[119]) + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = space();
    			attr(span0, "class", "tag svelte-1nqq7zl");
    			attr(span1, "class", "tag is-delete svelte-1nqq7zl");
    			attr(div, "class", "tags has-addons svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span0);
    			append(span0, t0);
    			append(div, t1);
    			append(div, span1);
    			insert(target, t2, anchor);

    			if (!mounted) {
    				dispose = listen(span1, "click", prevent_default(function () {
    					if (is_function(/*unselectItem*/ ctx[45](/*tagItem*/ ctx[119]))) /*unselectItem*/ ctx[45](/*tagItem*/ ctx[119]).apply(this, arguments);
    				}));

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*selectedItem*/ 2 && t0_value !== (t0_value = /*safeLabelFunction*/ ctx[38](/*tagItem*/ ctx[119]) + "")) set_data(t0, t0_value);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (detaching) detach(t2);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (1033:6) {#each selectedItem as tagItem}
    function create_each_block_1$1(ctx) {
    	let current;
    	const tag_slot_template = /*#slots*/ ctx[83].tag;
    	const tag_slot = create_slot(tag_slot_template, ctx, /*$$scope*/ ctx[82], get_tag_slot_context);
    	const tag_slot_or_fallback = tag_slot || fallback_block_4(ctx);

    	return {
    		c() {
    			if (tag_slot_or_fallback) tag_slot_or_fallback.c();
    		},
    		m(target, anchor) {
    			if (tag_slot_or_fallback) {
    				tag_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (tag_slot) {
    				if (tag_slot.p && (!current || dirty[0] & /*selectedItem*/ 2 | dirty[2] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						tag_slot,
    						tag_slot_template,
    						ctx,
    						/*$$scope*/ ctx[82],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[82])
    						: get_slot_changes(tag_slot_template, /*$$scope*/ ctx[82], dirty, get_tag_slot_changes),
    						get_tag_slot_context
    					);
    				}
    			} else {
    				if (tag_slot_or_fallback && tag_slot_or_fallback.p && (!current || dirty[0] & /*selectedItem*/ 2)) {
    					tag_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(tag_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(tag_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (tag_slot_or_fallback) tag_slot_or_fallback.d(detaching);
    		}
    	};
    }

    // (1065:4) {#if clearable}
    function create_if_block_8(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			span = element("span");
    			span.textContent = "✖";
    			attr(span, "class", "autocomplete-clear-button svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);

    			if (!mounted) {
    				dispose = listen(span, "click", /*clear*/ ctx[49]);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(span);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (1116:28) 
    function create_if_block_7(ctx) {
    	let div;
    	let current;
    	const no_results_slot_template = /*#slots*/ ctx[83]["no-results"];
    	const no_results_slot = create_slot(no_results_slot_template, ctx, /*$$scope*/ ctx[82], get_no_results_slot_context);
    	const no_results_slot_or_fallback = no_results_slot || fallback_block_3(ctx);

    	return {
    		c() {
    			div = element("div");
    			if (no_results_slot_or_fallback) no_results_slot_or_fallback.c();
    			attr(div, "class", "autocomplete-list-item-no-results svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (no_results_slot_or_fallback) {
    				no_results_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (no_results_slot) {
    				if (no_results_slot.p && (!current || dirty[0] & /*noResultsText*/ 2048 | dirty[2] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						no_results_slot,
    						no_results_slot_template,
    						ctx,
    						/*$$scope*/ ctx[82],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[82])
    						: get_slot_changes(no_results_slot_template, /*$$scope*/ ctx[82], dirty, get_no_results_slot_changes),
    						get_no_results_slot_context
    					);
    				}
    			} else {
    				if (no_results_slot_or_fallback && no_results_slot_or_fallback.p && (!current || dirty[0] & /*noResultsText*/ 2048)) {
    					no_results_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(no_results_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(no_results_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (no_results_slot_or_fallback) no_results_slot_or_fallback.d(detaching);
    		}
    	};
    }

    // (1112:21) 
    function create_if_block_6(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const create_slot_template = /*#slots*/ ctx[83].create;
    	const create_slot_1 = create_slot(create_slot_template, ctx, /*$$scope*/ ctx[82], get_create_slot_context);
    	const create_slot_or_fallback = create_slot_1 || fallback_block_2(ctx);

    	return {
    		c() {
    			div = element("div");
    			if (create_slot_or_fallback) create_slot_or_fallback.c();
    			attr(div, "class", "autocomplete-list-item-create svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (create_slot_or_fallback) {
    				create_slot_or_fallback.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen(div, "click", /*selectItem*/ ctx[39]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (create_slot_1) {
    				if (create_slot_1.p && (!current || dirty[0] & /*createText*/ 16384 | dirty[2] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						create_slot_1,
    						create_slot_template,
    						ctx,
    						/*$$scope*/ ctx[82],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[82])
    						: get_slot_changes(create_slot_template, /*$$scope*/ ctx[82], dirty, get_create_slot_changes),
    						get_create_slot_context
    					);
    				}
    			} else {
    				if (create_slot_or_fallback && create_slot_or_fallback.p && (!current || dirty[0] & /*createText*/ 16384)) {
    					create_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(create_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(create_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (create_slot_or_fallback) create_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (1108:37) 
    function create_if_block_5(ctx) {
    	let div;
    	let current;
    	const loading_slot_template = /*#slots*/ ctx[83].loading;
    	const loading_slot = create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[82], get_loading_slot_context);
    	const loading_slot_or_fallback = loading_slot || fallback_block_1(ctx);

    	return {
    		c() {
    			div = element("div");
    			if (loading_slot_or_fallback) loading_slot_or_fallback.c();
    			attr(div, "class", "autocomplete-list-item-loading svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (loading_slot_or_fallback) {
    				loading_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (loading_slot) {
    				if (loading_slot.p && (!current || dirty[0] & /*loadingText*/ 4096 | dirty[2] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						loading_slot,
    						loading_slot_template,
    						ctx,
    						/*$$scope*/ ctx[82],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[82])
    						: get_slot_changes(loading_slot_template, /*$$scope*/ ctx[82], dirty, get_loading_slot_changes),
    						get_loading_slot_context
    					);
    				}
    			} else {
    				if (loading_slot_or_fallback && loading_slot_or_fallback.p && (!current || dirty[0] & /*loadingText*/ 4096)) {
    					loading_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(loading_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(loading_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (loading_slot_or_fallback) loading_slot_or_fallback.d(detaching);
    		}
    	};
    }

    // (1074:4) {#if filteredListItems && filteredListItems.length > 0}
    function create_if_block$5(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;
    	let each_value = /*filteredListItems*/ ctx[31];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = /*maxItemsToShowInList*/ ctx[5] > 0 && /*filteredListItems*/ ctx[31].length > /*maxItemsToShowInList*/ ctx[5] && create_if_block_1$2(ctx);

    	return {
    		c() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*highlightIndex, maxItemsToShowInList*/ 1073741856 | dirty[1] & /*isConfirmed, filteredListItems, onListItemClick*/ 524801 | dirty[2] & /*$$scope*/ 1048576) {
    				each_value = /*filteredListItems*/ ctx[31];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*maxItemsToShowInList*/ ctx[5] > 0 && /*filteredListItems*/ ctx[31].length > /*maxItemsToShowInList*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (1118:48) {noResultsText}
    function fallback_block_3(ctx) {
    	let t;

    	return {
    		c() {
    			t = text(/*noResultsText*/ ctx[11]);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*noResultsText*/ 2048) set_data(t, /*noResultsText*/ ctx[11]);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (1114:41) {createText}
    function fallback_block_2(ctx) {
    	let t;

    	return {
    		c() {
    			t = text(/*createText*/ ctx[14]);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*createText*/ 16384) set_data(t, /*createText*/ ctx[14]);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (1110:43) {loadingText}
    function fallback_block_1(ctx) {
    	let t;

    	return {
    		c() {
    			t = text(/*loadingText*/ ctx[12]);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*loadingText*/ 4096) set_data(t, /*loadingText*/ ctx[12]);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (1076:8) {#if listItem && (maxItemsToShowInList <= 0 || i < maxItemsToShowInList)}
    function create_if_block_3(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const item_slot_template = /*#slots*/ ctx[83].item;
    	const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ ctx[82], get_item_slot_context);
    	const item_slot_or_fallback = item_slot || fallback_block$1(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[86](/*listItem*/ ctx[116]);
    	}

    	function pointerenter_handler() {
    		return /*pointerenter_handler*/ ctx[87](/*i*/ ctx[118]);
    	}

    	return {
    		c() {
    			div = element("div");
    			if (item_slot_or_fallback) item_slot_or_fallback.c();

    			attr(div, "class", div_class_value = "autocomplete-list-item " + (/*i*/ ctx[118] === /*highlightIndex*/ ctx[30]
    			? 'selected'
    			: '') + " svelte-1nqq7zl");

    			toggle_class(div, "confirmed", /*isConfirmed*/ ctx[50](/*listItem*/ ctx[116].item));
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (item_slot_or_fallback) {
    				item_slot_or_fallback.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div, "click", click_handler),
    					listen(div, "pointerenter", pointerenter_handler)
    				];

    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (item_slot) {
    				if (item_slot.p && (!current || dirty[1] & /*filteredListItems*/ 1 | dirty[2] & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						item_slot,
    						item_slot_template,
    						ctx,
    						/*$$scope*/ ctx[82],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[82])
    						: get_slot_changes(item_slot_template, /*$$scope*/ ctx[82], dirty, get_item_slot_changes),
    						get_item_slot_context
    					);
    				}
    			} else {
    				if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[1] & /*filteredListItems*/ 1)) {
    					item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
    				}
    			}

    			if (!current || dirty[0] & /*highlightIndex*/ 1073741824 && div_class_value !== (div_class_value = "autocomplete-list-item " + (/*i*/ ctx[118] === /*highlightIndex*/ ctx[30]
    			? 'selected'
    			: '') + " svelte-1nqq7zl")) {
    				attr(div, "class", div_class_value);
    			}

    			if (dirty[0] & /*highlightIndex*/ 1073741824 | dirty[1] & /*isConfirmed, filteredListItems*/ 524289) {
    				toggle_class(div, "confirmed", /*isConfirmed*/ ctx[50](/*listItem*/ ctx[116].item));
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(item_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(item_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (1092:14) {:else}
    function create_else_block$3(ctx) {
    	let html_tag;
    	let raw_value = /*listItem*/ ctx[116].label + "";
    	let html_anchor;

    	return {
    		c() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert(target, html_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[1] & /*filteredListItems*/ 1 && raw_value !== (raw_value = /*listItem*/ ctx[116].label + "")) html_tag.p(raw_value);
    		},
    		d(detaching) {
    			if (detaching) detach(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};
    }

    // (1090:14) {#if listItem.highlighted}
    function create_if_block_4(ctx) {
    	let html_tag;
    	let raw_value = /*listItem*/ ctx[116].highlighted + "";
    	let html_anchor;

    	return {
    		c() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert(target, html_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[1] & /*filteredListItems*/ 1 && raw_value !== (raw_value = /*listItem*/ ctx[116].highlighted + "")) html_tag.p(raw_value);
    		},
    		d(detaching) {
    			if (detaching) detach(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};
    }

    // (1089:13)                
    function fallback_block$1(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*listItem*/ ctx[116].highlighted) return create_if_block_4;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (1075:6) {#each filteredListItems as listItem, i}
    function create_each_block$8(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*listItem*/ ctx[116] && (/*maxItemsToShowInList*/ ctx[5] <= 0 || /*i*/ ctx[118] < /*maxItemsToShowInList*/ ctx[5]) && create_if_block_3(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (/*listItem*/ ctx[116] && (/*maxItemsToShowInList*/ ctx[5] <= 0 || /*i*/ ctx[118] < /*maxItemsToShowInList*/ ctx[5])) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*maxItemsToShowInList*/ 32 | dirty[1] & /*filteredListItems*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (1100:6) {#if maxItemsToShowInList > 0 && filteredListItems.length > maxItemsToShowInList}
    function create_if_block_1$2(ctx) {
    	let if_block_anchor;
    	let if_block = /*moreItemsText*/ ctx[13] && create_if_block_2$1(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (/*moreItemsText*/ ctx[13]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (1101:8) {#if moreItemsText}
    function create_if_block_2$1(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*filteredListItems*/ ctx[31].length - /*maxItemsToShowInList*/ ctx[5] + "";
    	let t1;
    	let t2;
    	let t3;

    	return {
    		c() {
    			div = element("div");
    			t0 = text("...");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(/*moreItemsText*/ ctx[13]);
    			attr(div, "class", "autocomplete-list-item-no-results svelte-1nqq7zl");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, t0);
    			append(div, t1);
    			append(div, t2);
    			append(div, t3);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*maxItemsToShowInList*/ 32 | dirty[1] & /*filteredListItems*/ 1 && t1_value !== (t1_value = /*filteredListItems*/ ctx[31].length - /*maxItemsToShowInList*/ ctx[5] + "")) set_data(t1, t1_value);
    			if (dirty[0] & /*moreItemsText*/ 8192) set_data(t3, /*moreItemsText*/ ctx[13]);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function create_fragment$u(ctx) {
    	let div2;
    	let select;
    	let t0;
    	let div0;
    	let t1;
    	let input_1;
    	let input_1_class_value;
    	let input_1_id_value;
    	let input_1_autocomplete_value;
    	let input_1_readonly_value;
    	let t2;
    	let t3;
    	let div1;
    	let current_block_type_index;
    	let if_block3;
    	let div1_class_value;
    	let div2_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (!/*multiple*/ ctx[6] && /*value*/ ctx[2]) return create_if_block_10;
    		if (/*multiple*/ ctx[6] && /*selectedItem*/ ctx[1]) return create_if_block_11;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type && current_block_type(ctx);
    	let if_block1 = /*multiple*/ ctx[6] && /*selectedItem*/ ctx[1] && create_if_block_9(ctx);
    	let if_block2 = /*clearable*/ ctx[35] && create_if_block_8(ctx);
    	const if_block_creators = [create_if_block$5, create_if_block_5, create_if_block_6, create_if_block_7];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*filteredListItems*/ ctx[31] && /*filteredListItems*/ ctx[31].length > 0) return 0;
    		if (/*loading*/ ctx[34] && /*loadingText*/ ctx[12]) return 1;
    		if (/*create*/ ctx[7]) return 2;
    		if (/*noResultsText*/ ctx[11]) return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c() {
    			div2 = element("div");
    			select = element("select");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			input_1 = element("input");
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div1 = element("div");
    			if (if_block3) if_block3.c();
    			attr(select, "name", /*selectName*/ ctx[20]);
    			attr(select, "id", /*selectId*/ ctx[21]);
    			select.multiple = /*multiple*/ ctx[6];
    			attr(select, "class", "svelte-1nqq7zl");
    			attr(input_1, "type", "text");

    			attr(input_1, "class", input_1_class_value = "" + ((/*inputClassName*/ ctx[17]
    			? /*inputClassName*/ ctx[17]
    			: '') + " " + (/*noInputStyles*/ ctx[27]
    			? ''
    			: 'input autocomplete-input') + " svelte-1nqq7zl"));

    			attr(input_1, "id", input_1_id_value = /*inputId*/ ctx[18] ? /*inputId*/ ctx[18] : "");
    			attr(input_1, "autocomplete", input_1_autocomplete_value = /*html5autocomplete*/ ctx[23] ? "on" : "off");
    			attr(input_1, "placeholder", /*placeholder*/ ctx[15]);
    			attr(input_1, "name", /*name*/ ctx[19]);
    			input_1.disabled = /*disabled*/ ctx[26];
    			input_1.required = /*required*/ ctx[28];
    			attr(input_1, "title", /*title*/ ctx[22]);
    			input_1.readOnly = input_1_readonly_value = /*readonly*/ ctx[24] || /*lock*/ ctx[8] && /*selectedItem*/ ctx[1];
    			attr(input_1, "tabindex", /*tabindex*/ ctx[29]);
    			attr(div0, "class", "input-container svelte-1nqq7zl");

    			attr(div1, "class", div1_class_value = "" + ((/*dropdownClassName*/ ctx[25]
    			? /*dropdownClassName*/ ctx[25]
    			: '') + " autocomplete-list " + (/*showList*/ ctx[36] ? '' : 'hidden') + " is-fullwidth" + " svelte-1nqq7zl"));

    			attr(div2, "class", div2_class_value = "" + ((/*className*/ ctx[16] ? /*className*/ ctx[16] : '') + " " + (/*hideArrow*/ ctx[9] || !/*items*/ ctx[0].length
    			? 'hide-arrow'
    			: '') + " " + (/*multiple*/ ctx[6] ? 'is-multiple' : '') + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[37] + " svelte-1nqq7zl"));

    			toggle_class(div2, "show-clear", /*clearable*/ ctx[35]);
    			toggle_class(div2, "is-loading", /*showLoadingIndicator*/ ctx[10] && /*loading*/ ctx[34]);
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, select);
    			if (if_block0) if_block0.m(select, null);
    			append(div2, t0);
    			append(div2, div0);
    			if (if_block1) if_block1.m(div0, null);
    			append(div0, t1);
    			append(div0, input_1);
    			/*input_1_binding*/ ctx[84](input_1);
    			set_input_value(input_1, /*text*/ ctx[3]);
    			append(div0, t2);
    			if (if_block2) if_block2.m(div0, null);
    			append(div2, t3);
    			append(div2, div1);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div1, null);
    			}

    			/*div1_binding*/ ctx[88](div1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window, "click", /*onDocumentClick*/ ctx[41]),
    					listen(input_1, "input", /*input_1_input_handler*/ ctx[85]),
    					listen(input_1, "input", /*onInput*/ ctx[44]),
    					listen(input_1, "focus", /*onFocusInternal*/ ctx[47]),
    					listen(input_1, "blur", /*onBlurInternal*/ ctx[48]),
    					listen(input_1, "keydown", /*onKeyDown*/ ctx[42]),
    					listen(input_1, "click", /*onInputClick*/ ctx[46]),
    					listen(input_1, "keypress", /*onKeyPress*/ ctx[43])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if (if_block0) if_block0.d(1);
    				if_block0 = current_block_type && current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(select, null);
    				}
    			}

    			if (!current || dirty[0] & /*selectName*/ 1048576) {
    				attr(select, "name", /*selectName*/ ctx[20]);
    			}

    			if (!current || dirty[0] & /*selectId*/ 2097152) {
    				attr(select, "id", /*selectId*/ ctx[21]);
    			}

    			if (!current || dirty[0] & /*multiple*/ 64) {
    				select.multiple = /*multiple*/ ctx[6];
    			}

    			if (/*multiple*/ ctx[6] && /*selectedItem*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*multiple, selectedItem*/ 66) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*inputClassName, noInputStyles*/ 134348800 && input_1_class_value !== (input_1_class_value = "" + ((/*inputClassName*/ ctx[17]
    			? /*inputClassName*/ ctx[17]
    			: '') + " " + (/*noInputStyles*/ ctx[27]
    			? ''
    			: 'input autocomplete-input') + " svelte-1nqq7zl"))) {
    				attr(input_1, "class", input_1_class_value);
    			}

    			if (!current || dirty[0] & /*inputId*/ 262144 && input_1_id_value !== (input_1_id_value = /*inputId*/ ctx[18] ? /*inputId*/ ctx[18] : "")) {
    				attr(input_1, "id", input_1_id_value);
    			}

    			if (!current || dirty[0] & /*html5autocomplete*/ 8388608 && input_1_autocomplete_value !== (input_1_autocomplete_value = /*html5autocomplete*/ ctx[23] ? "on" : "off")) {
    				attr(input_1, "autocomplete", input_1_autocomplete_value);
    			}

    			if (!current || dirty[0] & /*placeholder*/ 32768) {
    				attr(input_1, "placeholder", /*placeholder*/ ctx[15]);
    			}

    			if (!current || dirty[0] & /*name*/ 524288) {
    				attr(input_1, "name", /*name*/ ctx[19]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 67108864) {
    				input_1.disabled = /*disabled*/ ctx[26];
    			}

    			if (!current || dirty[0] & /*required*/ 268435456) {
    				input_1.required = /*required*/ ctx[28];
    			}

    			if (!current || dirty[0] & /*title*/ 4194304) {
    				attr(input_1, "title", /*title*/ ctx[22]);
    			}

    			if (!current || dirty[0] & /*readonly, lock, selectedItem*/ 16777474 && input_1_readonly_value !== (input_1_readonly_value = /*readonly*/ ctx[24] || /*lock*/ ctx[8] && /*selectedItem*/ ctx[1])) {
    				input_1.readOnly = input_1_readonly_value;
    			}

    			if (!current || dirty[0] & /*tabindex*/ 536870912) {
    				attr(input_1, "tabindex", /*tabindex*/ ctx[29]);
    			}

    			if (dirty[0] & /*text*/ 8 && input_1.value !== /*text*/ ctx[3]) {
    				set_input_value(input_1, /*text*/ ctx[3]);
    			}

    			if (/*clearable*/ ctx[35]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_8(ctx);
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block3) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block3 = if_blocks[current_block_type_index];

    					if (!if_block3) {
    						if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block3.c();
    					} else {
    						if_block3.p(ctx, dirty);
    					}

    					transition_in(if_block3, 1);
    					if_block3.m(div1, null);
    				} else {
    					if_block3 = null;
    				}
    			}

    			if (!current || dirty[0] & /*dropdownClassName*/ 33554432 | dirty[1] & /*showList*/ 32 && div1_class_value !== (div1_class_value = "" + ((/*dropdownClassName*/ ctx[25]
    			? /*dropdownClassName*/ ctx[25]
    			: '') + " autocomplete-list " + (/*showList*/ ctx[36] ? '' : 'hidden') + " is-fullwidth" + " svelte-1nqq7zl"))) {
    				attr(div1, "class", div1_class_value);
    			}

    			if (!current || dirty[0] & /*className, hideArrow, items, multiple*/ 66113 && div2_class_value !== (div2_class_value = "" + ((/*className*/ ctx[16] ? /*className*/ ctx[16] : '') + " " + (/*hideArrow*/ ctx[9] || !/*items*/ ctx[0].length
    			? 'hide-arrow'
    			: '') + " " + (/*multiple*/ ctx[6] ? 'is-multiple' : '') + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[37] + " svelte-1nqq7zl"))) {
    				attr(div2, "class", div2_class_value);
    			}

    			if (dirty[0] & /*className, hideArrow, items, multiple*/ 66113 | dirty[1] & /*clearable*/ 16) {
    				toggle_class(div2, "show-clear", /*clearable*/ ctx[35]);
    			}

    			if (dirty[0] & /*className, hideArrow, items, multiple, showLoadingIndicator*/ 67137 | dirty[1] & /*loading*/ 8) {
    				toggle_class(div2, "is-loading", /*showLoadingIndicator*/ ctx[10] && /*loading*/ ctx[34]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block3);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block1);
    			transition_out(if_block3);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);

    			if (if_block0) {
    				if_block0.d();
    			}

    			if (if_block1) if_block1.d();
    			/*input_1_binding*/ ctx[84](null);
    			if (if_block2) if_block2.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			/*div1_binding*/ ctx[88](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function safeFunction(theFunction, argument) {
    	if (typeof theFunction !== "function") {
    		console.error("Not a function: " + theFunction + ", argument: " + argument);
    		return undefined;
    	}

    	let result;

    	try {
    		result = theFunction(argument);
    	} catch(error) {
    		console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
    	}

    	return result;
    }

    function safeStringFunction(theFunction, argument) {
    	let result = safeFunction(theFunction, argument);

    	if (result === undefined || result === null) {
    		result = "";
    	}

    	if (typeof result !== "string") {
    		result = result.toString();
    	}

    	return result;
    }

    function numberOfMatches(listItem, searchWords) {
    	if (!listItem) {
    		return 0;
    	}

    	const itemKeywords = listItem.keywords;
    	let matches = 0;

    	searchWords.forEach(searchWord => {
    		if (itemKeywords.includes(searchWord)) {
    			matches++;
    		}
    	});

    	return matches;
    }

    function defaultItemSortFunction(obj1, obj2, searchWords) {
    	return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
    }

    function removeAccents(str) {
    	return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let showList;
    	let clearable;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { items = [] } = $$props;
    	let { searchFunction = false } = $$props;
    	let { labelFieldName = undefined } = $$props;
    	let { keywordsFieldName = labelFieldName } = $$props;
    	let { valueFieldName = undefined } = $$props;

    	let { labelFunction = function (item) {
    		if (item === undefined || item === null) {
    			return "";
    		}

    		return labelFieldName ? item[labelFieldName] : item;
    	} } = $$props;

    	let { keywordsFunction = function (item) {
    		if (item === undefined || item === null) {
    			return "";
    		}

    		return keywordsFieldName
    		? item[keywordsFieldName]
    		: labelFunction(item);
    	} } = $$props;

    	let { valueFunction = function (item, forceSingle = false) {
    		if (item === undefined || item === null) {
    			return item;
    		}

    		if (!multiple || forceSingle) {
    			return valueFieldName ? item[valueFieldName] : item;
    		} else {
    			return item.map(i => valueFieldName ? i[valueFieldName] : i);
    		}
    	} } = $$props;

    	let { keywordsCleanFunction = function (keywords) {
    		return keywords;
    	} } = $$props;

    	let { textCleanFunction = function (userEnteredText) {
    		return userEnteredText;
    	} } = $$props;

    	let { beforeChange = function (oldSelectedItem, newSelectedItem) {
    		return true;
    	} } = $$props;

    	let { onChange = function (newSelectedItem) {
    		
    	} } = $$props;

    	let { onFocus = function () {
    		
    	} } = $$props;

    	let { onBlur = function () {
    		
    	} } = $$props;

    	let { onCreate = function (text) {
    		if (debug) {
    			console.log("onCreate: " + text);
    		}
    	} } = $$props;

    	let { selectFirstIfEmpty = false } = $$props;
    	let { minCharactersToSearch = 1 } = $$props;
    	let { maxItemsToShowInList = 0 } = $$props;
    	let { multiple = false } = $$props;
    	let { create = false } = $$props;
    	let { ignoreAccents = true } = $$props;
    	let { matchAllKeywords = true } = $$props;
    	let { sortByMatchedKeywords = false } = $$props;
    	let { itemFilterFunction = undefined } = $$props;
    	let { itemSortFunction = undefined } = $$props;
    	let { lock = false } = $$props;
    	let { delay = 0 } = $$props;
    	let { localFiltering = true } = $$props;
    	let { localSorting = true } = $$props;
    	let { cleanUserText = true } = $$props;
    	let { closeOnBlur = false } = $$props;
    	let { hideArrow = false } = $$props;
    	let { showClear = false } = $$props;
    	let { showLoadingIndicator = false } = $$props;
    	let { noResultsText = "No results found" } = $$props;
    	let { loadingText = "Loading results..." } = $$props;
    	let { moreItemsText = "items not shown" } = $$props;
    	let { createText = "Not found, add anyway?" } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { inputClassName = undefined } = $$props;
    	let { inputId = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { selectName = undefined } = $$props;
    	let { selectId = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { html5autocomplete = undefined } = $$props;
    	let { readonly = undefined } = $$props;
    	let { dropdownClassName = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let { noInputStyles = false } = $$props;
    	let { required = null } = $$props;
    	let { debug = false } = $$props;
    	let { tabindex = 0 } = $$props;
    	let { selectedItem = multiple ? [] : undefined } = $$props;
    	let { value = undefined } = $$props;
    	let { highlightedItem = undefined } = $$props;

    	// --- Internal State ----
    	const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);

    	// HTML elements
    	let input;

    	let list;

    	// UI state
    	let opened = false;

    	let loading = false;
    	let highlightIndex = -1;
    	let { text } = $$props;
    	let filteredTextLength = 0;

    	// view model
    	let filteredListItems;

    	let listItems = [];

    	// requests/responses counters
    	let lastRequestId = 0;

    	let lastResponseId = 0;

    	// other state
    	let inputDelayTimeout;

    	function safeLabelFunction(item) {
    		// console.log("labelFunction: " + labelFunction);
    		// console.log("safeLabelFunction, item: " + item);
    		return safeStringFunction(labelFunction, item);
    	}

    	function safeKeywordsFunction(item) {
    		// console.log("safeKeywordsFunction");
    		const keywords = safeStringFunction(keywordsFunction, item);

    		let result = safeStringFunction(keywordsCleanFunction, keywords);
    		result = result.toLowerCase().trim();

    		if (ignoreAccents) {
    			result = removeAccents(result);
    		}

    		if (debug) {
    			console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
    		}

    		return result;
    	}

    	function prepareListItems() {
    		let timerId;

    		if (debug) {
    			timerId = `Autocomplete prepare list ${inputId ? `(id: ${inputId})` : ""}`;
    			console.time(timerId);
    			console.log("Prepare items to search");
    			console.log("items: " + JSON.stringify(items));
    		}

    		if (!Array.isArray(items)) {
    			console.warn("Autocomplete items / search function did not return array but", items);
    			$$invalidate(0, items = []);
    		}

    		const length = items ? items.length : 0;
    		listItems = new Array(length);

    		if (length > 0) {
    			items.forEach((item, i) => {
    				const listItem = getListItem(item);

    				if (listItem === undefined) {
    					console.log("Undefined item for: ", item);
    				}

    				listItems[i] = listItem;
    			});
    		}

    		$$invalidate(31, filteredListItems = listItems);

    		if (debug) {
    			console.log(listItems.length + " items to search");
    			console.timeEnd(timerId);
    		}
    	}

    	function getListItem(item) {
    		return {
    			// keywords representation of the item
    			keywords: localFiltering ? safeKeywordsFunction(item) : [],
    			// item label
    			label: safeLabelFunction(item),
    			// store reference to the origial item
    			item
    		};
    	}

    	function onSelectedItemChanged() {
    		$$invalidate(2, value = valueFunction(selectedItem));
    		$$invalidate(3, text = !multiple ? safeLabelFunction(selectedItem) : "");
    		$$invalidate(31, filteredListItems = listItems);
    		onChange(selectedItem);
    	}

    	function prepareUserEnteredText(userEnteredText) {
    		if (userEnteredText === undefined || userEnteredText === null) {
    			return "";
    		}

    		if (!cleanUserText) {
    			return userEnteredText;
    		}

    		const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
    		const cleanUserEnteredText = safeStringFunction(textCleanFunction, textFiltered);
    		const textFilteredLowerCase = cleanUserEnteredText.toLowerCase().trim();
    		return textFilteredLowerCase;
    	}

    	async function search() {
    		let timerId;

    		if (debug) {
    			timerId = `Autocomplete search ${inputId ? `(id: ${inputId})` : ""}`;
    			console.time(timerId);
    			console.log("Searching user entered text: '" + text + "'");
    		}

    		let textFiltered = prepareUserEnteredText(text);

    		if (minCharactersToSearch > 1 && textFiltered.length < minCharactersToSearch) {
    			textFiltered = "";
    		}

    		$$invalidate(81, filteredTextLength = textFiltered.length);

    		if (debug) {
    			console.log("Changed user entered text '" + text + "' into '" + textFiltered + "'");
    		}

    		// if no search text load all items
    		if (textFiltered === "") {
    			if (searchFunction) {
    				// we will need to rerun the search
    				$$invalidate(0, items = []);

    				if (debug) {
    					console.log("User entered text is empty clear list of items");
    				}
    			} else {
    				$$invalidate(31, filteredListItems = listItems);

    				if (debug) {
    					console.log("User entered text is empty set the list of items to all items");
    				}
    			}

    			closeIfMinCharsToSearchReached();

    			if (debug) {
    				console.timeEnd(timerId);
    			}

    			return;
    		}

    		if (!searchFunction) {
    			// internal search
    			processListItems(textFiltered);
    		} else {
    			// external search which provides items
    			lastRequestId = lastRequestId + 1;

    			const currentRequestId = lastRequestId;
    			$$invalidate(34, loading = true);

    			// searchFunction is a generator
    			if (searchFunction.constructor.name === "AsyncGeneratorFunction") {
    				for await (const chunk of searchFunction(textFiltered, maxItemsToShowInList)) {
    					// a chunk of an old response: throw it away
    					if (currentRequestId < lastResponseId) {
    						return false;
    					}

    					// a chunk for a new response: reset the item list
    					if (currentRequestId > lastResponseId) {
    						$$invalidate(0, items = []);
    					}

    					lastResponseId = currentRequestId;
    					$$invalidate(0, items = [...items, ...chunk]);
    					processListItems(textFiltered);
    				}

    				// there was nothing in the chunk
    				if (lastResponseId < currentRequestId) {
    					lastResponseId = currentRequestId;
    					$$invalidate(0, items = []);
    					processListItems(textFiltered);
    				}
    			} else // searchFunction is a regular function
    			{
    				let result = await searchFunction(textFiltered, maxItemsToShowInList);

    				// If a response to a newer request has been received
    				// while responses to this request were being loaded,
    				// then we can just throw away this outdated results.
    				if (currentRequestId < lastResponseId) {
    					return false;
    				}

    				lastResponseId = currentRequestId;
    				$$invalidate(0, items = result);
    				processListItems(textFiltered);
    			}

    			$$invalidate(34, loading = false);
    		}

    		if (debug) {
    			console.timeEnd(timerId);
    			console.log("Search found " + filteredListItems.length + " items");
    		}
    	}

    	function defaultItemFilterFunction(listItem, searchWords) {
    		const matches = numberOfMatches(listItem, searchWords);

    		if (matchAllKeywords) {
    			return matches >= searchWords.length;
    		} else {
    			return matches > 0;
    		}
    	}

    	function processListItems(textFiltered) {
    		// cleans, filters, orders, and highlights the list items
    		prepareListItems();

    		const textFilteredWithoutAccents = ignoreAccents
    		? removeAccents(textFiltered)
    		: textFiltered;

    		const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter(word => word !== "");

    		// local search
    		let tempfilteredListItems;

    		if (localFiltering) {
    			if (itemFilterFunction) {
    				tempfilteredListItems = listItems.filter(item => itemFilterFunction(item.item, searchWords));
    			} else {
    				tempfilteredListItems = listItems.filter(item => defaultItemFilterFunction(item, searchWords));
    			}

    			if (localSorting) {
    				if (itemSortFunction) {
    					tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction(item1.item, item2.item, searchWords));
    				} else {
    					if (sortByMatchedKeywords) {
    						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
    					}
    				}
    			}
    		} else {
    			tempfilteredListItems = listItems;
    		}

    		const hlfilter = highlightFilter(searchWords, "label");
    		$$invalidate(31, filteredListItems = tempfilteredListItems.map(hlfilter));
    		closeIfMinCharsToSearchReached();
    		return true;
    	}

    	// $: text, search();
    	function afterCreate(createdItem) {
    		let listItem;

    		if (debug) {
    			console.log("createdItem", createdItem);
    		}

    		if ("undefined" !== typeof createdItem) {
    			prepareListItems();
    			$$invalidate(31, filteredListItems = listItems);
    			let index = findItemIndex(createdItem, filteredListItems);

    			// if the items array was not updated, add the created item manually
    			if (index <= 0) {
    				$$invalidate(0, items = [createdItem]);
    				prepareListItems();
    				$$invalidate(31, filteredListItems = listItems);
    				index = 0;
    			}

    			if (index >= 0) {
    				$$invalidate(30, highlightIndex = index);
    				listItem = filteredListItems[highlightIndex];
    			}
    		}

    		return listItem;
    	}

    	function selectListItem(listItem) {
    		if (debug) {
    			console.log("selectListItem", listItem);
    		}

    		if ("undefined" === typeof listItem && create) {
    			// allow undefined items if create is enabled
    			const createdItem = onCreate(text);

    			if ("undefined" !== typeof createdItem) {
    				if (typeof createdItem.then === "function") {
    					createdItem.then(newItem => {
    						if ("undefined" !== typeof newItem) {
    							const newListItem = afterCreate(newItem);

    							if ("undefined" !== typeof newListItem) {
    								selectListItem(newListItem);
    							}
    						}
    					});

    					return true;
    				} else {
    					listItem = afterCreate(createdItem);
    				}
    			}
    		}

    		if ("undefined" === typeof listItem) {
    			if (debug) {
    				console.log(`listItem is undefined. Can not select.`);
    			}

    			return false;
    		}

    		if (lock && selectedItem) {
    			return true;
    		}

    		const newSelectedItem = listItem.item;

    		if (beforeChange(selectedItem, newSelectedItem)) {
    			// simple selection
    			if (!multiple) {
    				$$invalidate(1, selectedItem = undefined); // triggers change even if the the same item is selected
    				$$invalidate(1, selectedItem = newSelectedItem);
    			} else // first selection of multiple ones
    			if (!selectedItem) {
    				$$invalidate(1, selectedItem = [newSelectedItem]);
    			} else // selecting something already selected => unselect it
    			if (selectedItem.includes(newSelectedItem)) {
    				$$invalidate(1, selectedItem = selectedItem.filter(i => i !== newSelectedItem));
    			} else // adds the element to the selection
    			{
    				$$invalidate(1, selectedItem = [...selectedItem, newSelectedItem]);
    			}
    		}

    		return true;
    	}

    	function selectItem() {
    		if (debug) {
    			console.log("selectItem", highlightIndex);
    		}

    		const listItem = filteredListItems[highlightIndex];

    		if (selectListItem(listItem)) {
    			if (debug) {
    				console.log("selectListItem true, closing");
    			}

    			close();

    			if (multiple) {
    				input.focus();
    			}
    		} else {
    			if (debug) {
    				console.log("selectListItem false, not closing");
    			}
    		}
    	}

    	function up() {
    		if (debug) {
    			console.log("up");
    		}

    		open();

    		if (highlightIndex > 0) {
    			$$invalidate(30, highlightIndex--, highlightIndex);
    		}

    		highlight();
    	}

    	function down() {
    		if (debug) {
    			console.log("down");
    		}

    		open();

    		if (highlightIndex < filteredListItems.length - 1) {
    			$$invalidate(30, highlightIndex++, highlightIndex);
    		}

    		highlight();
    	}

    	function highlight() {
    		if (debug) {
    			console.log("highlight");
    		}

    		const query = ".selected";

    		if (debug) {
    			console.log("Seaching DOM element: " + query + " in " + list);
    		}

    		/**
     * @param {Element} el
     */
    		const el = list && list.querySelector(query);

    		if (el) {
    			if (typeof el.scrollIntoViewIfNeeded === "function") {
    				if (debug) {
    					console.log("Scrolling selected item into view");
    				}

    				el.scrollIntoViewIfNeeded();
    			} else if (el.scrollIntoView === "function") {
    				if (debug) {
    					console.log("Scrolling selected item into view");
    				}

    				el.scrollIntoView();
    			} else {
    				if (debug) {
    					console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
    				}
    			}
    		} else {
    			if (debug) {
    				console.warn("Selected item not found to scroll into view");
    			}
    		}
    	}

    	function onListItemClick(listItem) {
    		if (debug) {
    			console.log("onListItemClick");
    		}

    		if (selectListItem(listItem)) {
    			close();

    			if (multiple) {
    				input.focus();
    			}
    		}
    	}

    	function onDocumentClick(e) {
    		if (debug) {
    			console.log("onDocumentClick");
    		}

    		if (e.composedPath().some(path => path.classList && path.classList.contains(uniqueId))) {
    			if (debug) {
    				console.log("onDocumentClick inside");
    			}

    			// resetListToAllItemsAndOpen();
    			highlight();
    		} else {
    			if (debug) {
    				console.log("onDocumentClick outside");
    			}

    			close();
    		}
    	}

    	function onKeyDown(e) {
    		if (debug) {
    			console.log("onKeyDown");
    		}

    		let key = e.key;
    		if (key === "Tab" && e.shiftKey) key = "ShiftTab";

    		const fnmap = {
    			Tab: opened ? close() : null,
    			ShiftTab: opened ? close() : null,
    			ArrowDown: down.bind(this),
    			ArrowUp: up.bind(this),
    			Escape: onEsc.bind(this),
    			Backspace: multiple && selectedItem && selectedItem.length && !text
    			? onBackspace.bind(this)
    			: null
    		};

    		const fn = fnmap[key];

    		if (typeof fn === "function") {
    			fn(e);
    		}
    	}

    	function onKeyPress(e) {
    		if (debug) {
    			console.log("onKeyPress");
    		}

    		if (e.key === "Enter") {
    			e.preventDefault();
    			onEnter();
    		}
    	}

    	function onEnter() {
    		selectItem();
    	}

    	function onInput(e) {
    		if (debug) {
    			console.log("onInput");
    		}

    		$$invalidate(3, text = e.target.value);

    		if (inputDelayTimeout) {
    			clearTimeout(inputDelayTimeout);
    		}

    		if (delay) {
    			inputDelayTimeout = setTimeout(processInput, delay);
    		} else {
    			processInput();
    		}
    	}

    	function unselectItem(tag) {
    		if (debug) {
    			console.log("unselectItem", tag);
    		}

    		$$invalidate(1, selectedItem = selectedItem.filter(i => i !== tag));
    		input.focus();
    	}

    	function processInput() {
    		if (search()) {
    			$$invalidate(30, highlightIndex = 0);
    			open();
    		}
    	}

    	function onInputClick() {
    		if (debug) {
    			console.log("onInputClick");
    		}

    		resetListToAllItemsAndOpen();
    	}

    	function onEsc(e) {
    		if (debug) {
    			console.log("onEsc");
    		}

    		//if (text) return clear();
    		e.stopPropagation();

    		if (opened) {
    			input.focus();
    			close();
    		}
    	}

    	function onBackspace(e) {
    		if (debug) {
    			console.log("onBackspace");
    		}

    		unselectItem(selectedItem[selectedItem.length - 1]);
    	}

    	function onFocusInternal() {
    		if (debug) {
    			console.log("onFocus");
    		}

    		onFocus();
    		resetListToAllItemsAndOpen();
    	}

    	function onBlurInternal() {
    		if (debug) {
    			console.log("onBlur");
    		}

    		if (closeOnBlur) {
    			close();
    		}

    		onBlur();
    	}

    	function resetListToAllItemsAndOpen() {
    		if (debug) {
    			console.log("resetListToAllItemsAndOpen");
    		}

    		if (!text) {
    			$$invalidate(31, filteredListItems = listItems);
    		} else // When an async component is initialized, the item list
    		// must be loaded when the input is focused.
    		if (!listItems.length && selectedItem && searchFunction) {
    			search();
    		}

    		open();

    		// find selected item
    		if (selectedItem) {
    			if (debug) {
    				console.log("Searching currently selected item: " + JSON.stringify(selectedItem));
    			}

    			const index = findItemIndex(selectedItem, filteredListItems);

    			if (index >= 0) {
    				$$invalidate(30, highlightIndex = index);
    				highlight();
    			}
    		}
    	}

    	function findItemIndex(item, items) {
    		if (debug) {
    			console.log("Finding index for item", item);
    		}

    		let index = -1;

    		for (let i = 0; i < items.length; i++) {
    			const listItem = items[i];

    			if ("undefined" === typeof listItem) {
    				if (debug) {
    					console.log(`listItem ${i} is undefined. Skipping.`);
    				}

    				continue;
    			}

    			if (debug) {
    				console.log("Item " + i + ": " + JSON.stringify(listItem));
    			}

    			if (item === listItem.item) {
    				index = i;
    				break;
    			}
    		}

    		if (debug) {
    			if (index >= 0) {
    				console.log("Found index for item: " + index);
    			} else {
    				console.warn("Not found index for item: " + item);
    			}
    		}

    		return index;
    	}

    	function open() {
    		if (debug) {
    			console.log("open");
    		}

    		// check if the search text has more than the min chars required
    		if (notEnoughSearchText()) {
    			return;
    		}

    		$$invalidate(80, opened = true);
    	}

    	function close() {
    		if (debug) {
    			console.log("close");
    		}

    		$$invalidate(80, opened = false);
    		$$invalidate(34, loading = false);

    		if (!text && selectFirstIfEmpty) {
    			$$invalidate(30, highlightIndex = 0);
    			selectItem();
    		}
    	}

    	function notEnoughSearchText() {
    		return minCharactersToSearch > 1 && filteredTextLength < minCharactersToSearch;
    	}

    	function closeIfMinCharsToSearchReached() {
    		if (notEnoughSearchText()) {
    			close();
    		}
    	}

    	function clear() {
    		if (debug) {
    			console.log("clear");
    		}

    		$$invalidate(3, text = "");
    		$$invalidate(1, selectedItem = multiple ? [] : undefined);

    		setTimeout(() => {
    			input.focus();
    			close();
    		});
    	}

    	function highlightFilter(keywords, field) {
    		return item => {
    			let label = item[field];
    			const newItem = Object.assign({ highlighted: undefined }, item);
    			newItem.highlighted = label;
    			const labelLowercase = label.toLowerCase();

    			const labelLowercaseNoAc = ignoreAccents
    			? removeAccents(labelLowercase)
    			: labelLowercase;

    			if (keywords && keywords.length) {
    				const positions = [];

    				for (let i = 0; i < keywords.length; i++) {
    					let keyword = keywords[i];

    					if (ignoreAccents) {
    						keyword = removeAccents(keyword);
    					}

    					const keywordLen = keyword.length;
    					let pos1 = 0;

    					do {
    						pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

    						if (pos1 >= 0) {
    							let pos2 = pos1 + keywordLen;
    							positions.push([pos1, pos2]);
    							pos1 = pos2;
    						}
    					} while (pos1 !== -1);
    				}

    				if (positions.length > 0) {
    					const keywordPatterns = new Set();

    					for (let i = 0; i < positions.length; i++) {
    						const pair = positions[i];
    						const pos1 = pair[0];
    						const pos2 = pair[1];
    						const keywordPattern = labelLowercase.substring(pos1, pos2);
    						keywordPatterns.add(keywordPattern);
    					}

    					for (let keywordPattern of keywordPatterns) {
    						// FIXME pst: workarond for wrong replacement <b> tags
    						if (keywordPattern === "b") {
    							continue;
    						}

    						const reg = new RegExp("(" + keywordPattern + ")", "ig");
    						const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");
    						newItem.highlighted = newHighlighted;
    					}
    				}
    			}

    			return newItem;
    		};
    	}

    	function isConfirmed(listItem) {
    		if (!selectedItem) {
    			return false;
    		}

    		if (multiple) {
    			return selectedItem.includes(listItem);
    		} else {
    			return listItem === selectedItem;
    		}
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(32, input);
    		});
    	}

    	function input_1_input_handler() {
    		text = this.value;
    		$$invalidate(3, text);
    	}

    	const click_handler = listItem => onListItemClick(listItem);

    	const pointerenter_handler = i => {
    		$$invalidate(30, highlightIndex = i);
    	};

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			list = $$value;
    			$$invalidate(33, list);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('items' in $$props) $$invalidate(0, items = $$props.items);
    		if ('searchFunction' in $$props) $$invalidate(52, searchFunction = $$props.searchFunction);
    		if ('labelFieldName' in $$props) $$invalidate(53, labelFieldName = $$props.labelFieldName);
    		if ('keywordsFieldName' in $$props) $$invalidate(54, keywordsFieldName = $$props.keywordsFieldName);
    		if ('valueFieldName' in $$props) $$invalidate(55, valueFieldName = $$props.valueFieldName);
    		if ('labelFunction' in $$props) $$invalidate(56, labelFunction = $$props.labelFunction);
    		if ('keywordsFunction' in $$props) $$invalidate(57, keywordsFunction = $$props.keywordsFunction);
    		if ('valueFunction' in $$props) $$invalidate(4, valueFunction = $$props.valueFunction);
    		if ('keywordsCleanFunction' in $$props) $$invalidate(58, keywordsCleanFunction = $$props.keywordsCleanFunction);
    		if ('textCleanFunction' in $$props) $$invalidate(59, textCleanFunction = $$props.textCleanFunction);
    		if ('beforeChange' in $$props) $$invalidate(60, beforeChange = $$props.beforeChange);
    		if ('onChange' in $$props) $$invalidate(61, onChange = $$props.onChange);
    		if ('onFocus' in $$props) $$invalidate(62, onFocus = $$props.onFocus);
    		if ('onBlur' in $$props) $$invalidate(63, onBlur = $$props.onBlur);
    		if ('onCreate' in $$props) $$invalidate(64, onCreate = $$props.onCreate);
    		if ('selectFirstIfEmpty' in $$props) $$invalidate(65, selectFirstIfEmpty = $$props.selectFirstIfEmpty);
    		if ('minCharactersToSearch' in $$props) $$invalidate(66, minCharactersToSearch = $$props.minCharactersToSearch);
    		if ('maxItemsToShowInList' in $$props) $$invalidate(5, maxItemsToShowInList = $$props.maxItemsToShowInList);
    		if ('multiple' in $$props) $$invalidate(6, multiple = $$props.multiple);
    		if ('create' in $$props) $$invalidate(7, create = $$props.create);
    		if ('ignoreAccents' in $$props) $$invalidate(67, ignoreAccents = $$props.ignoreAccents);
    		if ('matchAllKeywords' in $$props) $$invalidate(68, matchAllKeywords = $$props.matchAllKeywords);
    		if ('sortByMatchedKeywords' in $$props) $$invalidate(69, sortByMatchedKeywords = $$props.sortByMatchedKeywords);
    		if ('itemFilterFunction' in $$props) $$invalidate(70, itemFilterFunction = $$props.itemFilterFunction);
    		if ('itemSortFunction' in $$props) $$invalidate(71, itemSortFunction = $$props.itemSortFunction);
    		if ('lock' in $$props) $$invalidate(8, lock = $$props.lock);
    		if ('delay' in $$props) $$invalidate(72, delay = $$props.delay);
    		if ('localFiltering' in $$props) $$invalidate(73, localFiltering = $$props.localFiltering);
    		if ('localSorting' in $$props) $$invalidate(74, localSorting = $$props.localSorting);
    		if ('cleanUserText' in $$props) $$invalidate(75, cleanUserText = $$props.cleanUserText);
    		if ('closeOnBlur' in $$props) $$invalidate(76, closeOnBlur = $$props.closeOnBlur);
    		if ('hideArrow' in $$props) $$invalidate(9, hideArrow = $$props.hideArrow);
    		if ('showClear' in $$props) $$invalidate(77, showClear = $$props.showClear);
    		if ('showLoadingIndicator' in $$props) $$invalidate(10, showLoadingIndicator = $$props.showLoadingIndicator);
    		if ('noResultsText' in $$props) $$invalidate(11, noResultsText = $$props.noResultsText);
    		if ('loadingText' in $$props) $$invalidate(12, loadingText = $$props.loadingText);
    		if ('moreItemsText' in $$props) $$invalidate(13, moreItemsText = $$props.moreItemsText);
    		if ('createText' in $$props) $$invalidate(14, createText = $$props.createText);
    		if ('placeholder' in $$props) $$invalidate(15, placeholder = $$props.placeholder);
    		if ('className' in $$props) $$invalidate(16, className = $$props.className);
    		if ('inputClassName' in $$props) $$invalidate(17, inputClassName = $$props.inputClassName);
    		if ('inputId' in $$props) $$invalidate(18, inputId = $$props.inputId);
    		if ('name' in $$props) $$invalidate(19, name = $$props.name);
    		if ('selectName' in $$props) $$invalidate(20, selectName = $$props.selectName);
    		if ('selectId' in $$props) $$invalidate(21, selectId = $$props.selectId);
    		if ('title' in $$props) $$invalidate(22, title = $$props.title);
    		if ('html5autocomplete' in $$props) $$invalidate(23, html5autocomplete = $$props.html5autocomplete);
    		if ('readonly' in $$props) $$invalidate(24, readonly = $$props.readonly);
    		if ('dropdownClassName' in $$props) $$invalidate(25, dropdownClassName = $$props.dropdownClassName);
    		if ('disabled' in $$props) $$invalidate(26, disabled = $$props.disabled);
    		if ('noInputStyles' in $$props) $$invalidate(27, noInputStyles = $$props.noInputStyles);
    		if ('required' in $$props) $$invalidate(28, required = $$props.required);
    		if ('debug' in $$props) $$invalidate(78, debug = $$props.debug);
    		if ('tabindex' in $$props) $$invalidate(29, tabindex = $$props.tabindex);
    		if ('selectedItem' in $$props) $$invalidate(1, selectedItem = $$props.selectedItem);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('highlightedItem' in $$props) $$invalidate(51, highlightedItem = $$props.highlightedItem);
    		if ('text' in $$props) $$invalidate(3, text = $$props.text);
    		if ('$$scope' in $$props) $$invalidate(82, $$scope = $$props.$$scope);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*items*/ 1 | $$self.$$.dirty[1] & /*searchFunction*/ 2097152) {
    			// -- Reactivity --
    			(searchFunction || prepareListItems());
    		}

    		if ($$self.$$.dirty[0] & /*selectedItem*/ 2) {
    			(onSelectedItemChanged());
    		}

    		if ($$self.$$.dirty[0] & /*highlightIndex*/ 1073741824 | $$self.$$.dirty[1] & /*filteredListItems*/ 1) {
    			$$invalidate(51, highlightedItem = filteredListItems && highlightIndex && highlightIndex >= 0 && highlightIndex < filteredListItems.length
    			? filteredListItems[highlightIndex].item
    			: null);
    		}

    		if ($$self.$$.dirty[0] & /*items*/ 1 | $$self.$$.dirty[2] & /*opened, filteredTextLength*/ 786432) {
    			$$invalidate(36, showList = opened && (items && items.length > 0 || filteredTextLength > 0));
    		}

    		if ($$self.$$.dirty[0] & /*lock, multiple, selectedItem*/ 322 | $$self.$$.dirty[2] & /*showClear*/ 32768) {
    			$$invalidate(35, clearable = showClear || (lock || multiple) && selectedItem);
    		}
    	};

    	return [
    		items,
    		selectedItem,
    		value,
    		text,
    		valueFunction,
    		maxItemsToShowInList,
    		multiple,
    		create,
    		lock,
    		hideArrow,
    		showLoadingIndicator,
    		noResultsText,
    		loadingText,
    		moreItemsText,
    		createText,
    		placeholder,
    		className,
    		inputClassName,
    		inputId,
    		name,
    		selectName,
    		selectId,
    		title,
    		html5autocomplete,
    		readonly,
    		dropdownClassName,
    		disabled,
    		noInputStyles,
    		required,
    		tabindex,
    		highlightIndex,
    		filteredListItems,
    		input,
    		list,
    		loading,
    		clearable,
    		showList,
    		uniqueId,
    		safeLabelFunction,
    		selectItem,
    		onListItemClick,
    		onDocumentClick,
    		onKeyDown,
    		onKeyPress,
    		onInput,
    		unselectItem,
    		onInputClick,
    		onFocusInternal,
    		onBlurInternal,
    		clear,
    		isConfirmed,
    		highlightedItem,
    		searchFunction,
    		labelFieldName,
    		keywordsFieldName,
    		valueFieldName,
    		labelFunction,
    		keywordsFunction,
    		keywordsCleanFunction,
    		textCleanFunction,
    		beforeChange,
    		onChange,
    		onFocus,
    		onBlur,
    		onCreate,
    		selectFirstIfEmpty,
    		minCharactersToSearch,
    		ignoreAccents,
    		matchAllKeywords,
    		sortByMatchedKeywords,
    		itemFilterFunction,
    		itemSortFunction,
    		delay,
    		localFiltering,
    		localSorting,
    		cleanUserText,
    		closeOnBlur,
    		showClear,
    		debug,
    		highlightFilter,
    		opened,
    		filteredTextLength,
    		$$scope,
    		slots,
    		input_1_binding,
    		input_1_input_handler,
    		click_handler,
    		pointerenter_handler,
    		div1_binding
    	];
    }

    class SimpleAutocomplete extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$t,
    			create_fragment$u,
    			safe_not_equal,
    			{
    				items: 0,
    				searchFunction: 52,
    				labelFieldName: 53,
    				keywordsFieldName: 54,
    				valueFieldName: 55,
    				labelFunction: 56,
    				keywordsFunction: 57,
    				valueFunction: 4,
    				keywordsCleanFunction: 58,
    				textCleanFunction: 59,
    				beforeChange: 60,
    				onChange: 61,
    				onFocus: 62,
    				onBlur: 63,
    				onCreate: 64,
    				selectFirstIfEmpty: 65,
    				minCharactersToSearch: 66,
    				maxItemsToShowInList: 5,
    				multiple: 6,
    				create: 7,
    				ignoreAccents: 67,
    				matchAllKeywords: 68,
    				sortByMatchedKeywords: 69,
    				itemFilterFunction: 70,
    				itemSortFunction: 71,
    				lock: 8,
    				delay: 72,
    				localFiltering: 73,
    				localSorting: 74,
    				cleanUserText: 75,
    				closeOnBlur: 76,
    				hideArrow: 9,
    				showClear: 77,
    				showLoadingIndicator: 10,
    				noResultsText: 11,
    				loadingText: 12,
    				moreItemsText: 13,
    				createText: 14,
    				placeholder: 15,
    				className: 16,
    				inputClassName: 17,
    				inputId: 18,
    				name: 19,
    				selectName: 20,
    				selectId: 21,
    				title: 22,
    				html5autocomplete: 23,
    				readonly: 24,
    				dropdownClassName: 25,
    				disabled: 26,
    				noInputStyles: 27,
    				required: 28,
    				debug: 78,
    				tabindex: 29,
    				selectedItem: 1,
    				value: 2,
    				highlightedItem: 51,
    				text: 3,
    				highlightFilter: 79
    			},
    			null,
    			[-1, -1, -1, -1]
    		);
    	}

    	get highlightFilter() {
    		return this.$$.ctx[79];
    	}
    }

    function restrictInputToNumbers(node, enable = true) {
      const onKeyPress = (event) => {
        const keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        if (!keys.includes(event.key)) {
          event.returnValue = false;
          if (event.preventDefault) event.preventDefault();
        }
      };

      if (enable) {
        node.addEventListener("keypress", onKeyPress);
      }

      return {
        destroy() {
          node.removeEventListener("keypress", onKeyPress);
        },
      };
    }

    /* src/components/Input/AutocompleteInput.svelte generated by Svelte v3.42.4 */

    function create_fragment$t(ctx) {
    	let div;
    	let autocomplete;
    	let current;

    	autocomplete = new SimpleAutocomplete({
    			props: {
    				delay: 500,
    				searchFunction: /*searchFunction*/ ctx[3],
    				textCleanFunction: /*func*/ ctx[14],
    				labelFunction: /*func_1*/ ctx[15],
    				beforeChange: /*func_2*/ ctx[16],
    				inputId: /*id*/ ctx[2],
    				noResultsText: /*noResultsText*/ ctx[1],
    				disabled: /*disabled*/ ctx[5],
    				localSorting: /*localSorting*/ ctx[12],
    				hideArrow: true,
    				sortByMatchedKeywords: /*sortByMatchedKeywords*/ ctx[11],
    				itemSortFunction: /*itemSortFunction*/ ctx[9],
    				localSearch: false,
    				localFiltering: /*localFiltering*/ ctx[10],
    				valueFieldName: /*valueField*/ ctx[8],
    				selectedItem: { attr: /*value*/ ctx[0] },
    				html5autocomplete: false,
    				required: /*required*/ ctx[6]
    			}
    		});

    	return {
    		c() {
    			div = element("div");
    			create_component(autocomplete.$$.fragment);
    			attr(div, "class", "container svelte-nhdxi9");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(autocomplete, div, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const autocomplete_changes = {};
    			if (dirty & /*searchFunction*/ 8) autocomplete_changes.searchFunction = /*searchFunction*/ ctx[3];
    			if (dirty & /*value*/ 1) autocomplete_changes.textCleanFunction = /*func*/ ctx[14];
    			if (dirty & /*suggestionFormat, valueField*/ 272) autocomplete_changes.labelFunction = /*func_1*/ ctx[15];
    			if (dirty & /*valueField, value, onSelected*/ 385) autocomplete_changes.beforeChange = /*func_2*/ ctx[16];
    			if (dirty & /*id*/ 4) autocomplete_changes.inputId = /*id*/ ctx[2];
    			if (dirty & /*noResultsText*/ 2) autocomplete_changes.noResultsText = /*noResultsText*/ ctx[1];
    			if (dirty & /*disabled*/ 32) autocomplete_changes.disabled = /*disabled*/ ctx[5];
    			if (dirty & /*localSorting*/ 4096) autocomplete_changes.localSorting = /*localSorting*/ ctx[12];
    			if (dirty & /*sortByMatchedKeywords*/ 2048) autocomplete_changes.sortByMatchedKeywords = /*sortByMatchedKeywords*/ ctx[11];
    			if (dirty & /*itemSortFunction*/ 512) autocomplete_changes.itemSortFunction = /*itemSortFunction*/ ctx[9];
    			if (dirty & /*localFiltering*/ 1024) autocomplete_changes.localFiltering = /*localFiltering*/ ctx[10];
    			if (dirty & /*valueField*/ 256) autocomplete_changes.valueFieldName = /*valueField*/ ctx[8];
    			if (dirty & /*value*/ 1) autocomplete_changes.selectedItem = { attr: /*value*/ ctx[0] };
    			if (dirty & /*required*/ 64) autocomplete_changes.required = /*required*/ ctx[6];
    			autocomplete.$set(autocomplete_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(autocomplete.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(autocomplete.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(autocomplete);
    		}
    	};
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { noResultsText } = $$props;
    	let { id } = $$props;
    	let { searchFunction } = $$props;
    	let { value } = $$props;
    	let { suggestionFormat } = $$props;
    	let { disabled } = $$props;
    	let { required } = $$props;
    	let { onlyNumbers = false } = $$props;

    	let { onSelected = () => {
    		
    	} } = $$props;

    	let { valueField } = $$props;
    	let { itemSortFunction } = $$props;
    	let { localFiltering } = $$props;
    	let { sortByMatchedKeywords } = $$props;
    	let { localSorting } = $$props;
    	onMount(() => restrictInputToNumbers(document.getElementById(id), onlyNumbers));
    	const func = text => $$invalidate(0, value = text);

    	const func_1 = item => {
    		if (typeof item === "undefined") return "";
    		const values = Object.values(item);

    		if (values.length === 0) return ""; else if (values.length === 1 && Object.keys(item)[0] === "attr") return item.attr; else if (suggestionFormat) {
    			return suggestionFormat(...values);
    		} else {
    			return item[valueField];
    		}
    	};

    	const func_2 = (prevSelectedObject, selectedObject) => {
    		if (valueField) $$invalidate(0, value = selectedObject[valueField]);
    		onSelected(selectedObject);
    	};

    	$$self.$$set = $$props => {
    		if ('noResultsText' in $$props) $$invalidate(1, noResultsText = $$props.noResultsText);
    		if ('id' in $$props) $$invalidate(2, id = $$props.id);
    		if ('searchFunction' in $$props) $$invalidate(3, searchFunction = $$props.searchFunction);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('suggestionFormat' in $$props) $$invalidate(4, suggestionFormat = $$props.suggestionFormat);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ('required' in $$props) $$invalidate(6, required = $$props.required);
    		if ('onlyNumbers' in $$props) $$invalidate(13, onlyNumbers = $$props.onlyNumbers);
    		if ('onSelected' in $$props) $$invalidate(7, onSelected = $$props.onSelected);
    		if ('valueField' in $$props) $$invalidate(8, valueField = $$props.valueField);
    		if ('itemSortFunction' in $$props) $$invalidate(9, itemSortFunction = $$props.itemSortFunction);
    		if ('localFiltering' in $$props) $$invalidate(10, localFiltering = $$props.localFiltering);
    		if ('sortByMatchedKeywords' in $$props) $$invalidate(11, sortByMatchedKeywords = $$props.sortByMatchedKeywords);
    		if ('localSorting' in $$props) $$invalidate(12, localSorting = $$props.localSorting);
    	};

    	return [
    		value,
    		noResultsText,
    		id,
    		searchFunction,
    		suggestionFormat,
    		disabled,
    		required,
    		onSelected,
    		valueField,
    		itemSortFunction,
    		localFiltering,
    		sortByMatchedKeywords,
    		localSorting,
    		onlyNumbers,
    		func,
    		func_1,
    		func_2
    	];
    }

    class AutocompleteInput extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$s, create_fragment$t, safe_not_equal, {
    			noResultsText: 1,
    			id: 2,
    			searchFunction: 3,
    			value: 0,
    			suggestionFormat: 4,
    			disabled: 5,
    			required: 6,
    			onlyNumbers: 13,
    			onSelected: 7,
    			valueField: 8,
    			itemSortFunction: 9,
    			localFiltering: 10,
    			sortByMatchedKeywords: 11,
    			localSorting: 12
    		});
    	}
    }

    function createFormatter (selectedStartDate, selectedEndDate, config) {
      const formatter = derived([ selectedStartDate, selectedEndDate ], ([ $selectedStartDate, $selectedEndDate ]) => {
        const formattedSelected = $selectedStartDate && $selectedStartDate.format(config.format);
        const formattedSelectedEnd = config.isRangePicker && $selectedEndDate && $selectedEndDate.format(config.format);

        return {
          formattedSelected,
          formattedSelectedEnd,
          formattedCombined: config.isRangePicker ? `${formattedSelected} - ${formattedSelectedEnd}` : formattedSelected
        }
      });

      return { formatter }
    }

    var dayjs_min = {exports: {}};

    (function (module, exports) {
    !function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},D="en",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if("string"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else {var i=t.name;v[i]=t,r=i;}return !n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));
    }(dayjs_min));

    var dayjs = dayjs_min.exports;

    var localeData$1 = {exports: {}};

    (function (module, exports) {
    !function(n,e){module.exports=e();}(commonjsGlobal,(function(){return function(n,e,t){var r=e.prototype,o=function(n){return n&&(n.indexOf?n:n.s)},u=function(n,e,t,r,u){var i=n.name?n:n.$locale(),a=o(i[e]),s=o(i[t]),f=a||s.map((function(n){return n.substr(0,r)}));if(!u)return f;var d=i.weekStart;return f.map((function(n,e){return f[(e+(d||0))%7]}))},i=function(){return t.Ls[t.locale()]},a=function(n,e){return n.formats[e]||function(n){return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(n,e,t){return e||t.slice(1)}))}(n.formats[e.toUpperCase()])},s=function(){var n=this;return {months:function(e){return e?e.format("MMMM"):u(n,"months")},monthsShort:function(e){return e?e.format("MMM"):u(n,"monthsShort","months",3)},firstDayOfWeek:function(){return n.$locale().weekStart||0},weekdays:function(e){return e?e.format("dddd"):u(n,"weekdays")},weekdaysMin:function(e){return e?e.format("dd"):u(n,"weekdaysMin","weekdays",2)},weekdaysShort:function(e){return e?e.format("ddd"):u(n,"weekdaysShort","weekdays",3)},longDateFormat:function(e){return a(n.$locale(),e)},meridiem:this.$locale().meridiem,ordinal:this.$locale().ordinal}};r.localeData=function(){return s.bind(this)()},t.localeData=function(){var n=i();return {firstDayOfWeek:function(){return n.weekStart||0},weekdays:function(){return t.weekdays()},weekdaysShort:function(){return t.weekdaysShort()},weekdaysMin:function(){return t.weekdaysMin()},months:function(){return t.months()},monthsShort:function(){return t.monthsShort()},longDateFormat:function(e){return a(n,e)},meridiem:n.meridiem,ordinal:n.ordinal}},t.months=function(){return u(i(),"months")},t.monthsShort=function(){return u(i(),"monthsShort","months",3)},t.weekdays=function(n){return u(i(),"weekdays",null,null,n)},t.weekdaysShort=function(n){return u(i(),"weekdaysShort","weekdays",3,n)},t.weekdaysMin=function(n){return u(i(),"weekdaysMin","weekdays",2,n)};}}));
    }(localeData$1));

    var localeData = localeData$1.exports;

    var minMax$1 = {exports: {}};

    (function (module, exports) {
    !function(e,n){module.exports=n();}(commonjsGlobal,(function(){return function(e,n,t){var i=function(e,n){if(!n||!n.length||!n[0]||1===n.length&&!n[0].length)return null;var t;1===n.length&&n[0].length>0&&(n=n[0]);t=n[0];for(var i=1;i<n.length;i+=1)n[i].isValid()&&!n[i][e](t)||(t=n[i]);return t};t.max=function(){var e=[].slice.call(arguments,0);return i("isAfter",e)},t.min=function(){var e=[].slice.call(arguments,0);return i("isBefore",e)};}}));
    }(minMax$1));

    var minMax = minMax$1.exports;

    var isSameOrBefore$1 = {exports: {}};

    (function (module, exports) {
    !function(e,i){module.exports=i();}(commonjsGlobal,(function(){return function(e,i){i.prototype.isSameOrBefore=function(e,i){return this.isSame(e,i)||this.isBefore(e,i)};}}));
    }(isSameOrBefore$1));

    var isSameOrBefore = isSameOrBefore$1.exports;

    var isSameOrAfter$1 = {exports: {}};

    (function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){t.prototype.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)};}}));
    }(isSameOrAfter$1));

    var isSameOrAfter = isSameOrAfter$1.exports;

    var de$1 = {exports: {}};

    (function (module, exports) {
    !function(e,n){module.exports=n(dayjs_min.exports);}(commonjsGlobal,(function(e){function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var t=n(e),a={s:"ein paar Sekunden",m:["eine Minute","einer Minute"],mm:"%d Minuten",h:["eine Stunde","einer Stunde"],hh:"%d Stunden",d:["ein Tag","einem Tag"],dd:["%d Tage","%d Tagen"],M:["ein Monat","einem Monat"],MM:["%d Monate","%d Monaten"],y:["ein Jahr","einem Jahr"],yy:["%d Jahre","%d Jahren"]};function i(e,n,t){var i=a[t];return Array.isArray(i)&&(i=i[n?0:1]),i.replace("%d",e)}var r={name:"de",weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),months:"Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan_Feb_März_Apr_Mai_Juni_Juli_Aug_Sept_Okt_Nov_Dez".split("_"),ordinal:function(e){return e+"."},weekStart:1,yearStart:4,formats:{LTS:"HH:mm:ss",LT:"HH:mm",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},relativeTime:{future:"in %s",past:"vor %s",s:i,m:i,mm:i,h:i,hh:i,d:i,dd:i,M:i,MM:i,y:i,yy:i}};return t.default.locale(r,null,!0),r}));
    }(de$1));

    var de = de$1.exports;

    dayjs.extend(localeData);
    dayjs.extend(minMax);
    dayjs.extend(isSameOrBefore);
    dayjs.extend(isSameOrAfter);
    dayjs.locale(de);

    function ensureFutureMonth (firstDate, secondDate) {
      return firstDate.isSame(secondDate, 'month') ? secondDate.add(1, 'month') : secondDate
    }

    function buildDaySelectionValidator (start, end, selectableCallback) {
      return date => {
        const isInRange = date.isSameOrAfter(start, 'day') && date.isSameOrBefore(end, 'day');
        return {
          isInRange,
          selectable: isInRange && (!selectableCallback || selectableCallback(date.toDate())),
          isToday: date.isSame(dayjs(), 'day')
        }
      }
    }

    function getCalendarPage (date, dayValidator) {
      const displayedRangeStart = date.startOf('month').startOf('week');
      const displayedRangeEnd = date.endOf('month').endOf('week').add(1, 'day');

      const weeks = [];
      let currentDay = displayedRangeStart;
      while (currentDay.isBefore(displayedRangeEnd, 'day')) {
        const weekOfMonth = Math.floor(currentDay.diff(displayedRangeStart, 'days') / 7);
        const isRequestedMonth = currentDay.isSame(date, 'month');
        weeks[weekOfMonth] = weeks[weekOfMonth] || { days: [], id: `${currentDay.format('YYYYMMYYYY')}${weekOfMonth}` };
        weeks[weekOfMonth].days.push(
          Object.assign({
            partOfMonth: isRequestedMonth,
            firstOfMonth: isRequestedMonth && currentDay.date() === 1,
            lastOfMonth: isRequestedMonth && currentDay.date() === date.daysInMonth(),
            day: currentDay.date(),
            month: currentDay.month(),
            year: currentDay.year(),
            date: currentDay
          }, dayValidator(currentDay))
        );
        currentDay = currentDay.add(1, 'day');
      }

      return { month: date.month(), year: date.year(), weeks }
    }

    function getMonths (config) {
      const { start, end, selectableCallback } = config;
      const firstMonth = start.startOf('month').startOf('day');
      const lastMonth = ensureFutureMonth(firstMonth, end.startOf('month').startOf('day'));

      const months = [];
      const validator = buildDaySelectionValidator(start, end, selectableCallback);
      let date = dayjs(firstMonth);
      while (date.isSameOrBefore(lastMonth)) {
        months.push(getCalendarPage(date, validator));
        date = date.add(1, 'month');
      }
      return months
    }

    function moveDateWithinAllowedRange (date, config, isStart) {
      const isOutsideRange = (
        date.valueOf() < config.start.valueOf() ||
        date.valueOf() > config.end.valueOf()
      );

      if (isOutsideRange) {
        console.warn('Provided date', date.format(), 'is outside specified start-and-end range', config.start.format(), 'to', config.end.format());
        return isStart ? config.start : config.end
      }

      return date
    }

    function sanitizeInitialValue (value, config) {
      let isDateChosen = false;
      let chosen;

      if (config.isRangePicker) {
        const [ from, to ] = value || [];
        isDateChosen = Boolean(from).valueOf() && Boolean(to).valueOf();
        chosen = isDateChosen ? value.map(dayjs) : [ dayjs.max(dayjs(), config.start), dayjs.min(dayjs().add(1, 'month'), config.end) ];
      } else {
        isDateChosen = Boolean(value).valueOf();
        chosen = [ isDateChosen ? dayjs(value) : dayjs.max(dayjs(), config.start) ];
      }

      const [ from, to ] = chosen;

      return {
        isDateChosen,
        chosen: [
          moveDateWithinAllowedRange(from, config, true),
          ...config.isRangePicker ? [ moveDateWithinAllowedRange(to, config, false) ] : []
        ]
      }
    }

    const contextKey = {};

    function setup (given, config) {
      const today = dayjs().startOf('day');

      const { isDateChosen, chosen: [ preSelectedStart, preSelectedEnd ] } = sanitizeInitialValue(given, config);
      const selectedStartDate = writable(preSelectedStart);
      const selectedEndDate = writable(preSelectedEnd);
      const { formatter } = createFormatter(selectedStartDate, selectedEndDate, config);
      const component = writable('date-view');

      const leftDate = preSelectedStart.startOf('month');
      const rightDate = config.isRangePicker ? ensureFutureMonth(preSelectedStart, preSelectedEnd).startOf('month') : null;

      return {
        months: getMonths(config),
        component,
        today,
        selectedStartDate,
        selectedEndDate,
        leftCalendarDate: writable(leftDate),
        rightCalendarDate: writable(rightDate),
        config,
        shouldShakeDate: writable(false),
        isOpen: writable(false),
        isClosing: writable(false),
        highlighted: writable(today),
        formatter,
        isDateChosen: writable(isDateChosen),
        resetView: () => {
          component.set('date-view');
        },
        isSelectingFirstDate: writable(true)
      }
    }

    function sizes (w) {
      const contentWidth = [ ...w.document.body.children ].reduce((a, el) => Math.max(
        a, el.getBoundingClientRect().right), 0
      ) - w.document.body.getBoundingClientRect().x;

      return {
        pageWidth: Math.min(w.document.body.scrollWidth, contentWidth),
        pageHeight: w.document.body.scrollHeight,
        viewportHeight: w.innerHeight,
        viewportWidth: w.innerWidth
      }
    }

    const dimensions = {
      page: {
        padding: 6,
        deadzone: 80
      },
      content: {
        medium: {
          single: {
            height: 410,
            width: 340
          },
          range: {
            height: 410,
            width: 680
          }
        },
        small: {
          single: {
            height: 410,
            width: 340
          },
          range: {
            height: 786,
            width: 340
          }
        }
      }
    };

    function getPosition (w, e, config) {
      const { isRangePicker } = config;
      const { pageWidth, viewportHeight, viewportWidth } = sizes(w);

      const display = pageWidth < 480 ? 'small' : 'medium';
      const mode = isRangePicker ? 'range' : 'single';
      const { padding, deadzone } = dimensions.page;
      const { width, height } = dimensions.content[display][mode];

      if (viewportHeight < (height + padding + deadzone) || viewportWidth < (width + padding)) {
        return {
          fullscreen: true,
          top: 0,
          left: 0
        }
      }

      let left = Math.max(padding, e.pageX - (width / 2));

      if ((left + width) > pageWidth) {
        left = (pageWidth - width) - padding;
      }

      let top = Math.max(padding, e.pageY - (height / 2));

      const willExceedViewableArea = (top + height) > viewportHeight;
      if (willExceedViewableArea) {
        top = viewportHeight - height - padding;
      }

      return { top, left }
    }

    const once = (el, evt, cb) => {
      if (!el) { return }
      function handler () {
        cb.apply(this, arguments);
        el.removeEventListener(evt, handler);
      }
      el.addEventListener(evt, handler);
    };

    /* node_modules/@beyonk/svelte-datepicker/src/components/Popover.svelte generated by Svelte v3.42.4 */

    const { window: window_1 } = globals;
    const get_contents_slot_changes = dirty => ({});
    const get_contents_slot_context = ctx => ({});
    const get_trigger_slot_changes = dirty => ({});
    const get_trigger_slot_context = ctx => ({});

    function create_fragment$s(ctx) {
    	let div4;
    	let div0;
    	let t;
    	let div3;
    	let div2;
    	let div1;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[17]);
    	const trigger_slot_template = /*#slots*/ ctx[16].trigger;
    	const trigger_slot = create_slot(trigger_slot_template, ctx, /*$$scope*/ ctx[15], get_trigger_slot_context);
    	const contents_slot_template = /*#slots*/ ctx[16].contents;
    	const contents_slot = create_slot(contents_slot_template, ctx, /*$$scope*/ ctx[15], get_contents_slot_context);

    	return {
    		c() {
    			div4 = element("div");
    			div0 = element("div");
    			if (trigger_slot) trigger_slot.c();
    			t = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (contents_slot) contents_slot.c();
    			attr(div0, "class", "trigger");
    			attr(div1, "class", "contents-inner svelte-10d3skr");
    			attr(div2, "class", "wrapper svelte-10d3skr");
    			attr(div3, "class", "contents-wrapper svelte-10d3skr");
    			set_style(div3, "top", /*translateY*/ ctx[6] + "px");
    			set_style(div3, "left", /*translateX*/ ctx[7] + "px");
    			toggle_class(div3, "visible", /*$isOpen*/ ctx[8]);
    			toggle_class(div3, "shrink", /*$isClosing*/ ctx[9]);
    			toggle_class(div3, "is-fullscreen", /*isFullscreen*/ ctx[5]);
    			attr(div4, "class", "sc-popover svelte-10d3skr");
    		},
    		m(target, anchor) {
    			insert(target, div4, anchor);
    			append(div4, div0);

    			if (trigger_slot) {
    				trigger_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[18](div0);
    			append(div4, t);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, div1);

    			if (contents_slot) {
    				contents_slot.m(div1, null);
    			}

    			/*div2_binding*/ ctx[19](div2);
    			/*div3_binding*/ ctx[20](div3);
    			/*div4_binding*/ ctx[21](div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window_1, "resize", /*onwindowresize*/ ctx[17]),
    					listen(div0, "click", /*doOpen*/ ctx[12])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (trigger_slot) {
    				if (trigger_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
    					update_slot_base(
    						trigger_slot,
    						trigger_slot_template,
    						ctx,
    						/*$$scope*/ ctx[15],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
    						: get_slot_changes(trigger_slot_template, /*$$scope*/ ctx[15], dirty, get_trigger_slot_changes),
    						get_trigger_slot_context
    					);
    				}
    			}

    			if (contents_slot) {
    				if (contents_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
    					update_slot_base(
    						contents_slot,
    						contents_slot_template,
    						ctx,
    						/*$$scope*/ ctx[15],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
    						: get_slot_changes(contents_slot_template, /*$$scope*/ ctx[15], dirty, get_contents_slot_changes),
    						get_contents_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*translateY*/ 64) {
    				set_style(div3, "top", /*translateY*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*translateX*/ 128) {
    				set_style(div3, "left", /*translateX*/ ctx[7] + "px");
    			}

    			if (dirty & /*$isOpen*/ 256) {
    				toggle_class(div3, "visible", /*$isOpen*/ ctx[8]);
    			}

    			if (dirty & /*$isClosing*/ 512) {
    				toggle_class(div3, "shrink", /*$isClosing*/ ctx[9]);
    			}

    			if (dirty & /*isFullscreen*/ 32) {
    				toggle_class(div3, "is-fullscreen", /*isFullscreen*/ ctx[5]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(trigger_slot, local);
    			transition_in(contents_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(trigger_slot, local);
    			transition_out(contents_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div4);
    			if (trigger_slot) trigger_slot.d(detaching);
    			/*div0_binding*/ ctx[18](null);
    			if (contents_slot) contents_slot.d(detaching);
    			/*div2_binding*/ ctx[19](null);
    			/*div3_binding*/ ctx[20](null);
    			/*div4_binding*/ ctx[21](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $isOpen;
    	let $isClosing;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	const { isOpen, isClosing, config, resetView } = getContext(contextKey);
    	component_subscribe($$self, isOpen, value => $$invalidate(8, $isOpen = value));
    	component_subscribe($$self, isClosing, value => $$invalidate(9, $isClosing = value));
    	const dispatch = createEventDispatcher();
    	let popover;
    	let w;
    	let triggerContainer;
    	let contentsAnimated;
    	let contentsWrapper;
    	let isFullscreen = false;
    	let translateY = 0;
    	let translateX = 0;
    	let { trigger } = $$props;

    	function close() {
    		isClosing.set(true);

    		once(contentsAnimated, 'animationend', () => {
    			isClosing.set(false);
    			isOpen.set(false);
    			dispatch('closed');
    		});
    	}

    	function checkForFocusLoss(evt) {
    		if (!$isOpen) return;
    		let el = evt.target;

    		do {
    			if (el === popover) {
    				return;
    			}

    			el = el.parentNode;
    		} while (el);

    		close();
    	}

    	onMount(() => {
    		config.closeOnFocusLoss && document.addEventListener('click', checkForFocusLoss);

    		if (!trigger) {
    			return;
    		}

    		triggerContainer.appendChild(trigger.parentNode.removeChild(trigger));

    		return () => {
    			config.closeOnFocusLoss && document.removeEventListener('click', checkForFocusLoss);
    		};
    	});

    	const doOpen = async e => {
    		isOpen.set(true);
    		resetView();
    		await tick();
    		const { top, left, fullscreen } = getPosition(window, e, config);
    		$$invalidate(5, isFullscreen = fullscreen);
    		$$invalidate(6, translateY = top);
    		$$invalidate(7, translateX = left);
    		dispatch('opened');
    	};

    	function onwindowresize() {
    		$$invalidate(1, w = window_1.innerWidth);
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			triggerContainer = $$value;
    			$$invalidate(2, triggerContainer);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contentsAnimated = $$value;
    			$$invalidate(3, contentsAnimated);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			contentsWrapper = $$value;
    			$$invalidate(4, contentsWrapper);
    		});
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			popover = $$value;
    			$$invalidate(0, popover);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('trigger' in $$props) $$invalidate(13, trigger = $$props.trigger);
    		if ('$$scope' in $$props) $$invalidate(15, $$scope = $$props.$$scope);
    	};

    	return [
    		popover,
    		w,
    		triggerContainer,
    		contentsAnimated,
    		contentsWrapper,
    		isFullscreen,
    		translateY,
    		translateX,
    		$isOpen,
    		$isClosing,
    		isOpen,
    		isClosing,
    		doOpen,
    		trigger,
    		close,
    		$$scope,
    		slots,
    		onwindowresize,
    		div0_binding,
    		div2_binding,
    		div3_binding,
    		div4_binding
    	];
    }

    class Popover extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$r, create_fragment$s, safe_not_equal, { trigger: 13, close: 14 });
    	}

    	get close() {
    		return this.$$.ctx[14];
    	}
    }

    class CalendarStyle {
      constructor (overrides = {}) {
        this.style = '';
        this.buttonBackgroundColor = '#fff';
        this.buttonBorderColor = '#eee';
        this.buttonTextColor = '#333';
        this.buttonWidth = '300px';
        this.highlightColor = '#f7901e';
        this.passiveHighlightColor = '#FCD9B1';

        this.dayBackgroundColor = 'none';
        this.dayBackgroundColorIsNight = 'none';
        this.dayTextColor = '#4a4a4a';
        this.dayTextColorIsNight = '#4a4a4a';
        this.dayTextColorInRange = 'white';
        this.dayHighlightedBackgroundColor = '#efefef';
        this.dayHighlightedTextColor = '#4a4a4a';

        this.currentDayTextColor = '#000';
        this.selectedDayTextColor = 'white';

        this.timeNightModeTextColor = 'white';
        this.timeNightModeBackgroundColor = '#808080';
        this.timeDayModeTextColor = 'white';
        this.timeDayModeBackgroundColor = 'white';
        this.timeSelectedTextColor = '#3d4548';
        this.timeInputTextColor = '#3d4548';
        this.timeConfirmButtonColor = '#2196F3';
        this.timeConfirmButtonTextColor = 'white';

        this.toolbarBorderColor = '#888';

        this.contentBackground = 'white';

        this.monthYearTextColor = '#3d4548';
        this.legendTextColor = '#4a4a4a';

        this.datepickerWidth = 'auto';

        Object.entries(overrides).forEach(([ prop, value ]) => {
          this[prop] = value;
        });
      }

      toWrapperStyle () {
        return `
      --button-background-color: ${this.buttonBackgroundColor};
      --button-border-color: ${this.buttonBorderColor};
      --button-text-color: ${this.buttonTextColor};
      --button-width: ${this.buttonWidth};
      --highlight-color: ${this.highlightColor};
      --passive-highlight-color: ${this.passiveHighlightColor};

      --day-background-color: ${this.dayBackgroundColor};
      --day-background-color-is-night: ${this.dayBackgroundColorIsNight};
      --day-text-color: ${this.dayTextColor};
      --day-text-color-in-range: ${this.dayTextColorInRange};
      --day-text-color-is-night: ${this.dayTextColorIsNight};
      --day-highlighted-background-color: ${this.dayHighlightedBackgroundColor};
      --day-highlighted-text-color: ${this.dayHighlightedTextColor};

      --current-day-text-color: ${this.currentDayTextColor};
      --selected-day-text-color: ${this.selectedDayTextColor};

      --time-night-mode-text-color: ${this.timeNightModeTextColor};
      --time-night-mode-background-color: ${this.timeNightModeBackgroundColor};
      --time-day-mode-text-color: ${this.timeDayModeTextColor};
      --time-day-mode-background-color: ${this.timeDayModeBackgroundColor};

      --time-selected-text-color: ${this.timeSelectedTextColor};
      --time-input-text-color: ${this.timeInputTextColor};
      --time-confirm-button-text-color: ${this.timeConfirmButtonTextColor};
      --time-confirm-button-color: ${this.timeConfirmButtonColor};

      --toolbar-border-color: ${this.toolbarBorderColor};

      --content-background: ${this.contentBackground};

      --month-year-text-color: ${this.monthYearTextColor};
      --legend-text-color: ${this.legendTextColor};
      --datepicker-width: ${this.datepickerWidth};

      ${this.style}
    `
      }
    }

    function isDateBetweenSelected (a, b, c) {
      const start = a.startOf('day').toDate();
      const stop = b.startOf('day').toDate();
      const day = c.startOf('day').toDate();
      return day > start && day < stop
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/date-view/Week.svelte generated by Svelte v3.42.4 */

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (20:2) {#each days as day}
    function create_each_block$7(ctx) {
    	let div;
    	let button;
    	let t0_value = /*day*/ ctx[16].date.date() + "";
    	let t0;
    	let button_aria_label_value;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[15](/*day*/ ctx[16]);
    	}

    	return {
    		c() {
    			div = element("div");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(button, "class", "day--label svelte-1gcp452");
    			attr(button, "type", "button");
    			attr(button, "aria-label", button_aria_label_value = /*day*/ ctx[16].date.format('YYYY-MM-DD'));
    			toggle_class(button, "highlighted", /*day*/ ctx[16].date.isSame(/*$highlighted*/ ctx[5], 'day'));
    			toggle_class(button, "shake-date", /*$shouldShakeDate*/ ctx[6] && /*day*/ ctx[16].date.isSame(/*$shouldShakeDate*/ ctx[6], 'day'));
    			toggle_class(button, "disabled", !/*day*/ ctx[16].selectable);
    			attr(div, "class", "day svelte-1gcp452");
    			toggle_class(div, "is-night", !/*$isDaytime*/ ctx[2]);
    			toggle_class(div, "is-range-picker", /*config*/ ctx[7].isRangePicker);
    			toggle_class(div, "outside-month", !/*day*/ ctx[16].partOfMonth);
    			toggle_class(div, "first-of-month", /*day*/ ctx[16].firstOfMonth);
    			toggle_class(div, "last-of-month", /*day*/ ctx[16].lastOfMonth);
    			toggle_class(div, "selection-start", /*day*/ ctx[16].date.isSame(/*$selectedStartDate*/ ctx[3], 'day'));
    			toggle_class(div, "selection-end", /*config*/ ctx[7].isRangePicker && /*day*/ ctx[16].date.isSame(/*$selectedEndDate*/ ctx[4], 'day'));
    			toggle_class(div, "part-of-range", /*config*/ ctx[7].isRangePicker && isDateBetweenSelected(/*$selectedStartDate*/ ctx[3], /*$selectedEndDate*/ ctx[4], /*day*/ ctx[16].date));
    			toggle_class(div, "is-today", /*day*/ ctx[16].isToday);
    			toggle_class(div, "is-disabled", !/*day*/ ctx[16].selectable);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, button);
    			append(button, t0);
    			append(div, t1);

    			if (!mounted) {
    				dispose = listen(button, "click", stop_propagation(click_handler));
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*days*/ 1 && t0_value !== (t0_value = /*day*/ ctx[16].date.date() + "")) set_data(t0, t0_value);

    			if (dirty & /*days*/ 1 && button_aria_label_value !== (button_aria_label_value = /*day*/ ctx[16].date.format('YYYY-MM-DD'))) {
    				attr(button, "aria-label", button_aria_label_value);
    			}

    			if (dirty & /*days, $highlighted*/ 33) {
    				toggle_class(button, "highlighted", /*day*/ ctx[16].date.isSame(/*$highlighted*/ ctx[5], 'day'));
    			}

    			if (dirty & /*$shouldShakeDate, days*/ 65) {
    				toggle_class(button, "shake-date", /*$shouldShakeDate*/ ctx[6] && /*day*/ ctx[16].date.isSame(/*$shouldShakeDate*/ ctx[6], 'day'));
    			}

    			if (dirty & /*days*/ 1) {
    				toggle_class(button, "disabled", !/*day*/ ctx[16].selectable);
    			}

    			if (dirty & /*$isDaytime*/ 4) {
    				toggle_class(div, "is-night", !/*$isDaytime*/ ctx[2]);
    			}

    			if (dirty & /*days*/ 1) {
    				toggle_class(div, "outside-month", !/*day*/ ctx[16].partOfMonth);
    			}

    			if (dirty & /*days*/ 1) {
    				toggle_class(div, "first-of-month", /*day*/ ctx[16].firstOfMonth);
    			}

    			if (dirty & /*days*/ 1) {
    				toggle_class(div, "last-of-month", /*day*/ ctx[16].lastOfMonth);
    			}

    			if (dirty & /*days, $selectedStartDate*/ 9) {
    				toggle_class(div, "selection-start", /*day*/ ctx[16].date.isSame(/*$selectedStartDate*/ ctx[3], 'day'));
    			}

    			if (dirty & /*config, days, $selectedEndDate*/ 145) {
    				toggle_class(div, "selection-end", /*config*/ ctx[7].isRangePicker && /*day*/ ctx[16].date.isSame(/*$selectedEndDate*/ ctx[4], 'day'));
    			}

    			if (dirty & /*config, isDateBetweenSelected, $selectedStartDate, $selectedEndDate, days*/ 153) {
    				toggle_class(div, "part-of-range", /*config*/ ctx[7].isRangePicker && isDateBetweenSelected(/*$selectedStartDate*/ ctx[3], /*$selectedEndDate*/ ctx[4], /*day*/ ctx[16].date));
    			}

    			if (dirty & /*days*/ 1) {
    				toggle_class(div, "is-today", /*day*/ ctx[16].isToday);
    			}

    			if (dirty & /*days*/ 1) {
    				toggle_class(div, "is-disabled", !/*day*/ ctx[16].selectable);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$r(ctx) {
    	let div;
    	let div_intro;
    	let each_value = /*days*/ ctx[0];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div, "class", "week svelte-1gcp452");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*$isDaytime, config, days, $selectedStartDate, $selectedEndDate, isDateBetweenSelected, $highlighted, $shouldShakeDate, dispatch*/ 8445) {
    				each_value = /*days*/ ctx[0];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i(local) {
    			if (local) {
    				if (!div_intro) {
    					add_render_callback(() => {
    						div_intro = create_in_transition(div, fly, {
    							x: /*direction*/ ctx[1] * 50,
    							duration: 180,
    							delay: 90
    						});

    						div_intro.start();
    					});
    				}
    			}
    		},
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $isDaytime;
    	let $selectedStartDate;
    	let $selectedEndDate;
    	let $highlighted;
    	let $shouldShakeDate;
    	let { viewContextKey } = $$props;
    	let { days } = $$props;
    	let { direction } = $$props;
    	const { config, shouldShakeDate, highlighted, selectedStartDate, selectedEndDate } = getContext(contextKey);
    	component_subscribe($$self, shouldShakeDate, value => $$invalidate(6, $shouldShakeDate = value));
    	component_subscribe($$self, highlighted, value => $$invalidate(5, $highlighted = value));
    	component_subscribe($$self, selectedStartDate, value => $$invalidate(3, $selectedStartDate = value));
    	component_subscribe($$self, selectedEndDate, value => $$invalidate(4, $selectedEndDate = value));
    	const { isDaytime } = getContext(viewContextKey);
    	component_subscribe($$self, isDaytime, value => $$invalidate(2, $isDaytime = value));
    	const dispatch = createEventDispatcher();
    	const click_handler = day => dispatch('chosen', { date: day.date });

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(14, viewContextKey = $$props.viewContextKey);
    		if ('days' in $$props) $$invalidate(0, days = $$props.days);
    		if ('direction' in $$props) $$invalidate(1, direction = $$props.direction);
    	};

    	return [
    		days,
    		direction,
    		$isDaytime,
    		$selectedStartDate,
    		$selectedEndDate,
    		$highlighted,
    		$shouldShakeDate,
    		config,
    		shouldShakeDate,
    		highlighted,
    		selectedStartDate,
    		selectedEndDate,
    		isDaytime,
    		dispatch,
    		viewContextKey,
    		click_handler
    	];
    }

    class Week extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$q, create_fragment$r, safe_not_equal, {
    			viewContextKey: 14,
    			days: 0,
    			direction: 1
    		});
    	}
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/date-view/Month.svelte generated by Svelte v3.42.4 */

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (24:8) {#each dayjs.weekdaysShort(true) as day}
    function create_each_block_1(ctx) {
    	let span;
    	let t_value = /*day*/ ctx[10] + "";
    	let t;

    	return {
    		c() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "class", "svelte-lktis3");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (29:4) {#each $monthView.visibleMonth.weeks as week (week.id)}
    function create_each_block$6(key_1, ctx) {
    	let first;
    	let week;
    	let current;

    	week = new Week({
    			props: {
    				viewContextKey: /*viewContextKey*/ ctx[0],
    				days: /*week*/ ctx[7].days,
    				direction: /*direction*/ ctx[1]
    			}
    		});

    	week.$on("chosen", /*chosen_handler*/ ctx[6]);

    	return {
    		key: key_1,
    		first: null,
    		c() {
    			first = empty();
    			create_component(week.$$.fragment);
    			this.first = first;
    		},
    		m(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(week, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const week_changes = {};
    			if (dirty & /*viewContextKey*/ 1) week_changes.viewContextKey = /*viewContextKey*/ ctx[0];
    			if (dirty & /*$monthView*/ 4) week_changes.days = /*week*/ ctx[7].days;
    			if (dirty & /*direction*/ 2) week_changes.direction = /*direction*/ ctx[1];
    			week.$set(week_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(week.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(week.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(first);
    			destroy_component(week, detaching);
    		}
    	};
    }

    function create_fragment$q(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let t;
    	let each_blocks = [];
    	let each1_lookup = new Map();
    	let current;
    	let each_value_1 = dayjs.weekdaysShort(true);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = /*$monthView*/ ctx[2].visibleMonth.weeks;
    	const get_key = ctx => /*week*/ ctx[7].id;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$6(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
    	}

    	return {
    		c() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div0, "class", "month-week svelte-lktis3");
    			attr(div1, "class", "legend svelte-lktis3");
    			attr(div2, "class", "month-dates svelte-lktis3");
    			attr(div3, "class", "month-container svelte-lktis3");
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, div0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append(div2, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*dayjs*/ 0) {
    				each_value_1 = dayjs.weekdaysShort(true);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*viewContextKey, $monthView, direction*/ 7) {
    				each_value = /*$monthView*/ ctx[2].visibleMonth.weeks;
    				group_outros();
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, div2, outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div3);
    			destroy_each(each_blocks_1, detaching);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $monthView;
    	let { viewContextKey } = $$props;
    	let { id } = $$props;
    	const { monthView } = getContext(viewContextKey);
    	component_subscribe($$self, monthView, value => $$invalidate(2, $monthView = value));
    	let lastId = id;
    	let direction;

    	function chosen_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(0, viewContextKey = $$props.viewContextKey);
    		if ('id' in $$props) $$invalidate(4, id = $$props.id);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*lastId, id*/ 48) {
    			{
    				$$invalidate(1, direction = lastId < id ? 1 : -1);
    				$$invalidate(5, lastId = id);
    			}
    		}
    	};

    	return [viewContextKey, direction, $monthView, monthView, id, lastId, chosen_handler];
    }

    class Month extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$p, create_fragment$q, safe_not_equal, { viewContextKey: 0, id: 4 });
    	}
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/date-view/NavBar.svelte generated by Svelte v3.42.4 */

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    // (84:6) {#each availableMonths as monthDefinition, index}
    function create_each_block$5(ctx) {
    	let button;
    	let span;
    	let t0_value = /*monthDefinition*/ ctx[27].abbrev + "";
    	let t0;
    	let t1;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[21](/*monthDefinition*/ ctx[27], /*index*/ ctx[29], ...args);
    	}

    	return {
    		c() {
    			button = element("button");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(span, "class", "svelte-1c4p61v");
    			attr(button, "class", "month-selector--month svelte-1c4p61v");
    			button.disabled = button_disabled_value = !/*monthDefinition*/ ctx[27].selectable;
    			toggle_class(button, "selected", /*index*/ ctx[29] === /*$displayedDate*/ ctx[0].month());
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, span);
    			append(span, t0);
    			append(button, t1);

    			if (!mounted) {
    				dispose = listen(button, "click", click_handler_2);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*availableMonths*/ 4 && t0_value !== (t0_value = /*monthDefinition*/ ctx[27].abbrev + "")) set_data(t0, t0_value);

    			if (dirty & /*availableMonths*/ 4 && button_disabled_value !== (button_disabled_value = !/*monthDefinition*/ ctx[27].selectable)) {
    				button.disabled = button_disabled_value;
    			}

    			if (dirty & /*$displayedDate*/ 1) {
    				toggle_class(button, "selected", /*index*/ ctx[29] === /*$displayedDate*/ ctx[0].month());
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$p(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let i0;
    	let button0_disabled_value;
    	let t0;
    	let button1;
    	let span;
    	let t1_value = /*$displayedDate*/ ctx[0].format('MMMM YYYY') + "";
    	let t1;
    	let t2;
    	let button2;
    	let i1;
    	let button2_disabled_value;
    	let t3;
    	let div1;
    	let mounted;
    	let dispose;
    	let each_value = /*availableMonths*/ ctx[2];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t0 = space();
    			button1 = element("button");
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			button2 = element("button");
    			i1 = element("i");
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(i0, "class", "arrow left svelte-1c4p61v");
    			attr(button0, "class", "control svelte-1c4p61v");
    			attr(button0, "type", "button");
    			attr(button0, "aria-label", "Previous month");
    			button0.disabled = button0_disabled_value = !/*canDecrementMonth*/ ctx[3];
    			attr(button1, "type", "button");
    			attr(button1, "class", "label svelte-1c4p61v");
    			attr(i1, "class", "arrow right svelte-1c4p61v");
    			attr(button2, "class", "control svelte-1c4p61v");
    			attr(button2, "type", "button");
    			attr(button2, "aria-label", "Next month");
    			button2.disabled = button2_disabled_value = !/*canIncrementMonth*/ ctx[4];
    			attr(div0, "class", "heading-section svelte-1c4p61v");
    			attr(div1, "class", "month-selector svelte-1c4p61v");
    			toggle_class(div1, "open", /*monthSelectorOpen*/ ctx[1]);
    			attr(div2, "class", "title svelte-1c4p61v");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div0, button0);
    			append(button0, i0);
    			append(div0, t0);
    			append(div0, button1);
    			append(button1, span);
    			append(span, t1);
    			append(div0, t2);
    			append(div0, button2);
    			append(button2, i1);
    			append(div2, t3);
    			append(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*click_handler*/ ctx[19]),
    					listen(button1, "click", /*toggleMonthSelectorOpen*/ ctx[10]),
    					listen(button2, "click", /*click_handler_1*/ ctx[20])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*canDecrementMonth*/ 8 && button0_disabled_value !== (button0_disabled_value = !/*canDecrementMonth*/ ctx[3])) {
    				button0.disabled = button0_disabled_value;
    			}

    			if (dirty & /*$displayedDate*/ 1 && t1_value !== (t1_value = /*$displayedDate*/ ctx[0].format('MMMM YYYY') + "")) set_data(t1, t1_value);

    			if (dirty & /*canIncrementMonth*/ 16 && button2_disabled_value !== (button2_disabled_value = !/*canIncrementMonth*/ ctx[4])) {
    				button2.disabled = button2_disabled_value;
    			}

    			if (dirty & /*availableMonths, $displayedDate, monthSelected*/ 2053) {
    				each_value = /*availableMonths*/ ctx[2];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*monthSelectorOpen*/ 2) {
    				toggle_class(div1, "open", /*monthSelectorOpen*/ ctx[1]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let myPosition;
    	let startPosition;
    	let endPosition;
    	let canIncrementMonth;
    	let canDecrementMonth;
    	let $displayedDate;
    	let $monthView;
    	let $rightCalendarDate;
    	let $leftCalendarDate;
    	let { viewContextKey } = $$props;
    	const { months, config, highlighted, leftCalendarDate, rightCalendarDate } = getContext(contextKey);
    	component_subscribe($$self, leftCalendarDate, value => $$invalidate(18, $leftCalendarDate = value));
    	component_subscribe($$self, rightCalendarDate, value => $$invalidate(17, $rightCalendarDate = value));
    	const { isStart, displayedDate, monthView } = getContext(viewContextKey);
    	component_subscribe($$self, displayedDate, value => $$invalidate(0, $displayedDate = value));
    	component_subscribe($$self, monthView, value => $$invalidate(16, $monthView = value));
    	let monthSelectorOpen = false;
    	let availableMonths;

    	function changeMonth(selectedMonth) {
    		displayedDate.update(v => v.month(selectedMonth));
    		highlighted.set($displayedDate);
    	}

    	function incrementMonth(direction) {
    		if (direction === 1 && !canIncrementMonth) return;
    		if (direction === -1 && !canDecrementMonth) return;
    		displayedDate.update(d => d.add(direction, 'months'));
    		highlighted.set($displayedDate);
    	}

    	function toggleMonthSelectorOpen() {
    		$$invalidate(1, monthSelectorOpen = !monthSelectorOpen);
    	}

    	function monthSelected(event, { monthDefinition, index }) {
    		event.stopPropagation();
    		if (!monthDefinition.selectable) return;
    		changeMonth(index);
    		toggleMonthSelectorOpen();
    	}

    	const click_handler = () => incrementMonth(-1);
    	const click_handler_1 = () => incrementMonth(1);
    	const click_handler_2 = (monthDefinition, index, e) => monthSelected(e, { monthDefinition, index });

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(12, viewContextKey = $$props.viewContextKey);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$displayedDate*/ 1) {
    			{
    				const isOnLowerBoundary = config.start.isSame($displayedDate, 'year');
    				const isOnUpperBoundary = config.end.isSame($displayedDate, 'year');

    				$$invalidate(2, availableMonths = dayjs.months().map((m, i) => {
    					return Object.assign({}, { name: m, abbrev: dayjs.monthsShort()[i] }, {
    						selectable: !isOnLowerBoundary && !isOnUpperBoundary || (!isOnLowerBoundary || i >= config.start.month()) && (!isOnUpperBoundary || i <= config.end.year())
    					});
    				}));
    			}
    		}

    		if ($$self.$$.dirty & /*$displayedDate*/ 1) {
    			$$invalidate(14, myPosition = dayjs($displayedDate).diff('0000-00-00', 'month'));
    		}

    		if ($$self.$$.dirty & /*$leftCalendarDate*/ 262144) {
    			$$invalidate(13, startPosition = dayjs($leftCalendarDate).diff('0000-00-00', 'month'));
    		}

    		if ($$self.$$.dirty & /*$rightCalendarDate*/ 131072) {
    			$$invalidate(15, endPosition = dayjs($rightCalendarDate).diff('0000-00-00', 'month'));
    		}

    		if ($$self.$$.dirty & /*$monthView, myPosition, endPosition*/ 114688) {
    			$$invalidate(4, canIncrementMonth = $monthView.monthIndex < months.length - 1 && (config.isRangePicker && isStart
    			? myPosition < endPosition - 1
    			: true));
    		}

    		if ($$self.$$.dirty & /*$monthView, myPosition, startPosition*/ 90112) {
    			$$invalidate(3, canDecrementMonth = $monthView.monthIndex > 0 && (config.isRangePicker && !isStart
    			? myPosition > startPosition + 1
    			: true));
    		}
    	};

    	return [
    		$displayedDate,
    		monthSelectorOpen,
    		availableMonths,
    		canDecrementMonth,
    		canIncrementMonth,
    		leftCalendarDate,
    		rightCalendarDate,
    		displayedDate,
    		monthView,
    		incrementMonth,
    		toggleMonthSelectorOpen,
    		monthSelected,
    		viewContextKey,
    		startPosition,
    		myPosition,
    		endPosition,
    		$monthView,
    		$rightCalendarDate,
    		$leftCalendarDate,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class NavBar extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$o, create_fragment$p, safe_not_equal, { viewContextKey: 12 });
    	}
    }

    let shakeHighlightTimeout;

    function getDay (months, m, d, y) {
      const theMonth = months.find(aMonth => aMonth.month === m && aMonth.year === y);
      if (!theMonth) {
        return null
      }

      for (let i = 0; i < theMonth.weeks.length; i += 1) {
        for (let j = 0; j < theMonth.weeks[i].days.length; j += 1) {
          const aDay = theMonth.weeks[i].days[j];
          if (aDay.month === m && aDay.day === d && aDay.year === y) return aDay
        }
      }
      return null
    }

    function checkIfVisibleDateIsSelectable (months, date) {
      const proposedDay = getDay(
        months,
        date.month(),
        date.date(),
        date.year()
      );
      return proposedDay && proposedDay.selectable
    }

    function shakeDate (shouldShakeDate, date) {
      clearTimeout(shakeHighlightTimeout);
      shouldShakeDate.set(date);
      shakeHighlightTimeout = setTimeout(() => {
        shouldShakeDate.set(false);
      }, 700);
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/date-view/DateView.svelte generated by Svelte v3.42.4 */

    function create_fragment$o(ctx) {
    	let div;
    	let navbar;
    	let t;
    	let month;
    	let current;

    	navbar = new NavBar({
    			props: {
    				viewContextKey: /*viewContextKey*/ ctx[0]
    			}
    		});

    	month = new Month({
    			props: {
    				viewContextKey: /*viewContextKey*/ ctx[0],
    				id: /*visibleMonthsId*/ ctx[1]
    			}
    		});

    	month.$on("chosen", /*chosen_handler*/ ctx[5]);

    	return {
    		c() {
    			div = element("div");
    			create_component(navbar.$$.fragment);
    			t = space();
    			create_component(month.$$.fragment);
    			attr(div, "class", "svelte-3fib5n");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(navbar, div, null);
    			append(div, t);
    			mount_component(month, div, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const navbar_changes = {};
    			if (dirty & /*viewContextKey*/ 1) navbar_changes.viewContextKey = /*viewContextKey*/ ctx[0];
    			navbar.$set(navbar_changes);
    			const month_changes = {};
    			if (dirty & /*viewContextKey*/ 1) month_changes.viewContextKey = /*viewContextKey*/ ctx[0];
    			if (dirty & /*visibleMonthsId*/ 2) month_changes.id = /*visibleMonthsId*/ ctx[1];
    			month.$set(month_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(month.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(month.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(navbar);
    			destroy_component(month);
    		}
    	};
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let visibleMonthsId;
    	let $displayedDate;
    	let { viewContextKey } = $$props;
    	const dispatch = createEventDispatcher();
    	const { displayedDate } = getContext(viewContextKey);
    	component_subscribe($$self, displayedDate, value => $$invalidate(4, $displayedDate = value));
    	const { months, shouldShakeDate } = getContext(contextKey);

    	function registerSelection(chosen) {
    		if (!checkIfVisibleDateIsSelectable(months, chosen)) {
    			return shakeDate(shouldShakeDate, chosen);
    		}

    		dispatch('chosen', { date: chosen });
    		return true;
    	}

    	const chosen_handler = e => registerSelection(e.detail.date);

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(0, viewContextKey = $$props.viewContextKey);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$displayedDate*/ 16) {
    			$$invalidate(1, visibleMonthsId = $displayedDate.unix());
    		}
    	};

    	return [
    		viewContextKey,
    		visibleMonthsId,
    		displayedDate,
    		registerSelection,
    		$displayedDate,
    		chosen_handler
    	];
    }

    class DateView extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$n, create_fragment$o, safe_not_equal, { viewContextKey: 0 });
    	}
    }

    function createMonthView (months, displayedDate) {
      return derived([ displayedDate ], ([ $displayedDate ]) => {
        let monthIndex = 0;

        const month = $displayedDate.month();
        const year = $displayedDate.year();
        for (let i = 0; i < months.length; i += 1) {
          if (months[i].month === month && months[i].year === year) {
            monthIndex = i;
          }
        }

        return {
          monthIndex,
          visibleMonth: months[monthIndex]
        }
      })
    }

    function createViewContext (isStart, mainContext) {
      const { config, months, leftCalendarDate, rightCalendarDate, selectedStartDate, selectedEndDate } = mainContext;
      const [ date, displayedDate ] = isStart ? [ selectedStartDate, leftCalendarDate ] : [ selectedEndDate, rightCalendarDate ];
      const isDaytime = derived(date, $date => {
        if (!$date) { return true }
        const [ h ] = dayjs($date).format('HH:mm').split(':').map(d => parseInt(d));
        return h > config.morning && h < config.night
      });

      return {
        isStart,
        date,
        view: DateView,
        isDaytime,
        displayedDate,
        monthView: createMonthView(months, displayedDate)
      }
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/Toolbar.svelte generated by Svelte v3.42.4 */

    function create_fragment$n(ctx) {
    	let div;
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			button = element("button");
    			t = text(/*continueText*/ ctx[0]);
    			attr(button, "type", "button");
    			attr(button, "class", "button svelte-hbl86k");
    			attr(div, "class", "toolbar svelte-hbl86k");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, button);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", prevent_default(/*progress*/ ctx[2]));
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*continueText*/ 1) set_data(t, /*continueText*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $component;
    	let { continueText } = $$props;
    	const dispatch = createEventDispatcher();
    	const { config, component, isDateChosen } = getContext(contextKey);
    	component_subscribe($$self, component, value => $$invalidate(3, $component = value));

    	function finalise() {
    		isDateChosen.set(true);
    		dispatch('close');
    	}

    	function progress() {
    		isDateChosen.set(false);

    		if ($component === 'date-view') {
    			if (config.isTimePicker) {
    				component.set('time-view');
    			} else {
    				finalise();
    			}
    		} else if ($component === 'time-view') {
    			finalise();
    		}
    	}

    	$$self.$$set = $$props => {
    		if ('continueText' in $$props) $$invalidate(0, continueText = $$props.continueText);
    	};

    	return [continueText, component, progress];
    }

    class Toolbar extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$m, create_fragment$n, safe_not_equal, { continueText: 0 });
    	}
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/time-view/Chevron.svelte generated by Svelte v3.42.4 */

    function create_fragment$m(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "chevron svelte-twxu81");
    			toggle_class(span, "bottom", !/*up*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);

    			if (!mounted) {
    				dispose = listen(span, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*up*/ 1) {
    				toggle_class(span, "bottom", !/*up*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(span);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { up = true } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('up' in $$props) $$invalidate(0, up = $$props.up);
    	};

    	return [up, click_handler];
    }

    class Chevron extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, { up: 0 });
    	}
    }

    function timeInput (node, store) {
      node.addEventListener('keydown', types);
      node.addEventListener('focus', resetTime);
      node.addEventListener('blur', attemptValuePersist);

      let time;

      const unsubscribe = store.subscribe(given => {
        time = given.split('');
        syncInput();
      });

      function syncInput () {
        node.value = time.join('');
      }

      function resetTime () {
        time = [];
        syncInput();
      }

      function persistTime () {
        store.set(time.join(''));
        syncInput();
      }

      function attemptValuePersist () {
        if (time.digits === 5) {
          persistTime();
          return
        }

        time = get_store_value(store).split('');
        syncInput();
      }

      function types (e) {
        e.preventDefault();
        const k = e.which;

        if (k >= 48 && k <= 57) {
          addDigit(k);
        }

        if (k === 8) {
          deleteDigit();
        }
      }

      function deleteDigit () {
        time.pop();
        time.length === 3 && time.pop();
        syncInput();
      }

      function isInvalidDigit (digit) {
        const tooManyDigits = time.length > 4;
        const invalidFirstDigit = time.length === 0 && ![ 0, 1, 2 ].includes(digit);
        const invalidSecondDigit = time.length === 1 && time[0] === 2 && digit > 3;
        const invalidThirdDigit = time.length === 3 && digit > 5;
        return tooManyDigits || invalidFirstDigit || invalidSecondDigit || invalidThirdDigit
      }

      function addDigit (k) {
        const digit = k - 48;
        if (isInvalidDigit(digit)) { return }

        time.length === 2 && time.push(':');
        time.push(digit);

        if (time.length === 5) {
          persistTime();
        }

        syncInput();
      }

      return {
        destroy () {
          unsubscribe();
          node.removeEventListener('keydown', types);
          node.removeEventListener('focus', resetTime);
          node.removeEventListener('blur', attemptValuePersist);
        }
      }
    }

    function format (h, m) {
      return [
        String(h).padStart(2, '0'),
        String(m).padStart(2, '0')
      ].join(':')
    }

    function createStore (date, config) {
      const time = writable(dayjs(date).format('HH:mm'));

      function increment (segment) {
        time.update(t => {
          let [ h, m ] = t.split(':');
          if (segment === 'hour' && h < 23) { ++h; }
          if (segment === 'minute' && m < 59) {
            m = Math.min(59, parseInt(m) + config.minuteStep);
          }
          return format(h, m)
        });
      }

      function decrement (segment) {
        time.update(t => {
          let [ h, m ] = t.split(':');
          if (segment === 'hour' && h > 0) { --h; }
          if (segment === 'minute' && m > 0) {
            m = Math.max(0, parseInt(m) - config.minuteStep);
          }
          return format(h, m)
        });
      }

      function set (t) {
        time.set(t);
      }
      return {
        increment,
        decrement,
        time,
        set
      }
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/time-view/TimeInput.svelte generated by Svelte v3.42.4 */

    function create_fragment$l(ctx) {
    	let div2;
    	let div0;
    	let chevron0;
    	let t0;
    	let chevron1;
    	let t1;
    	let input;
    	let t2;
    	let div1;
    	let chevron2;
    	let t3;
    	let chevron3;
    	let current;
    	let mounted;
    	let dispose;
    	chevron0 = new Chevron({ props: { up: true } });
    	chevron0.$on("click", /*click_handler*/ ctx[7]);
    	chevron1 = new Chevron({ props: { up: true } });
    	chevron1.$on("click", /*click_handler_1*/ ctx[8]);
    	chevron2 = new Chevron({ props: { up: false } });
    	chevron2.$on("click", /*click_handler_2*/ ctx[9]);
    	chevron3 = new Chevron({ props: { up: false } });
    	chevron3.$on("click", /*click_handler_3*/ ctx[10]);

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(chevron0.$$.fragment);
    			t0 = space();
    			create_component(chevron1.$$.fragment);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div1 = element("div");
    			create_component(chevron2.$$.fragment);
    			t3 = space();
    			create_component(chevron3.$$.fragment);
    			attr(div0, "class", "controls svelte-w5vedm");
    			attr(input, "type", "text");
    			attr(input, "class", "svelte-w5vedm");
    			attr(div1, "class", "controls svelte-w5vedm");
    			attr(div2, "class", "time-picker svelte-w5vedm");
    			toggle_class(div2, "is-night", !/*$isDaytime*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			mount_component(chevron0, div0, null);
    			append(div0, t0);
    			mount_component(chevron1, div0, null);
    			append(div2, t1);
    			append(div2, input);
    			append(div2, t2);
    			append(div2, div1);
    			mount_component(chevron2, div1, null);
    			append(div1, t3);
    			mount_component(chevron3, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(timeInput.call(null, input, /*timeStore*/ ctx[5]));
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$isDaytime*/ 1) {
    				toggle_class(div2, "is-night", !/*$isDaytime*/ ctx[0]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(chevron0.$$.fragment, local);
    			transition_in(chevron1.$$.fragment, local);
    			transition_in(chevron2.$$.fragment, local);
    			transition_in(chevron3.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(chevron0.$$.fragment, local);
    			transition_out(chevron1.$$.fragment, local);
    			transition_out(chevron2.$$.fragment, local);
    			transition_out(chevron3.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_component(chevron0);
    			destroy_component(chevron1);
    			destroy_component(chevron2);
    			destroy_component(chevron3);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $date;
    	let $isDaytime;
    	let { viewContextKey } = $$props;
    	const { config } = getContext(contextKey);
    	const { date, isDaytime } = getContext(viewContextKey);
    	component_subscribe($$self, date, value => $$invalidate(11, $date = value));
    	component_subscribe($$self, isDaytime, value => $$invalidate(0, $isDaytime = value));
    	const { increment, decrement, time: timeStore } = createStore($date, config);

    	onMount(() => timeStore.subscribe(ts => {
    		const [d, m] = ts.split(':').map(g => parseInt(g));
    		date.update(v => v.hour(d).minute(m));
    	}));

    	const click_handler = () => increment('hour');
    	const click_handler_1 = () => increment('minute');
    	const click_handler_2 = () => decrement('hour');
    	const click_handler_3 = () => decrement('minute');

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(6, viewContextKey = $$props.viewContextKey);
    	};

    	return [
    		$isDaytime,
    		date,
    		isDaytime,
    		increment,
    		decrement,
    		timeStore,
    		viewContextKey,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class TimeInput extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$k, create_fragment$l, safe_not_equal, { viewContextKey: 6 });
    	}
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/time-view/TimeView.svelte generated by Svelte v3.42.4 */

    function create_fragment$k(ctx) {
    	let div;
    	let span;
    	let t0_value = dayjs(/*$date*/ ctx[2]).format(/*config*/ ctx[5].format) + "";
    	let t0;
    	let t1;
    	let timeinput;
    	let current;

    	timeinput = new TimeInput({
    			props: {
    				viewContextKey: /*viewContextKey*/ ctx[0]
    			}
    		});

    	return {
    		c() {
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(timeinput.$$.fragment);
    			attr(span, "class", "chosen-date svelte-17tznc2");
    			attr(div, "class", "time-container svelte-17tznc2");
    			toggle_class(div, "is-night", !/*$isDaytime*/ ctx[1]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(span, t0);
    			append(div, t1);
    			mount_component(timeinput, div, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if ((!current || dirty & /*$date*/ 4) && t0_value !== (t0_value = dayjs(/*$date*/ ctx[2]).format(/*config*/ ctx[5].format) + "")) set_data(t0, t0_value);
    			const timeinput_changes = {};
    			if (dirty & /*viewContextKey*/ 1) timeinput_changes.viewContextKey = /*viewContextKey*/ ctx[0];
    			timeinput.$set(timeinput_changes);

    			if (dirty & /*$isDaytime*/ 2) {
    				toggle_class(div, "is-night", !/*$isDaytime*/ ctx[1]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(timeinput.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(timeinput.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(timeinput);
    		}
    	};
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $isDaytime;
    	let $date;
    	let { viewContextKey } = $$props;
    	const { date, isDaytime } = getContext(viewContextKey);
    	component_subscribe($$self, date, value => $$invalidate(2, $date = value));
    	component_subscribe($$self, isDaytime, value => $$invalidate(1, $isDaytime = value));
    	const { config } = getContext(contextKey);

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(0, viewContextKey = $$props.viewContextKey);
    	};

    	return [viewContextKey, $isDaytime, $date, date, isDaytime, config];
    }

    class TimeView extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$j, create_fragment$k, safe_not_equal, { viewContextKey: 0 });
    	}
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/view/View.svelte generated by Svelte v3.42.4 */

    function create_fragment$j(ctx) {
    	let div;
    	let switch_instance;
    	let current;

    	var switch_value = /*$component*/ ctx[2] === 'date-view'
    	? DateView
    	: TimeView;

    	function switch_props(ctx) {
    		return {
    			props: {
    				viewContextKey: /*viewContextKey*/ ctx[0]
    			}
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("chosen", /*chosen_handler*/ ctx[6]);
    	}

    	return {
    		c() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr(div, "class", "calendar svelte-1sgbxd0");
    			toggle_class(div, "is-range-picker", /*config*/ ctx[3].isRangePicker);
    			toggle_class(div, "day", /*$isDaytime*/ ctx[1]);
    			toggle_class(div, "night", !/*$isDaytime*/ ctx[1]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*viewContextKey*/ 1) switch_instance_changes.viewContextKey = /*viewContextKey*/ ctx[0];

    			if (switch_value !== (switch_value = /*$component*/ ctx[2] === 'date-view'
    			? DateView
    			: TimeView)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("chosen", /*chosen_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (dirty & /*$isDaytime*/ 2) {
    				toggle_class(div, "day", /*$isDaytime*/ ctx[1]);
    			}

    			if (dirty & /*$isDaytime*/ 2) {
    				toggle_class(div, "night", !/*$isDaytime*/ ctx[1]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $isDaytime;
    	let $component;
    	let { viewContextKey } = $$props;
    	const { config, component } = getContext(contextKey);
    	component_subscribe($$self, component, value => $$invalidate(2, $component = value));
    	const { isDaytime } = getContext(viewContextKey);
    	component_subscribe($$self, isDaytime, value => $$invalidate(1, $isDaytime = value));

    	function chosen_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('viewContextKey' in $$props) $$invalidate(0, viewContextKey = $$props.viewContextKey);
    	};

    	return [
    		viewContextKey,
    		$isDaytime,
    		$component,
    		config,
    		component,
    		isDaytime,
    		chosen_handler
    	];
    }

    class View extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$i, create_fragment$j, safe_not_equal, { viewContextKey: 0 });
    	}
    }

    /* node_modules/@beyonk/svelte-datepicker/src/components/DatePicker.svelte generated by Svelte v3.42.4 */
    const get_default_slot_changes = dirty => ({ formatted: dirty[0] & /*$formatter*/ 256 });
    const get_default_slot_context = ctx => ({ formatted: /*$formatter*/ ctx[8] });

    // (181:8) {#if !trigger}
    function create_if_block_1$1(ctx) {
    	let button;

    	function select_block_type(ctx, dirty) {
    		if (/*$isDateChosen*/ ctx[4]) return create_if_block_2;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	return {
    		c() {
    			button = element("button");
    			if_block.c();
    			attr(button, "class", "calendar-button svelte-19zfrtc");
    			attr(button, "type", "button");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			if_block.m(button, null);
    		},
    		p(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button, null);
    				}
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			if_block.d();
    		}
    	};
    }

    // (185:12) {:else}
    function create_else_block$2(ctx) {
    	let t;

    	return {
    		c() {
    			t = text(/*placeholder*/ ctx[0]);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*placeholder*/ 1) set_data(t, /*placeholder*/ ctx[0]);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (183:12) {#if $isDateChosen}
    function create_if_block_2(ctx) {
    	let t_value = /*$formatter*/ ctx[8].formattedCombined + "";
    	let t;

    	return {
    		c() {
    			t = text(t_value);
    		},
    		m(target, anchor) {
    			insert(target, t, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*$formatter*/ 256 && t_value !== (t_value = /*$formatter*/ ctx[8].formattedCombined + "")) set_data(t, t_value);
    		},
    		d(detaching) {
    			if (detaching) detach(t);
    		}
    	};
    }

    // (180:35)          
    function fallback_block(ctx) {
    	let if_block_anchor;
    	let if_block = !/*trigger*/ ctx[1] && create_if_block_1$1(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, dirty) {
    			if (!/*trigger*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    // (179:4) 
    function create_trigger_slot(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[34].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr(div, "slot", "trigger");
    			attr(div, "class", "svelte-19zfrtc");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$formatter*/ 256 | dirty[1] & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[37],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[37], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*$formatter, $isDateChosen, placeholder, trigger*/ 275)) {
    					default_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};
    }

    // (198:8) {#if config.isRangePicker}
    function create_if_block$4(ctx) {
    	let view;
    	let current;

    	view = new View({
    			props: {
    				viewContextKey: /*endContextKey*/ ctx[11]
    			}
    		});

    	view.$on("chosen", /*addDate*/ ctx[21]);

    	return {
    		c() {
    			create_component(view.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(view, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(view.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(view.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(view, detaching);
    		}
    	};
    }

    // (192:4) 
    function create_contents_slot(ctx) {
    	let div1;
    	let div0;
    	let view;
    	let t0;
    	let t1;
    	let toolbar;
    	let current;

    	view = new View({
    			props: {
    				viewContextKey: /*startContextKey*/ ctx[10]
    			}
    		});

    	view.$on("chosen", /*addDate*/ ctx[21]);
    	let if_block = /*config*/ ctx[12].isRangePicker && create_if_block$4(ctx);

    	toolbar = new Toolbar({
    			props: { continueText: /*continueText*/ ctx[3] }
    		});

    	toolbar.$on("close", /*close*/ ctx[22]);

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(view.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(toolbar.$$.fragment);
    			attr(div0, "class", "view svelte-19zfrtc");
    			attr(div1, "class", "contents svelte-19zfrtc");
    			attr(div1, "slot", "contents");
    			toggle_class(div1, "is-range-picker", /*config*/ ctx[12].isRangePicker);
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			mount_component(view, div0, null);
    			append(div0, t0);
    			if (if_block) if_block.m(div0, null);
    			append(div1, t1);
    			mount_component(toolbar, div1, null);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (/*config*/ ctx[12].isRangePicker) if_block.p(ctx, dirty);
    			const toolbar_changes = {};
    			if (dirty[0] & /*continueText*/ 8) toolbar_changes.continueText = /*continueText*/ ctx[3];
    			toolbar.$set(toolbar_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(view.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(toolbar.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(view.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(toolbar.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			destroy_component(view);
    			if (if_block) if_block.d();
    			destroy_component(toolbar);
    		}
    	};
    }

    function create_fragment$i(ctx) {
    	let div;
    	let popover_1;
    	let div_style_value;
    	let current;

    	let popover_1_props = {
    		trigger: /*trigger*/ ctx[1],
    		$$slots: {
    			contents: [create_contents_slot],
    			trigger: [create_trigger_slot]
    		},
    		$$scope: { ctx }
    	};

    	popover_1 = new Popover({ props: popover_1_props });
    	/*popover_1_binding*/ ctx[35](popover_1);
    	popover_1.$on("opened", /*initialisePicker*/ ctx[20]);
    	popover_1.$on("closed", /*closed_handler*/ ctx[36]);

    	return {
    		c() {
    			div = element("div");
    			create_component(popover_1.$$.fragment);
    			attr(div, "class", "datepicker svelte-19zfrtc");
    			attr(div, "style", div_style_value = /*styling*/ ctx[2].toWrapperStyle());
    			toggle_class(div, "open", /*$isOpen*/ ctx[6]);
    			toggle_class(div, "closing", /*$isClosing*/ ctx[7]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(popover_1, div, null);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const popover_1_changes = {};
    			if (dirty[0] & /*trigger*/ 2) popover_1_changes.trigger = /*trigger*/ ctx[1];

    			if (dirty[0] & /*continueText, $formatter, $isDateChosen, placeholder, trigger*/ 283 | dirty[1] & /*$$scope*/ 64) {
    				popover_1_changes.$$scope = { dirty, ctx };
    			}

    			popover_1.$set(popover_1_changes);

    			if (!current || dirty[0] & /*styling*/ 4 && div_style_value !== (div_style_value = /*styling*/ ctx[2].toWrapperStyle())) {
    				attr(div, "style", div_style_value);
    			}

    			if (dirty[0] & /*$isOpen*/ 64) {
    				toggle_class(div, "open", /*$isOpen*/ ctx[6]);
    			}

    			if (dirty[0] & /*$isClosing*/ 128) {
    				toggle_class(div, "closing", /*$isClosing*/ ctx[7]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(popover_1.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(popover_1.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			/*popover_1_binding*/ ctx[35](null);
    			destroy_component(popover_1);
    		}
    	};
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $isDateChosen;
    	let $isSelectingFirstDate;
    	let $selectedEndDate;
    	let $selectedStartDate;
    	let $isOpen;
    	let $isClosing;
    	let $formatter;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { range = false } = $$props;
    	let { placeholder = 'Choose Date' } = $$props;
    	let { format = 'DD / MM / YYYY' } = $$props;
    	let { start = dayjs().subtract(1, 'year') } = $$props;
    	let { end = dayjs().add(1, 'year') } = $$props;
    	let { trigger = null } = $$props;
    	let { selectableCallback = null } = $$props;
    	let { styling = new CalendarStyle() } = $$props;
    	let { selected } = $$props;
    	let { closeOnFocusLoss = true } = $$props;
    	let { time = false } = $$props;
    	let { morning = 7 } = $$props;
    	let { night = 19 } = $$props;
    	let { minuteStep = 5 } = $$props;
    	let { continueText = 'Continue' } = $$props;
    	const dispatch = createEventDispatcher();
    	const startContextKey = {};
    	const endContextKey = {};

    	const config = {
    		start: dayjs(start),
    		end: dayjs(end),
    		isRangePicker: range,
    		isTimePicker: time,
    		closeOnFocusLoss,
    		format,
    		morning,
    		night,
    		selectableCallback,
    		minuteStep: parseInt(minuteStep)
    	};

    	setContext(contextKey, setup(selected, config));
    	const { selectedStartDate, selectedEndDate, isOpen, isClosing, highlighted, formatter, isDateChosen, isSelectingFirstDate } = getContext(contextKey);
    	component_subscribe($$self, selectedStartDate, value => $$invalidate(40, $selectedStartDate = value));
    	component_subscribe($$self, selectedEndDate, value => $$invalidate(39, $selectedEndDate = value));
    	component_subscribe($$self, isOpen, value => $$invalidate(6, $isOpen = value));
    	component_subscribe($$self, isClosing, value => $$invalidate(7, $isClosing = value));
    	component_subscribe($$self, formatter, value => $$invalidate(8, $formatter = value));
    	component_subscribe($$self, isDateChosen, value => $$invalidate(4, $isDateChosen = value));
    	component_subscribe($$self, isSelectingFirstDate, value => $$invalidate(38, $isSelectingFirstDate = value));
    	setContext(startContextKey, createViewContext(true, getContext(contextKey)));

    	if (config.isRangePicker) {
    		setContext(endContextKey, createViewContext(false, getContext(contextKey)));
    	}

    	let popover;

    	function initialisePicker() {
    		highlighted.set($selectedStartDate);
    		dispatch('open');
    	}

    	function setRangeValue() {
    		$$invalidate(23, selected = [$selectedStartDate, $selectedEndDate]);

    		dispatch('range-selected', {
    			from: $selectedStartDate.toDate(),
    			to: $selectedEndDate.toDate()
    		});
    	}

    	function setDateValue() {
    		$$invalidate(23, selected = $selectedStartDate.toDate());
    		dispatch('date-selected', { date: $selectedStartDate.toDate() });
    	}

    	function swapDatesIfRequired() {
    		if (!config.isRangePicker) {
    			return;
    		}

    		const from = $selectedStartDate;
    		const to = $selectedEndDate;

    		if (to.isBefore(from)) {
    			selectedStartDate.set(to);
    			selectedEndDate.set(from);
    		}
    	}

    	function addDate(e) {
    		const { date } = e.detail;

    		if ($isSelectingFirstDate) {
    			selectedStartDate.set(date);
    		} else {
    			selectedEndDate.set(date);
    		}

    		swapDatesIfRequired();
    		config.isRangePicker && isSelectingFirstDate.update(v => !v);
    	}

    	function close() {
    		swapDatesIfRequired();
    		popover.close();
    	}

    	function popover_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			popover = $$value;
    			$$invalidate(5, popover);
    		});
    	}

    	const closed_handler = () => dispatch('close');

    	$$self.$$set = $$props => {
    		if ('range' in $$props) $$invalidate(24, range = $$props.range);
    		if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
    		if ('format' in $$props) $$invalidate(25, format = $$props.format);
    		if ('start' in $$props) $$invalidate(26, start = $$props.start);
    		if ('end' in $$props) $$invalidate(27, end = $$props.end);
    		if ('trigger' in $$props) $$invalidate(1, trigger = $$props.trigger);
    		if ('selectableCallback' in $$props) $$invalidate(28, selectableCallback = $$props.selectableCallback);
    		if ('styling' in $$props) $$invalidate(2, styling = $$props.styling);
    		if ('selected' in $$props) $$invalidate(23, selected = $$props.selected);
    		if ('closeOnFocusLoss' in $$props) $$invalidate(29, closeOnFocusLoss = $$props.closeOnFocusLoss);
    		if ('time' in $$props) $$invalidate(30, time = $$props.time);
    		if ('morning' in $$props) $$invalidate(31, morning = $$props.morning);
    		if ('night' in $$props) $$invalidate(32, night = $$props.night);
    		if ('minuteStep' in $$props) $$invalidate(33, minuteStep = $$props.minuteStep);
    		if ('continueText' in $$props) $$invalidate(3, continueText = $$props.continueText);
    		if ('$$scope' in $$props) $$invalidate(37, $$scope = $$props.$$scope);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$isDateChosen*/ 16) {
    			{
    				if ($isDateChosen) {
    					config.isRangePicker ? setRangeValue() : setDateValue();
    					dispatch('change');
    				}
    			}
    		}
    	};

    	return [
    		placeholder,
    		trigger,
    		styling,
    		continueText,
    		$isDateChosen,
    		popover,
    		$isOpen,
    		$isClosing,
    		$formatter,
    		dispatch,
    		startContextKey,
    		endContextKey,
    		config,
    		selectedStartDate,
    		selectedEndDate,
    		isOpen,
    		isClosing,
    		formatter,
    		isDateChosen,
    		isSelectingFirstDate,
    		initialisePicker,
    		addDate,
    		close,
    		selected,
    		range,
    		format,
    		start,
    		end,
    		selectableCallback,
    		closeOnFocusLoss,
    		time,
    		morning,
    		night,
    		minuteStep,
    		slots,
    		popover_1_binding,
    		closed_handler,
    		$$scope
    	];
    }

    class DatePicker extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$h,
    			create_fragment$i,
    			safe_not_equal,
    			{
    				range: 24,
    				placeholder: 0,
    				format: 25,
    				start: 26,
    				end: 27,
    				trigger: 1,
    				selectableCallback: 28,
    				styling: 2,
    				selected: 23,
    				closeOnFocusLoss: 29,
    				time: 30,
    				morning: 31,
    				night: 32,
    				minuteStep: 33,
    				continueText: 3
    			},
    			null,
    			[-1, -1]
    		);
    	}
    }

    /* src/components/Input/ClearInputButton.svelte generated by Svelte v3.42.4 */

    function create_if_block$3(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div = element("div");

    			div.innerHTML = `<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" role="presentation"><path fill="currentColor" d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124
      l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`;

    			attr(div, "class", "clear svelte-a9z6xt");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (!mounted) {
    				dispose = listen(div, "click", stop_propagation(/*click_handler*/ ctx[1]));
    				mounted = true;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$h(ctx) {
    	let if_block_anchor;
    	let if_block = /*visible*/ ctx[0] && create_if_block$3(ctx);

    	return {
    		c() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},
    		p(ctx, [dirty]) {
    			if (/*visible*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { visible = true } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('visible' in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	return [visible, click_handler];
    }

    class ClearInputButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$g, create_fragment$h, safe_not_equal, { visible: 0 });
    	}
    }

    /* src/components/Input/DateInput.svelte generated by Svelte v3.42.4 */

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i][0];
    	child_ctx[11] = list[i][1];
    	return child_ctx;
    }

    // (41:0) {:else}
    function create_else_block$1(ctx) {
    	let datepicker;
    	let current;

    	datepicker = new DatePicker({
    			props: {
    				selected: /*value*/ ctx[0] === 0
    				? new Date()
    				: new Date(/*value*/ ctx[0]),
    				format: "#{d}.#{m}.#{Y}",
    				start: new Date(2018, 1, 1),
    				end: inTwoMonths(),
    				continueText: "Speichern",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			}
    		});

    	datepicker.$on("date-selected", /*date_selected_handler*/ ctx[8]);

    	return {
    		c() {
    			create_component(datepicker.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(datepicker, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const datepicker_changes = {};

    			if (dirty & /*value*/ 1) datepicker_changes.selected = /*value*/ ctx[0] === 0
    			? new Date()
    			: new Date(/*value*/ ctx[0]);

    			if (dirty & /*$$scope, value*/ 16385) {
    				datepicker_changes.$$scope = { dirty, ctx };
    			}

    			datepicker.$set(datepicker_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(datepicker.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(datepicker.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(datepicker, detaching);
    		}
    	};
    }

    // (35:0) {#if disabled}
    function create_if_block$2(ctx) {
    	let input;
    	let input_value_value;

    	return {
    		c() {
    			input = element("input");
    			attr(input, "type", "text");

    			input.value = input_value_value = /*value*/ ctx[0] === 0
    			? "-"
    			: saveParseTimestampToString(/*value*/ ctx[0]);

    			input.disabled = true;
    			attr(input, "class", "svelte-d77rmw");
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*value*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[0] === 0
    			? "-"
    			: saveParseTimestampToString(/*value*/ ctx[0])) && input.value !== input_value_value) {
    				input.value = input_value_value;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(input);
    		}
    	};
    }

    // (42:2) <DatePicker     selected={value === 0 ? new Date() : new Date(value)}     on:date-selected={(event) => {       const date = event.detail.date;       const newTimeMillis =         date.getTime() - getTimeZoneOffsetMs(date.getTime());       if (millisAtStartOfDay(value) !== millisAtStartOfDay(newTimeMillis)) {         value = millisAtStartOfDay(newTimeMillis);         dispatch("change", date);       }       if (         showAlertOnPastDateSelection &&         millisAtStartOfDay(newTimeMillis) < millisAtStartOfToday()       ) {         alert(           "Achtung: Dieses Datum liegt in der Vergangenheit, bitte prüfe ob es korrekt ist."         );       }     }}     format={"#{d}.#{m}.#{Y}"}     start={new Date(2018, 1, 1)}     end={inTwoMonths()}     continueText={"Speichern"}   >
    function create_default_slot(ctx) {
    	let input;
    	let input_value_value;
    	let t;
    	let clearinputbutton;
    	let current;

    	clearinputbutton = new ClearInputButton({
    			props: { visible: /*value*/ ctx[0] !== 0 }
    		});

    	clearinputbutton.$on("click", /*click_handler*/ ctx[7]);

    	return {
    		c() {
    			input = element("input");
    			t = space();
    			create_component(clearinputbutton.$$.fragment);
    			attr(input, "type", "text");

    			input.value = input_value_value = /*value*/ ctx[0] === 0
    			? "-"
    			: saveParseTimestampToString(/*value*/ ctx[0]);

    			attr(input, "class", "svelte-d77rmw");
    		},
    		m(target, anchor) {
    			insert(target, input, anchor);
    			insert(target, t, anchor);
    			mount_component(clearinputbutton, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			if (!current || dirty & /*value*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[0] === 0
    			? "-"
    			: saveParseTimestampToString(/*value*/ ctx[0])) && input.value !== input_value_value) {
    				input.value = input_value_value;
    			}

    			const clearinputbutton_changes = {};
    			if (dirty & /*value*/ 1) clearinputbutton_changes.visible = /*value*/ ctx[0] !== 0;
    			clearinputbutton.$set(clearinputbutton_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(clearinputbutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(clearinputbutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(input);
    			if (detaching) detach(t);
    			destroy_component(clearinputbutton, detaching);
    		}
    	};
    }

    // (80:0) {#each Object.entries(quickset) as [days, text]}
    function create_each_block$4(ctx) {
    	let buttontight;
    	let current;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[9](/*days*/ ctx[10]);
    	}

    	buttontight = new ButtonTight({ props: { text: /*text*/ ctx[11] } });
    	buttontight.$on("click", click_handler_1);

    	return {
    		c() {
    			create_component(buttontight.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(buttontight, target, anchor);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const buttontight_changes = {};
    			if (dirty & /*quickset*/ 2) buttontight_changes.text = /*text*/ ctx[11];
    			buttontight.$set(buttontight_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(buttontight.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(buttontight.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(buttontight, detaching);
    		}
    	};
    }

    function create_fragment$g(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let each_1_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*disabled*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = Object.entries(/*quickset*/ ctx[1]);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c() {
    			if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(t.parentNode, t);
    			}

    			if (dirty & /*Object, quickset, addDays, parseInt*/ 66) {
    				each_value = Object.entries(/*quickset*/ ctx[1]);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach(each_1_anchor);
    		}
    	};
    }

    function inTwoMonths() {
    	const date = new Date();
    	date.setMonth(date.getMonth() + 2);
    	return date;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	const dispatch = createEventDispatcher();

    	const getTimeZoneOffsetMs = (millis = new Date().getTime()) => {
    		return new Date(millis).getTimezoneOffset() * 60000;
    	};

    	let { quickset = {} } = $$props;
    	let { value = 0 } = $$props;
    	let { disabled = false } = $$props;
    	let { showAlertOnPastDateSelection = false } = $$props;

    	function addDays(days) {
    		let date = new Date();
    		date.setDate(date.getDate() + days);
    		$$invalidate(0, value = millisAtStartOfDay(date.getTime()));
    	}

    	const click_handler = () => {
    		$$invalidate(0, value = 0);
    		dispatch("change", undefined);
    	};

    	const date_selected_handler = event => {
    		const date = event.detail.date;
    		const newTimeMillis = date.getTime() - getTimeZoneOffsetMs(date.getTime());

    		if (millisAtStartOfDay(value) !== millisAtStartOfDay(newTimeMillis)) {
    			$$invalidate(0, value = millisAtStartOfDay(newTimeMillis));
    			dispatch("change", date);
    		}

    		if (showAlertOnPastDateSelection && millisAtStartOfDay(newTimeMillis) < millisAtStartOfToday()) {
    			alert("Achtung: Dieses Datum liegt in der Vergangenheit, bitte prüfe ob es korrekt ist.");
    		}
    	};

    	const click_handler_1 = days => addDays(parseInt(days));

    	$$self.$$set = $$props => {
    		if ('quickset' in $$props) $$invalidate(1, quickset = $$props.quickset);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('showAlertOnPastDateSelection' in $$props) $$invalidate(3, showAlertOnPastDateSelection = $$props.showAlertOnPastDateSelection);
    	};

    	return [
    		value,
    		quickset,
    		disabled,
    		showAlertOnPastDateSelection,
    		dispatch,
    		getTimeZoneOffsetMs,
    		addDays,
    		click_handler,
    		date_selected_handler,
    		click_handler_1
    	];
    }

    class DateInput extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$f, create_fragment$g, safe_not_equal, {
    			quickset: 1,
    			value: 0,
    			disabled: 2,
    			showAlertOnPastDateSelection: 3
    		});
    	}
    }

    /* src/components/Input/Checkbox.svelte generated by Svelte v3.42.4 */

    function create_fragment$f(ctx) {
    	let checkbox;
    	let updating_checked;
    	let current;

    	const checkbox_spread_levels = [
    		{ class: "checkbox" },
    		{ size: "1.7rem" },
    		{ disabled: /*disabled*/ ctx[1] },
    		/*$$props*/ ctx[3]
    	];

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[4](value);
    	}

    	let checkbox_props = {};

    	for (let i = 0; i < checkbox_spread_levels.length; i += 1) {
    		checkbox_props = assign(checkbox_props, checkbox_spread_levels[i]);
    	}

    	if (/*value*/ ctx[0] !== void 0) {
    		checkbox_props.checked = /*value*/ ctx[0];
    	}

    	checkbox = new Checkbox({ props: checkbox_props });
    	binding_callbacks.push(() => bind$1(checkbox, 'checked', checkbox_checked_binding));
    	checkbox.$on("change", /*change_handler*/ ctx[5]);

    	return {
    		c() {
    			create_component(checkbox.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const checkbox_changes = (dirty & /*disabled, $$props*/ 10)
    			? get_spread_update(checkbox_spread_levels, [
    					checkbox_spread_levels[0],
    					checkbox_spread_levels[1],
    					dirty & /*disabled*/ 2 && { disabled: /*disabled*/ ctx[1] },
    					dirty & /*$$props*/ 8 && get_spread_object(/*$$props*/ ctx[3])
    				])
    			: {};

    			if (!updating_checked && dirty & /*value*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*value*/ ctx[0];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { value } = $$props;
    	let { disabled = false } = $$props;
    	let { onChange } = $$props;

    	function checkbox_checked_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	const change_handler = event => {
    		if (onChange) {
    			onChange(event.detail);
    		}
    	};

    	$$self.$$set = $$new_props => {
    		$$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('disabled' in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
    		if ('onChange' in $$new_props) $$invalidate(2, onChange = $$new_props.onChange);
    	};

    	$$props = exclude_internal_props($$props);
    	return [value, disabled, onChange, $$props, checkbox_checked_binding, change_handler];
    }

    class Checkbox_1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$e, create_fragment$f, safe_not_equal, { value: 0, disabled: 1, onChange: 2 });
    	}
    }

    var onSave$1 = async (customer, closePopup, createNew, formRef) => {
      if (!formRef.wasChecked && !formRef.checkValidity()) {
        formRef.wasChecked = true;
        warning('Einige benötigte Felder sind nicht (korrekt) ausgefüllt. Trotzdem speichern?');
        return;
      }

      if (
        await Database.fetchByIdAndType(customer.id, "customer").then((results) => {
          if (createNew) {
            return results.length > 0;
          } else {
            return results.some((result) => result._id !== customer._id);
          }
        })
      ) {
        danger("Ein/e Nutzer:in mit dieser Nummer existiert bereits!", 6000);
        return;
      }

      await (createNew
        ? Database.createDoc(customer)
        : Database.updateDoc(customer)
      )
        .then((result) => success("Nutzer:in gespeichert!"))
        .then(closePopup)
        .catch((error) => {
          danger("Nutzer:in konnte nicht gespeichert werden!", {
            persist: true,
          });
          Logger.error(error);
        });
    };

    var onDelete$2 = (customer, closePopup) => {
      if (confirm("Soll diese/r Nutzer:in wirklich gelöscht werden?")) {
        return Database.removeDoc(customer)
          .then(() => success("Nutzer:in gelöscht!"))
          .then(closePopup)
          .catch((error) => {
            Logger.error(error);
            danger("Nutzer:in konnte nicht gelöscht werden!", {
              persist: true,
            });
          });
      }
    };

    // initial values for new customers

    var initialValues$2 = {
      id: () => Database.nextUnusedId("customer"),
      registration_date: () => millisAtStartOfToday(),
      type: () => "customer",
      lastname: () => "",
      firstname: () => "",
      renewed_on: () => 0,
      remark: () => "",
      subscribed_to_newsletter: () => false,
      email: () => "",
      street: () => "",
      house_number: () => "",
      postal_code: () => "",
      city: () => "",
      telephone_number: () => "",
      heard: () => "",
      highlight: () => "",
    };

    var customerInputs = {
      title: (context) => `Nutzer:in ${context.createNew ? "anlegen" : "bearbeiten"}`,
      initialValues: initialValues$2,
      footerButtons: (context) => [
        {
          text: "Abbrechen",
          onClick: context.closePopup,
        },
        {
          text: "Löschen",
          onClick: () => onDelete$2(context.doc, context.closePopup),
          color: "red",
          hidden: context.createNew,
          loadingText: "Nutzer:in wird gelöscht",
        },
        {
          text: "Speichern",
          onClick: () => onSave$1(context.doc, context.closePopup, context.createNew, context.form),
          loadingText: "Nutzer:in wird gespeichert",
        },
      ],
      inputs: [
        {
          id: "id",
          label: "Nutzernummer",
          group: "ID und Name",
          component: TextInput,
          props: {
            pattern: "[0-9]+",
            required: true,
            onlyNumbers: true,
          },
        },
        {
          id: "firstname",
          label: "Vorname",
          group: "ID und Name",
          component: TextInput,
          props: { required: true },
        },
        {
          id: "lastname",
          label: "Nachname",
          group: "ID und Name",
          component: TextInput,
          props: { required: true },
        },
        {
          id: "street",
          label: "Straße",
          group: "Adresse",
          component: AutocompleteInput,
          props: {
            required: true,
            searchFunction: (context) => (searchTerm) =>
              Database.fetchUniqueCustomerFieldValues("street", searchTerm),
            noResultsText: "Straße noch nicht in Datenbank",
            valueField: "street",
          },
        },
        {
          id: "house_number",
          label: "Hausnummer",
          group: "Adresse",
          component: TextInput,
          props: { required: true },
        },
        {
          id: "postal_code",
          label: "Postleitzahl",
          group: "Adresse",
          component: AutocompleteInput,
          props: {
            required: true,
            onlyNumbers: true,
            searchFunction: (context) => (searchTerm) =>
              Database.fetchUniqueCustomerFieldValues(
                "postal_code",
                searchTerm,
                true
              ),
            valueField: "postal_code",
            noResultsText: "PLZ noch nicht in Datenbank",
          },
        },
        {
          id: "city",
          label: "Stadt",
          group: "Adresse",
          component: AutocompleteInput,
          props: {
            required: true,
            searchFunction: (context) => (searchTerm) =>
              Database.fetchUniqueCustomerFieldValues("city", searchTerm),
            valueField: "city",
            noResultsText: "Stadt noch nicht in Datenbank",
          },
        },
        {
          id: "email",
          label: "E-Mail",
          group: "Kontakt",
          component: TextInput,
          props: {
            required: true,
            pattern: ".+@.+\.[a-zA-Z]+",
          }
        },
        {
          id: "telephone_number",
          label: "Telefonnummer",
          group: "Kontakt",
          component: TextInput,
        },
        {
          id: "subscribed_to_newsletter",
          label: "Newsletter",
          group: "Kontakt",
          component: Checkbox_1,
        },
        {
          id: "registration_date",
          label: "Beitritt",
          group: "Mitgliedschaft",
          component: DateInput,
          props: {
            container: (context) => context.container,
          },
        },
        {
          id: "renewed_on",
          label: "Verlängert am",
          group: "Mitgliedschaft",
          component: DateInput,
          hidden: (context) => context.createNew,
          props: {
            quickset: { 0: "Heute" },
            container: (context) => context.container,
          },
        },
        {
          id: "heard",
          label: "Aufmerksam geworden",
          group: "Mitgliedschaft",
          component: SelectInput,
          props: {
            selectionOptions: [
              "Internet",
              "Freunde & Bekannte",
              "Zeitung / Medien",
              "Nachbarschaft",
            ],
            isCreatable: true,
            isMulti: true,
            isClearable: true,
          },
        },
        {
          id: "remark",
          label: "Bemerkung",
          group: "Sonstiges",
          component: TextInput,
        },
        {
          id: "highlight",
          label: "Markieren",
          group: "Sonstiges",
          component: SelectInput,
          props: {
            selectionOptions: [
              { value: "", label: "Nicht markieren" },
              {
                value: ColorDefs.HIGHLIGHT_GREEN,
                label:
                  "<a style='color:" + ColorDefs.HIGHLIGHT_GREEN + "'>■</a> Grün",
              },
              {
                value: ColorDefs.HIGHLIGHT_BLUE,
                label:
                  "<a style='color: " + ColorDefs.HIGHLIGHT_BLUE + "'>■</a> Blau",
              },
              {
                value: ColorDefs.HIGHLIGHT_YELLOW,
                label:
                  "<a style='color: " + ColorDefs.HIGHLIGHT_YELLOW + "'>■</a> Gelb",
              },
              {
                value: ColorDefs.HIGHLIGHT_RED,
                label:
                  "<a style='color: " + ColorDefs.HIGHLIGHT_RED + "'>■</a> Rot",
              },
            ],
            isClearable: true,
            isMulti: false,
          },
        },
      ],
    };

    const ONE_YEAR_AGO_MILLIS = new Date().getTime() - 1000 * 60 * 60 * 24 * 365;

    var customerFilters = {
      filters: {
        "Newsletter: Ja": {
          required_fields: ["subscribed_to_newsletter"],
          selectors: {
            subscribed_to_newsletter: {
              $eq: true,
            },
          },
        },
        "Newsletter: Nein": {
          required_fields: ["subscribed_to_newsletter"],
          selectors: {
            subscribed_to_newsletter: {
              $eq: false,
            },
          },
        },
        "Beitritt vor > 1 Jahr": {
          required_fields: ["registration_date"],
          selectors: {
            registration_date: {
              $lt: ONE_YEAR_AGO_MILLIS,
            },
          },
        },
        "Beitritt vor < 1 Jahr": {
          required_fields: ["registration_date"],
          selectors: {
            registration_date: {
              $gt: ONE_YEAR_AGO_MILLIS,
            },
          },
        },
        "Verlängert vor > 1 Jahr": {
          required_fields: ["renewed_on"],
          selectors: {
            renewed_on: {
              $lt: ONE_YEAR_AGO_MILLIS,
            },
          },
        },
        "Verlängert vor < 1 Jahr": {
          required_fields: ["renewed_on"],
          selectors: {
            renewed_on: {
              $gt: ONE_YEAR_AGO_MILLIS,
            },
          },
        },
      },
      activeByDefault: [],
    };

    const customerIdStartsWithSelector = (searchValue) =>
      Database.selectorBuilder()
        .withField("id")
        .numericFieldStartsWith(searchValue)
        .withDocType("customer")
        .build();

    const itemIdStartsWithAndNotDeletedSelector = (searchValue) =>
      Database.selectorBuilder()
        .withField("id")
        .numericFieldStartsWith(searchValue)
        .withDocType("item")
        .withField("status")
        .isNotEqualTo("deleted")
        .build();

    const customerAttributeStartsWithIgnoreCaseSelector = (field, searchValue) =>
      Database.selectorBuilder()
        .withField(field)
        .startsWithIgnoreCaseAndDiacritics(searchValue)
        .withDocType("customer")
        .build();

    const itemAttributeStartsWithIgnoreCaseAndNotDeletedSelector = (
      field,
      searchValue
    ) =>
      Database.selectorBuilder()
        .withField(field)
        .startsWithIgnoreCase(searchValue)
        .withField("status")
        .isNotEqualTo("deleted")
        .withDocType("item")
        .build();

    const activeRentalsForCustomerSelector = (customerId) =>
      Database.selectorBuilder()
        .withDocType("rental")
        .withField("customer_id")
        .equals(customerId)
        .withField("returned_on")
        .equals(0)
        .build();

    const customerById = (customerId) =>
      Database.selectorBuilder()
        .withDocType("customer")
        .withField("id")
        .equals(customerId)
        .build();

    const itemById = (itemId) =>
      Database.selectorBuilder()
        .withDocType("item")
        .withField("id")
        .equals(itemId)
        .build();

    var customerDataHooks = {
        // this function allows to either block entire data table loading by returning a pending promise
        // or return immediately, but resolve individual values asynchronously instead
        async onDataLoaded(data) {
            const rentalCountResolvers = data.map(() => Promise.withResolvers());
            const activeRentalCountResolvers = data.map(() => Promise.withResolvers());

            async function fetchAll() {
              const allRentals = await Database.getRentalsByEntity('customer', data.map(c => c.id), ['customer_id', 'returned_on']);
              const activeRentals = allRentals.filter(r => r.returned_on === 0);
      
              const allRentalsCount = Database.countByKey(allRentals, 'customer_id');
              const activeRentalsCount = Database.countByKey(activeRentals, 'customer_id');

              data.forEach((e, i) => {
                rentalCountResolvers[i].resolve(allRentalsCount[e.id] || 0);
                activeRentalCountResolvers[i].resolve(activeRentalsCount[e.id] || 0);
              });
            }

            fetchAll();  // intentionally not awaited!

            data.forEach((e, i) => {
              e.rental_count = rentalCountResolvers[i].promise;
              e.active_rental_count = activeRentalCountResolvers[i].promise;
            });
            return data
      }
    };

    class WoocommerceClientMock {
      constructor() {}

      async fetchItem(wcItemId) {
        await new Promise((r) => setTimeout(r, 1500));
        const item = testdata.docs.find((item) => item.wc_id == wcItemId);
        if (wcItemId && item) {
          return {
            stock_status: item.status,
            attributes: [
              {
                options: [item.deposit + " €"],
              },
            ],
            ...(item.image && {
              images: [
                {
                  src: item.image,
                },
              ],
            }),
            permalink: item.wc_url,
            categories: [
              {
                name: item.category,
              },
            ],
          };
        } else {
          throw new Error("Failed to load wc product, http response code 404");
        }
      }

      _translateItemAttributesForWc(item) {
        const isRentedAndHasReturnDateInFuture =
          item.expected_return_date && item.status == "outofstock" ? true : false;

        console.log(
          "expected return date",
          item.expected_return_date,
          isRentedAndHasReturnDateInFuture
        );
      }

      async updateItem(item) {
        this._translateItemAttributesForWc(item);
        await new Promise((r) => setTimeout(r, 1500));
      }

      async deleteItem(item) {
        await new Promise((r) => setTimeout(r, 1500));
      }

      async createItem(item) {
        this._translateItemAttributesForWc(item);
        await new Promise((r) => setTimeout(r, 1500));
        return {
          permalink: "link",
          id: "wcId",
        };
      }
    }

    var WoocommerceClient = new WoocommerceClientMock();

    const setNumericValuesDefault0 = (doc, columns) => {
      Object.keys(doc).forEach((key) => {
        const colForKey = columns.find((col) => col.key === key);
        if (colForKey && colForKey.numeric && doc[key] === "") {
          doc[key] = 0; // default value for numbers
        }
      });
    };

    var onCreate = async (item, closePopup, formRef) => {
      if (!formRef.wasChecked && !formRef.checkValidity()) {
        formRef.wasChecked = true;
        warning('Einige benötigte Felder sind nicht (korrekt) ausgefüllt. Trotzdem speichern?');
        return;
      }

      if (
        await Database.fetchByIdAndType(item.id, "item").then(
          (results) => results.length > 0
        )
      ) {
        danger(
          "Ein Gegenstand mit dieser Nummer existiert bereits!",
          6000
        );
        return;
      }

      setNumericValuesDefault0(item, itemColumns);

      // create item on woocommerce first to store wc_id in db afterwards
      // await needed here so that a wc_id is created and stored in db before the user can edit the item again
      await WoocommerceClient.createItem(item)
        .then((wcDoc) => {
          item.wc_url = wcDoc.permalink;
          item.wc_id = wcDoc.id;
          success("Gegenstand auf der Webseite erstellt!", 3000);
        })
        .catch((error) => {
          warning(
            "Gegenstand konnte auf der Webseite nicht erstellt werden!",
            {
              persist: true,
            }
          );
          Logger.error(error);
        })
        // create in db even if creating item in woocommerce fails
        .then(() => Database.createDoc(item))
        .then(closePopup)
        .then(() => success("Gegenstand gespeichert!"))
        .catch((error) => {
          danger("Gegenstand konnte nicht gespeichert werden!", {
            persist: true,
          });
          Logger.error(error);
        });
    };

    var onDelete$1 = async (item, closePopup) => {
      if (confirm("Soll dieser Gegenstand wirklich gelöscht werden?")) {
        item.status = "deleted";
        await Database.updateDoc(item)
          .then(() => success("Gegenstand als gelöscht markiert!"))
          .then(closePopup)
          .catch((error) => {
            Logger.error(error);
            danger("Gegenstand konnte nicht gelöscht werden!", {
              persist: true,
            });
          });

        await WoocommerceClient.deleteItem(item)
          .then(() =>
            success("Gegenstand von der Webseite gelöscht!", 3000)
          )
          .catch((error) => {
            warning(
              "Gegenstand konnte nicht von der Webseite gelöscht werden!",
              {
                persist: true,
              }
            );
            Logger.error(error);
          });
      }
    };

    var onUpdate = async (item, closePopup, formRef) => {
      if (!formRef.wasChecked && !formRef.checkValidity()) {
        formRef.wasChecked = true;
        warning('Einige benötigte Felder sind nicht (korrekt) ausgefüllt. Trotzdem speichern?');
        return;
      }

      if (
        await Database.fetchByIdAndType(item.id, "item").then((results) =>
          results.some((result) => result._id !== item._id)
        )
      ) {
        danger(
          "Ein Gegenstand mit dieser Nummer existiert bereits!",
          6000
        );
        return;
      }

      setNumericValuesDefault0(item, itemColumns);

      await Database.updateDoc(item)
        .then(closePopup)
        .then(() => success("Gegenstand gespeichert!"))
        .catch((error) => {
          danger("Gegenstand konnte nicht gespeichert werden!", 6000);
          Logger.error(error);
        });

      // no await to update woocommerce in background
      WoocommerceClient.updateItem(item)
        .then(() =>
          success("Gegenstand auf der Webseite aktualisiert!", 3000)
        )
        .catch((error) => {
          warning(
            "Gegenstand auf der Webseite konnte nicht aktualisiert werden!",
            6000
          );
          Logger.error(error);
        });
    };

    var onRestore = async (item, closePopup) => {
      if (confirm("Soll dieser Gegenstand wiederhergestellt werden?")) {
        let doc = (await Database.fetchDocsBySelector(itemById(item.id)))[0];
        doc.status = "instock";
        await WoocommerceClient.createItem(doc)
          .then((wcDoc) => {
            success("Gegenstand auf der Webseite erstellt!", 3000);
            doc.wc_url = wcDoc.permalink;
            doc.wc_id = wcDoc.id;
            return Database.updateDoc(doc);
          })
          .then(closePopup)
          .catch((error) => {
            warning(
              "Gegenstand konnte auf der Webseite nicht erstellt werden!",
              6000
            );
            Logger.error(error);
          });
      }
    };

    // initial values for new customers

    var initialValues$1 = {
      id: () => Database.nextUnusedId("item"),
      added: () => millisAtStartOfToday(),
      status: () => "instock",
      type: () => "item",
      name: () => "",
      brand: () => "",
      itype: () => "",
      category: () => "",
      deposit: () => "",
      parts: () => "",
      exists_more_than_once: () => false,
      manual: () => "",
      package: () => "",
      wc_url: () => "",
      wc_id: () => "",
      image: () => "",
      highlight: () => "",
      synonyms: () => "",
      description: () => "",
    };

    const isDeleted = (context) => context.doc.status === "deleted";

    var itemInputs = {
      title: (context) =>
        `Gegenstand ${context.createNew ? "anlegen" : "bearbeiten"}`,
      initialValues: initialValues$1,
      height: "20rem",
      footerButtons: (context) => [
        {
          text: "Abbrechen",
          onClick: context.closePopup,
        },
        {
          text: "Löschen",
          onClick: () => onDelete$1(context.doc, context.closePopup),
          color: "red",
          hidden: context.doc.status === "deleted" || context.createNew,
          loadingText: "Gegenstand wird gelöscht",
        },
        {
          text: "Wiederherstellen",
          onClick: () => onRestore(context.doc, context.closePopup),
          color: "green",
          hidden: context.doc.status !== "deleted",
          loadingText: "Gegenstand wird wiederhergestellt",
        },
        {
          text: "Speichern",
          onClick: context.createNew
            ? () => onCreate(context.doc, context.closePopup, context.form)
            : () => onUpdate(context.doc, context.closePopup, context.form),
          loadingText: "Gegenstand wird gespeichert",
        },
      ],
      inputs: [
        {
          id: "id",
          label: "Nr",
          group: "Bezeichnung",
          component: TextInput,
          props: {
            required: true,
            onlyNumbers: true,
            pattern: "[0-9]+",
            disabled: isDeleted,
          },
        },
        {
          id: "name",
          label: "Name",
          group: "Bezeichnung",
          component: TextInput,
          props: {
            required: true,
            disabled: isDeleted,
          },
        },
        {
          id: "brand",
          label: "Marke",
          group: "Bezeichnung",
          component: TextInput,
          props: {
            disabled: isDeleted,
          },
        },
        {
          id: "itype",
          label: "Typbezeichnung",
          group: "Bezeichnung",
          component: TextInput,
          props: {
            disabled: isDeleted,
          },
        },
        {
          id: "category",
          label: "Kategorie",
          group: "Eigenschaften",
          component: SelectInput,
          props: {
            disabled: isDeleted,
            selectionOptions: [
              "Küche",
              "Haushalt",
              "Garten",
              "Kinder",
              "Freizeit",
              "Heimwerker",
            ],
            isCreatable: false,
            isMulti: true,
            isClearable: true,
          },
        },
        {
          id: "deposit",
          label: "Pfand",
          group: "Eigenschaften",
          component: TextInput,
          props: {
            onlyNumbers: true,
            disabled: isDeleted,
          },
        },
        {
          id: "added",
          label: "Erfasst am",
          group: "Eigenschaften",
          component: DateInput,
          props: {
            disabled: isDeleted,
            container: (context) => context.container,
          },
        },
        {
          id: "description",
          label: "Beschreibung",
          group: "Beschreibung",
          component: TextInput,
          props: {
            multiline: true,
            disabled: isDeleted,
          },
        },
        {
          id: "synonyms",
          label: "Synonyme",
          group: "Beschreibung",
          component: SelectInput,
          props: {
            isCreatable: true,
            isMulti: true,
            isClearable: true,
            placeholder: "Synonyme anlegen",
            disabled: isDeleted,
          },
        },

        {
          id: "parts",
          label: "Anzahl Teile",
          group: "Eigenschaften",
          component: TextInput,
          props: {
            disabled: isDeleted,
          },
        },

        {
          id: "image",
          label: "Bild",
          group: "Bild",
          component: TextInput,
          props: {
            disabled: isDeleted,
          },
        },

        {
          id: "status",
          label: "Status",
          group: "Status",
          component: SelectInput,
          props: {
            selectionOptions: [
              { value: "instock", label: "verfügbar" },
              { value: "outofstock", label: "verliehen" },
              { value: "onbackorder", label: "nicht verleihbar" },
              { value: "reserved", label: "reserviert" },
              { value: "lost", label: "verschollen" },
              { value: "repairing", label: "in Reparatur" },
              { value: "forsale", label: "zu verkaufen" },
            ],
            isCreatable: false,
            isMulti: false,
            isClearable: false,
            disabled: isDeleted,
          },
        },
        {
          id: "exists_more_than_once",
          label: "Mehrmals vorhanden",
          group: "Status",
          component: Checkbox_1,
          props: {
            disabled: isDeleted,
          },
        },
        {
          id: "highlight",
          label: "Markieren",
          group: "Status",
          component: SelectInput,
          props: {
            selectionOptions: [
              { value: "", label: "Nicht markieren" },
              {
                value: ColorDefs.HIGHLIGHT_GREEN,
                label:
                  "<a style='color:" + ColorDefs.HIGHLIGHT_GREEN + "'>■</a> Grün",
              },
              {
                value: ColorDefs.HIGHLIGHT_BLUE,
                label:
                  "<a style='color: " + ColorDefs.HIGHLIGHT_BLUE + "'>■</a> Blau",
              },
              {
                value: ColorDefs.HIGHLIGHT_YELLOW,
                label:
                  "<a style='color: " + ColorDefs.HIGHLIGHT_YELLOW + "'>■</a> Gelb",
              },
              {
                value: ColorDefs.HIGHLIGHT_RED,
                label:
                  "<a style='color: " + ColorDefs.HIGHLIGHT_RED + "'>■</a> Rot",
              },
            ],
            isClearable: true,
            isMulti: false,
            disabled: isDeleted,
          },
        },
        {
          id: "internal_note",
          label: "Interne Notiz",
          group: "Status",
          component: TextInput,
          props: {
            multiline: true,
          },
        },
      ],
    };

    var itemFilters = {
      filters: {
        "nicht gelöscht": {
          required_fields: ["status"],
          selectors: {
            status: {
              $ne: "deleted",
            },
          },
        },
        gelöscht: {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "deleted",
            },
          },
        },
        verfügbar: {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "instock",
            },
          },
        },
        ausgeliehen: {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "outofstock",
            },
          },
        },
        reserviert: {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "reserved",
            },
          },
        },
        "nicht verleihbar": {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "onbackorder",
            },
          },
        },
        "verschollen": {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "lost",
            },
          },
        },
        "in Reparatur": {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "repairing",
            },
          },
        },
        "zu verkaufen": {
          required_fields: ["status"],
          selectors: {
            status: {
              $eq: "forsale",
            },
          },
        },
        "Kategorie Küche": {
          required_fields: ["category"],
          selectors: {
            category: {
              $eq: "Küche",
            },
          },
        },
        "Kategorie Haushalt": {
          required_fields: ["category"],
          selectors: {
            category: {
              $eq: "Haushalt",
            },
          },
        },
        "Kategorie Garten": {
          required_fields: ["category"],
          selectors: {
            category: {
              $eq: "Garten",
            },
          },
        },
        "Kategorie Heimwerker": {
          required_fields: ["category"],
          selectors: {
            category: {
              $eq: "Heimwerker",
            },
          },
        },
        "Kategorie Kinder": {
          required_fields: ["category"],
          selectors: {
            category: {
              $eq: "Kinder",
            },
          },
        },
        "Kategorie Freizeit": {
          required_fields: ["category"],
          selectors: {
            category: {
              $eq: "Freizeit",
            },
          },
        },
      },
      activeByDefault: ["nicht gelöscht"],
    };

    var itemDataHooks = {
        // this function allows to either block entire data table loading by returning a pending promise
        // or return immediately, but resolve individual values asynchronously instead
        async onDataLoaded(data) {
            const rentalCountResolvers = data.map(() => Promise.withResolvers());

            async function fetchAll() {
              const allRentals = await Database.getRentalsByEntity('item', data.map(i => i.id), ['item_id']);
              const counts = Database.countByKey(allRentals, 'item_id');
              data.forEach((e, i) => rentalCountResolvers[i].resolve(counts[e.id] || 0));
            }

            fetchAll();  // intentionally not awaited!

            data.forEach((e, i) => {
              e.rental_count = rentalCountResolvers[i].promise;
            });
            return data
        }
    };

    const createKeyValueStore = () => {
      const store = writable({});

      return {
        ...store,
        setValue: (key, value) =>
          store.update((formularStore) => ({
            ...formularStore,
            [key]: value,
          })),
        removeValue: (key) =>
          store.update((formularStore) => {
            const { [key]: _, ...rest } = formularStore;
            return rest;
          }),
      };
    };

    const createRecentEmployeesArray = () => {
      // the array will simply keep growing and items will be double.
      // however we should never run into performance problems
      // as there are only a couple of dozens of entries created per day
      const store = writable(new Array());

      return {
        ...store,
        add: (string) =>
          store.update((prevStore) =>
            string ? [...prevStore, string] : prevStore
          ),
      };
    };

    createKeyValueStore();
    const recentEmployeesStore = createRecentEmployeesArray();

    const fetchItemById = async (itemId) => {
      try {
        return (await Database.fetchDocsBySelector(itemById(itemId)))[0];
      } catch (error) {
        Logger.error(error);
        throw `Failed to load item with id ${itemId}`;
      }
    };

    const newItemStatus = (rental) => {
      if (
        (rental.returned_on &&
          rental.returned_on !== 0 &&
          rental.returned_on <= new Date().getTime()) || // already returned
        rental.rented_on > new Date().getTime() // or not yet rented
      ) {
        return "instock";
      } else {
        return "outofstock";
      }
    };

    const getExpReturnDate = (item, rental) => {
      const hasReturnDateInFuture =
        item.status === "outofstock" &&
        rental &&
        rental.to_return_on &&
        rental.to_return_on >= millisAtStartOfToday() &&
        !rental.returned_on;

      let expReturnDate = "";
      if (item.status === "reserved") {
        expReturnDate = "Reserviert und noch nicht abgeholt";
      } else if (hasReturnDateInFuture) {
        expReturnDate = saveParseTimestampToString(rental.to_return_on);
      }
      return expReturnDate;
    };

    const updateItemStatus = async (item, status, rental) => {
      item.status = status;
      item.expected_return_date = getExpReturnDate(item, rental);
      await Database.updateDoc(item);
      await WoocommerceClient.updateItem(item);
      success(
        `'${item.name}' wurde als ${
      item.status === "instock" ? "verfügbar" : "verliehen"
    } markiert.`
      );
    };

    async function onReturnAndSave(context, employee) {
      const { doc, closePopup, createNew, contextVars } = context;

      if (createNew) {
        Logger.error("createNew is true if it should be false");
        return; // just for safety
      }
      doc.deposit_returned = doc.deposit_returned
        ? doc.deposit_returned
        : doc.deposit;
      doc.receiving_employee = doc.receiving_employee
        ? doc.receiving_employee
        : employee;
      doc.returned_on = doc.returned_on ? doc.returned_on : millisAtStartOfToday();
      await onSave(context);
    }

    async function onSave(context) {
      const { doc, closePopup, createNew, contextVars, form } = context;

      if (!form.wasChecked && !form.checkValidity()) {
        // "Soft-require" temporarily disabled -> mandatorily require all required fields for rentals
        // form.wasChecked = true;
        // notifier.warning('Einige benötigte Felder sind nicht (korrekt) ausgefüllt. Trotzdem speichern?');
        danger('Nicht alle benötigten Felder sind (korrekt) ausgefüllt.', 3000);
        return;
      }

      setNumericValuesDefault0(doc, rentalColumns);
      // item changed, reset initial item to status available
      if (
        contextVars.initialItemId !== undefined &&
        contextVars.initialItemId !== doc.item_id
      ) {
        try {
          const initialItem = await fetchItemById(contextVars.initialItemId);
          await updateItemStatus(initialItem, "instock");
          warning(
            `Status von '${contextVars.initialItemName}' wurde auf 'verfügbar' geändert. Bitter überprüfe ob das stimmt.`,
            { persist: true }
          );
        } catch (error) {
          Logger.error(
            `Failed to update status of initial item with name ${contextVars.initialItemName} id ${contextVars.initialItemId}, ${error}`
          );
          warning(
            `Status von '${contextVars.initialItemName}' konnte nicht aktualisiert werden. Bitte überprüfe den Status dieses Gegenstandes.`,
            { persist: true }
          );
        }
      }

      if (contextVars.updateItemStatus) {
        try {
          const item = await fetchItemById(doc.item_id);
          doc.image = item.image;
          await updateItemStatus(item, newItemStatus(doc), doc);
        } catch (error) {
          Logger.error(
            `Failed to update status of item with id ${doc.item_id}, ${error}`
          );

          danger(
            `Status des Gegenstandes mit ID '${doc.item_id}' konnte nicht aktualisiert werden!`,
            { persist: true }
          );
        }
      } else {
        Logger.debug(
          `Did not update item of rental ${doc._id} because updateItemStatus is false.`
        );
      }

      await (createNew ? Database.createDoc(doc) : Database.updateDoc(doc))
        .then((_) => success("Leihvorgang gespeichert!"))
        .then(() => recentEmployeesStore.add(doc.passing_out_employee))
        .then(() => recentEmployeesStore.add(doc.receiving_employee))
        .then(closePopup)
        .catch((error) => {
          danger("Leihvorgang konnte nicht gespeichert werden!", {
            persist: true,
          });
          Logger.error(error);
        });
    }

    var onDelete = async (rental, closePopup) => {
      if (confirm("Soll dieser Leihvorgang wirklich gelöscht werden?")) {
        Database.removeDoc(rental)
          .then(() => success("Leihvorgang gelöscht!"))
          .then(closePopup)
          .catch((error) => {
            Logger.error(error);
            danger("Leihvorgang konnte nicht gelöscht werden!", 6000);
          });
      }
    };

    // initial values for new customers

    var initialValues = {
      rented_on: () => millisAtStartOfToday(),
      to_return_on: () =>
        millisAtStartOfDay(new Date().getTime() + 7 * 24 * 60 * 60 * 1000),
      returned_on: () => 0,
      extended_on: () => 0,
      type: () => "rental",
      image: () => "",
      item_id: () => "",
      item_name: () => "",
      customer_id: () => "",
      customer_name: () => "",
      passing_out_employee: () => "",
      receiving_employee: () => "",
      deposit: () => "",
      deposit_returned: () => "",
      remark: () => "",
    };

    /**
     * Whether the toggle for updateStatusOnWebsite is hidden.
     */
    var hideToggleUpdateItemStatus = false;

    const updateToggleStatus = (context, itemExistsMoreThanOnce) => {
      if (itemExistsMoreThanOnce) {
        context.contextVars.updateItemStatus = false;
        hideToggleUpdateItemStatus = true;
      } else {
        hideToggleUpdateItemStatus = false;
      }
    };

    function getRecentEmployees() {
      var employeeObj = {};
      for (let employee of get_store_value(recentEmployeesStore)) {
        employeeObj[employee] = employee;
      }
      return employeeObj;
    }

    function suggestReceivingEmployee(context) {
      if (context.doc.receiving_employee != "") {
        return context.doc.receiving_employee;
      }

      let mostRecent;
      // retrieve last element of array
      for (mostRecent of get_store_value(recentEmployeesStore));

      if (!mostRecent) {
        // if none is in the store, assume the passing out employee is currently working
        mostRecent = context.doc.passing_out_employee;
      }
      return mostRecent;
    }

    const updateItemOfRental = (context, item) => {
      if (context.doc.item_id !== item.id) {
        context.updateDoc({
          item_id: item.id,
          item_name: item.name,
          deposit: item.deposit,
        });
        updateToggleStatus(context, item.exists_more_than_once);
        showNotificationsForItem(item);
      }
    };

    const updateCustomerOfRental = (context, customer) => {
      context.updateDoc({
        customer_name: customer.lastname,
        customer_id: customer.id,
      });
      showNotificationsForCustomer(customer.id);
    };

    const showNotificationsForItem = async (item) => {
      // show notification if not available
      var statusMapping = {
        instock: "verfügbar",
        outofstock: "verliehen",
        reserved: "reserviert",
        onbackorder: "temporär nicht verfügbar / in Reparatur",
        lost: "verschollen",
        repairing: "in Reparatur",
        forsale: "zu verkaufen",
      };
      var status = statusMapping[item.status];
      if (["outofstock", "reserved", "onbackorder", "lost", "repairing", "forsale"].includes(item.status)) {
        danger(
          `${item.name} (${item.id}) ist nicht verfügbar, hat Status: ${status}`,
          10000
        );
      } else if (item.status == "undefined") {
        warning(
          `Fehler beim Statuscheck, ${item.name} (${item.id}) hat Status: ${status}`,
          10000
        );
      }
      // show notification it item is highlighted in a color
      if (item.highlight && item.highlight !== "") {
        const colorDescription = itemColorToDescription(item.highlight);
        info(
          `${item.name} (${item.id}) wurde farblich markiert: ${colorDescription}`,
          {
            persist: true,
          }
        );
      }
    };

    let sortItemByIdOrName = (itemA, itemB) => {
      // check if itemX exists at all
      if ((itemA == undefined) | (itemB == undefined)) {
        return 0;
      }
      // if has id and id is numerical compare id
      if (
        (itemA.id !== undefined) &
        (itemB.id !== undefined) &
        !(isNaN(itemA.id) | isNaN(itemB.id))
      ) {
        return itemA.id - itemB.id;
      }

      // maybe itemA and itemB themselve are numerical?
      if (!(isNaN(itemA) | isNaN(itemB))) {
        return itemA - itemB;
      }

      // inputs are not numerically sortable
      return 0;
    };

    const showNotificationsForCustomer = async (customerId) => {
      Database.fetchAllDocsBySelector(
        activeRentalsForCustomerSelector(customerId),
        ["item_name"]
      )
        .then((results) => results.map((doc) => doc["item_name"]))
        .then((activeRentals) => {
          if (activeRentals.length > 0 && activeRentals.length < 3) {
            warning(
              `Nutzer:in hat schon diese Gegenstände ausgeliehen: ${activeRentals.join(
            ", "
          )}`,
              6000
            );
          } else if (activeRentals.length >= 3) {
            danger(
              `Nutzer:in hat schon mehr als 2 Gegenstände ausgeliehen: ${activeRentals.join(
            ", "
          )}`,
              6000
            );
          }
        });

      Database.fetchAllDocsBySelector(customerById(customerId), [
        "remark",
        "highlight",
      ]).then((results) => {
        if (
          // first check if there is a remark
          results.length > 0 &&
          results[0]["remark"] &&
          results[0]["remark"] !== ""
        ) {
          danger(results[0]["remark"], { persist: true });
        }
        if (
          // then check if customer is highlighted
          results.length > 0 &&
          results[0]["highlight"] &&
          results[0]["highlight"] !== ""
        ) {
          const colorDescription = customerColorToDescription(
            results[0]["highlight"]
          );
          info(
            "Diese/r Nutzer:in wurde farblich markiert: " + colorDescription,
            { persist: true }
          );
        }
      });
    };

    var rentalInputs = {
      title: (context) =>
        `Leihvorgang ${context.createNew ? "anlegen" : "bearbeiten"}`,
      initialValues,
      onMount: (context) => () => {
        hideToggleUpdateItemStatus = false;
        /**
         * Whether the status of the selected item should be updated when a rental is created or completed.
         * For items existing more than once this should always be false. For other items this can be toggled by the user.
         */
        context.contextVars.updateItemStatus = true;

        /**
         * The id of the item that belongs to this rental at the time of opening the input form. This is required to
         * check if the item was changed when saving the rental.
         */
        context.contextVars.initialItemId = context.doc.item_id;
        context.contextVars.initialItemName = context.doc.item_name;

        if (context.doc.item_id) {
          Database.fetchDocsBySelector(itemById(context.doc.item_id), [
            "id",
            "name",
            "deposit",
            "exists_more_than_once",
          ]).then((items) => updateItemOfRental(context, items[0]));
        }
      },
      footerButtons: (context) => [
        {
          text: "Abbrechen",
          onClick: context.closePopup,
        },
        {
          text: "Löschen",
          onClick: () => onDelete(context.doc, context.closePopup),
          color: "red",
          hidden: context.createNew,
          loadingText: "Leihvorgang wird gelöscht",
        },
        {
          text: `Zurückgeben ${
        suggestReceivingEmployee(context)
          ? `\n(als ${suggestReceivingEmployee(context)})`
          : ""
      }`,
          onClick: () =>
            onReturnAndSave(context, suggestReceivingEmployee(context)),
          color: "green",
          hidden: context.createNew,
          loadingText: "Leihvorgang wird abgeschlossen",
        },

        {
          text: "Speichern",
          onClick: () => onSave(context),
          loadingText: "Leihvorgang wird gespeichert",
        },
      ],
      inputs: [
        {
          id: "item_id",
          label: "Nr",
          group: "Gegenstand",
          component: AutocompleteInput,
          nobind: true,
          props: {
            required: true,
            localSorting: true,
            sortByMatchedKeywords: true,
            itemSortFunction: () => sortItemByIdOrName,
            valueField: "id",
            onlyNumbers: true,
            searchFunction: (context) => (searchTerm) =>
              Database.fetchDocsBySelector(
                itemIdStartsWithAndNotDeletedSelector(searchTerm),
                [
                  "id",
                  "name",
                  "deposit",
                  "exists_more_than_once",
                  "status",
                  "highlight",
                ]
              ),
            suggestionFormat: (context) => (id, item_name) =>
              `${String(id).padStart(4, "0")}: ${item_name}`,
            noResultsText: "Kein Gegenstand mit dieser Id",
            onSelected: (context) => (selectedItem) => {
              updateItemOfRental(context, selectedItem);
            },
          },
        },

        {
          id: "item_name",
          label: "Name",
          group: "Gegenstand",
          component: AutocompleteInput,
          nobind: true,
          props: {
            valueField: "name",
            searchFunction: (context) => (searchTerm) =>
              Database.fetchDocsBySelector(
                itemAttributeStartsWithIgnoreCaseAndNotDeletedSelector(
                  "name",
                  searchTerm
                ),
                ["id", "name", "deposit", "exists_more_than_once"]
              ),
            suggestionFormat: (context) => (id, item_name) =>
              `${String(id).padStart(4, "0")}: ${item_name}`,
            noResultsText: "Kein Gegenstand mit diesem Name",
            onSelected: (context) => (selectedItem) => {
              updateItemOfRental(context, selectedItem);
            },
          },
        },
        {
          id: "update_status",
          label: "Status aktualisieren",
          group: "Gegenstand",
          component: Checkbox_1,
          nobind: true,
          hidden: () => hideToggleUpdateItemStatus,
          props: {
            value: (context) => context.contextVars.updateItemStatus,
            // onChange callback necessary because bind only works for doc attributes
            onChange: (context) => (value) =>
              (context.contextVars.updateItemStatus = value),
          },
        },

        {
          id: "rented_on",
          label: "Ausgeliehen am",
          group: "Zeitraum",
          component: DateInput,
          props: {
            container: (context) => context.container,
          },
        },
        {
          id: "extended_on",
          label: "Verlängert am",
          group: "Zeitraum",
          hidden: (context) => context.createNew,
          component: DateInput,
          props: {
            quickset: { 0: "Heute" },
            container: (context) => context.container,
          },
        },
        {
          id: "to_return_on",
          label: "Zurückerwartet am",
          group: "Zeitraum",
          component: DateInput,
          props: {
            quickset: { 7: "1 Woche", 14: "2 Wochen", 21: "3 Wochen" },
            container: (context) => context.container,
            showAlertOnPastDateSelection: true,
          },
        },
        {
          id: "returned_on",
          label: "Zurückgegeben am",
          group: "Zeitraum",
          component: DateInput,
          hidden: (context) => context.createNew,
          props: {
            quickset: { 0: "Heute" },
            container: (context) => context.container,
          },
        },

        {
          id: "customer_id",
          label: "Nr",
          group: "Nutzer:in",
          component: AutocompleteInput,
          nobind: true,
          props: {
            required: true,
            localSorting: true,
            sortByMatchedKeywords: true,
            itemSortFunction: () => sortItemByIdOrName,
            localFiltering: true,
            valueField: "id",
            onlyNumbers: true,
            searchFunction: (context) => (searchTerm) =>
              Database.fetchDocsBySelector(
                customerIdStartsWithSelector(searchTerm),
                ["id", "firstname", "lastname"],
                ["id"]
              ),
            suggestionFormat: (context) => (id, firstname, lastname) =>
              `${id}: ${firstname} ${lastname}`,
            noResultsText: "Kein/e Nutzer:in mit dieser Nummer",
            onSelected: (context) => (selectedCustomer) => {
              updateCustomerOfRental(context, selectedCustomer);
            },
          },
        },
        {
          id: "customer_name",
          label: "Nachname",
          group: "Nutzer:in",
          component: AutocompleteInput,
          nobind: true,
          props: {
            valueField: "lastname",
            searchFunction: (context) => (searchTerm) =>
              Database.fetchDocsBySelector(
                customerAttributeStartsWithIgnoreCaseSelector(
                  "lastname",
                  searchTerm
                ),
                ["id", "firstname", "lastname"]
              ),
            suggestionFormat: (context) => (id, firstname, lastname) =>
              `${id}: ${firstname} ${lastname}`,
            noResultsText: "Kein/e Nutzer:in mit diesem Name",
            onSelected: (context) => (selectedCustomer) => {
              updateCustomerOfRental(context, selectedCustomer);
            },
          },
        },

        {
          id: "deposit",
          label: "Pfand",
          group: "Pfand",
          component: TextInput,
          props: {
            required: true,
            pattern: "[0-9]+",
            onlyNumbers: true,
          },
        },

        {
          id: "deposit_returned",
          label: "Pfand zurück",
          group: "Pfand",
          hidden: (context) => context.createNew,
          component: TextInput,
          props: {
            quickset: (context) => ({ [context.doc.deposit]: context.doc.deposit }),
            onlyNumbers: true,
          },
        },

        {
          id: "passing_out_employee",
          label: "Ausgabe",
          group: "Mitarbeiter",
          component: TextInput,
          props: {
            required: true,
            quickset: getRecentEmployees,
          },
        },
        {
          id: "receiving_employee",
          label: "Rücknahme",
          group: "Mitarbeiter",
          hidden: (context) => context.createNew,
          component: TextInput,
          props: {
            quickset: getRecentEmployees,
          },
        },
        {
          id: "remark",
          label: "Bemerkung",
          group: "Mitarbeiter",
          component: TextInput,
          props: {
            multiline: true,
          },
        },
      ],
    };

    const MILLIS_PER_DAY = 86400 * 1000;
    const START_OF_TODAY = millisAtStartOfToday();

    var rentalFilters = {
      filters: {
        aktuell: {
          required_fields: ["returned_on"],
          selectors: {
            $or: [
              {
                returned_on: {
                  $eq: 0,
                },
              },
              {
                returned_on: {
                  $exists: false,
                },
              },
              {
                $and: [
                  {
                    returned_on: {
                      $gte: START_OF_TODAY,
                    },
                  },
                  {
                    returned_on: {
                      $lt: START_OF_TODAY + MILLIS_PER_DAY,
                    },
                  },
                ],
              },
            ],
          },
        },
        abgeschlossen: {
          required_fields: ["returned_on"],
          selectors: {
            returned_on: {
              $gt: 0,
            },
          },
        },
        "Rückgabe heute": {
          required_fields: ["to_return_on"],
          selectors: {
            $and: [
              {
                to_return_on: {
                  $gte: START_OF_TODAY,
                },
              },
              {
                to_return_on: {
                  $lt: START_OF_TODAY + MILLIS_PER_DAY,
                },
              },
            ],
          },
        },
        verspätet: {
          required_fields: ["returned_on", "to_return_on"],
          selectors: {
            $and: [
              {
                to_return_on: {
                  $gt: 0,
                },
              },
              {
                returned_on: {
                  $eq: 0,
                },
              },
              {
                to_return_on: {
                  $lt: START_OF_TODAY,
                },
              },
            ],
          },
        },
      },
      activeByDefault: ["aktuell"],
    };

    var rentalDataHooks = {
        // this function allows to either block entire data table loading by returning a pending promise
        // or return immediately, but resolve individual values asynchronously instead
        async onDataLoaded(data) {
            const itemHighlightResolvers = data.map(() => Promise.withResolvers());
            const customerHighlightResolvers = data.map(() => Promise.withResolvers());

            function getSelectQuery(entityType, ids) {
                ids.sort((a, b) => a - b);
                return {
                    $and: [
                        { type: entityType },
                        {
                            id: {
                                $gte: ids.length ? ids[0] : 0,
                                $lte: ids.length ? ids[ids.length - 1] : 999999,
                                $or: ids,
                            }
                        }
                    ]
                }
            }

            async function fetchItemHighlights() {
                const itemIds = data.map(d => d.item_id);
                const select = getSelectQuery('item', itemIds);
                const result = await Database.fetchDocsBySelector(select, ['id', '_rev', 'highlight'], [], data.length * 10);
                data.forEach((e, i) => {
                    itemHighlightResolvers[i].resolve(result.find(item => item.id === e.item_id)?.highlight || '');
                });
            }

            async function fetchCustomerHighlights() {
                const customerIds = data.map(d => d.customer_id);
                const select = getSelectQuery('customer', customerIds);
                const result = await Database.fetchDocsBySelector(select, ['id', '_rev', 'highlight'], [], data.length * 10);
                data.forEach((e, i) => {
                    customerHighlightResolvers[i].resolve(result.find(customer => customer.id === e.customer_id)?.highlight || '');
                });
            }

            fetchItemHighlights();  // intentionally not awaited!
            fetchCustomerHighlights();  // intentionally not awaited!

            data.forEach((e, i) => {
                e.item_highlight = itemHighlightResolvers[i].promise;
                e.customer_highlight = customerHighlightResolvers[i].promise;
            });
            return data
        }
    };

    var config = [
      {
        route: "/customers",
        inputs: customerInputs,
        columns: customerColumns,
        filters: customerFilters,
        docType: "customer",
        title: "Nutzer:innen",
        onData: customerDataHooks.onDataLoaded,
      },
      {
        route: "/items",
        inputs: itemInputs,
        columns: itemColumns,
        filters: itemFilters,
        docType: "item",
        title: "Gegenstände",
        onData: itemDataHooks.onDataLoaded,
      },
      {
        route: "/rentals",
        inputs: rentalInputs,
        columns: rentalColumns,
        filters: rentalFilters,
        docType: "rental",
        title: "Leihvorgänge",
        onData: rentalDataHooks.onDataLoaded,
      },
    ];

    var indexCreated = false;

    const createIndex = async () => {
      if (!indexCreated) {
        // create index for each column for sorting
        await Promise.all(
          [...customerColumns, ...itemColumns, ...rentalColumns]
            .filter((column) => !column.disableSort)
            .map((column) =>
              Database.createIndex({
                index: {
                  fields: column.sort
                    ? ["type", ...column.sort]
                    : ["type", column.key],
                },
              })
            )
        );

        await Database.createIndex({ index: { fields: ["type"] } });

        indexCreated = true;
      }
    };

    const MAX_LOG_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 1 week
    const currentMs = new Date().getTime();

    const loadLogs = () => JSON.parse(localStorage.getItem("logs") ?? "[]");

    const persistLogs = (logs) =>
      localStorage.setItem(
        "logs",
        JSON.stringify(logs.filter((log) => currentMs - log.time < MAX_LOG_AGE_MS))
      );

    const appendLog = (log) => persistLogs([...loadLogs(), log]);

    /* src/components/Logging/Logger.svelte generated by Svelte v3.42.4 */

    function instance$d($$self) {
    	Logger.setLevel(Logger.DEBUG);
    	var consoleHandler = Logger.createDefaultHandler();

    	Logger.setHandler(function (messages, context) {
    		consoleHandler(messages, context);
    		if (typeof messages[0] === "object") messages[0] = messages[0].toString();

    		appendLog({
    			time: new Date().getTime(),
    			level: context.level,
    			message: messages[0]
    		});
    	});

    	return [];
    }

    class Logger_1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$d, null, safe_not_equal, {});
    	}
    }

    /* src/components/Logging/LogView.svelte generated by Svelte v3.42.4 */

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (34:2) {#each loadLogs() as log}
    function create_each_block$3(ctx) {
    	let t0_value = /*formatLog*/ ctx[1](/*log*/ ctx[2]) + "";
    	let t0;
    	let t1;
    	let br;

    	return {
    		c() {
    			t0 = text(t0_value);
    			t1 = space();
    			br = element("br");
    		},
    		m(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    			insert(target, br, anchor);
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(t0);
    			if (detaching) detach(t1);
    			if (detaching) detach(br);
    		}
    	};
    }

    function create_fragment$e(ctx) {
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let button;
    	let t3;
    	let mounted;
    	let dispose;
    	let each_value = loadLogs();
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Logs";
    			t1 = space();
    			button = element("button");
    			button.textContent = "Download";
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div0, "class", "header");
    			attr(div1, "class", "content svelte-1jmp5ie");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, h1);
    			append(div0, t1);
    			append(div0, button);
    			append(div1, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = listen(button, "click", /*download*/ ctx[0]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*formatLog, loadLogs*/ 2) {
    				each_value = loadLogs();
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div1);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$c($$self) {
    	function download() {
    		var text = loadLogs().map(formatLog).join("\n");
    		var element = document.createElement("a");
    		element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    		element.setAttribute("download", `LeihLokalVerwaltung_Logs_${new Date().getUTCDate()}_${new Date().getUTCMonth() + 1}`);
    		element.style.display = "none";
    		document.body.appendChild(element);
    		element.click();
    		document.body.removeChild(element);
    	}

    	const formatLog = log => {
    		return `${new Date(log.time).toLocaleDateString()} ${new Date(log.time).toLocaleTimeString()} [${log.level.name}] ${log.message}`;
    	};

    	return [download, formatLog];
    }

    class LogView extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$c, create_fragment$e, safe_not_equal, {});
    	}
    }

    function flip(node, { from, to }, params = {}) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
        const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
        const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
        const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
        return {
            delay,
            duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
            easing,
            css: (t, u) => {
                const x = u * dx;
                const y = u * dy;
                const sx = t + u * from.width / to.width;
                const sy = t + u * from.height / to.height;
                return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
            }
        };
    }

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    /** Dispatch event on click outside of node */
    function observeResize(node, onResize) {
      const resizeObserver = new ResizeObserver(onResize);
      resizeObserver.observe(node);

      return {
        destroy() {
          resizeObserver.unobserve(node);
        },
      };
    }

    /* src/components/svgs/TrashCan.svelte generated by Svelte v3.42.4 */

    function create_fragment$d(ctx) {
    	let svg;
    	let path;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr(path, "d", "M0 281.296l0 -68.355q1.953 -37.107 29.295 -62.496t64.449 -25.389l93.744 0l0 -31.248q0 -39.06 27.342 -66.402t66.402 -27.342l312.48 0q39.06 0 66.402 27.342t27.342 66.402l0 31.248l93.744 0q37.107 0 64.449 25.389t29.295 62.496l0 68.355q0 25.389 -18.553 43.943t-43.943 18.553l0 531.216q0 52.731 -36.13 88.862t-88.862 36.13l-499.968 0q-52.731 0 -88.862 -36.13t-36.13 -88.862l0 -531.216q-25.389 0 -43.943 -18.553t-18.553 -43.943zm62.496 0l749.952 0l0 -62.496q0 -13.671 -8.789 -22.46t-22.46 -8.789l-687.456 0q-13.671 0 -22.46 8.789t-8.789 22.46l0 62.496zm62.496 593.712q0 25.389 18.553 43.943t43.943 18.553l499.968 0q25.389 0 43.943 -18.553t18.553 -43.943l0 -531.216l-624.96 0l0 531.216zm62.496 -31.248l0 -406.224q0 -13.671 8.789 -22.46t22.46 -8.789l62.496 0q13.671 0 22.46 8.789t8.789 22.46l0 406.224q0 13.671 -8.789 22.46t-22.46 8.789l-62.496 0q-13.671 0 -22.46 -8.789t-8.789 -22.46zm31.248 0l62.496 0l0 -406.224l-62.496 0l0 406.224zm31.248 -718.704l374.976 0l0 -31.248q0 -13.671 -8.789 -22.46t-22.46 -8.789l-312.48 0q-13.671 0 -22.46 8.789t-8.789 22.46l0 31.248zm124.992 718.704l0 -406.224q0 -13.671 8.789 -22.46t22.46 -8.789l62.496 0q13.671 0 22.46 8.789t8.789 22.46l0 406.224q0 13.671 -8.789 22.46t-22.46 8.789l-62.496 0q-13.671 0 -22.46 -8.789t-8.789 -22.46zm31.248 0l62.496 0l0 -406.224l-62.496 0l0 406.224zm156.24 0l0 -406.224q0 -13.671 8.789 -22.46t22.46 -8.789l62.496 0q13.671 0 22.46 8.789t8.789 22.46l0 406.224q0 13.671 -8.789 22.46t-22.46 8.789l-62.496 0q-13.671 0 -22.46 -8.789t-8.789 -22.46zm31.248 0l62.496 0l0 -406.224l-62.496 0l0 406.224z");
    			attr(svg, "width", "1.5em");
    			attr(svg, "height", "1.5em");
    			attr(svg, "viewBox", "0 0 875 1000");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);

    			if (!mounted) {
    				dispose = listen(svg, "click", stop_propagation(/*click_handler*/ ctx[0]));
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(svg);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$b($$self) {
    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	return [click_handler];
    }

    class TrashCan extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$b, create_fragment$d, safe_not_equal, {});
    	}
    }

    let t = {};

    const exec = (command, value = null) => {
      document.execCommand(command, false, value);
    };

    const getTagsRecursive = (element, tags) => {
      tags = tags || (element && element.tagName ? [element.tagName] : []);

      if (element && element.parentNode) {
        element = element.parentNode;
      } else {
        return tags;
      }

      const tag = element.tagName;
      if (element.style && element.getAttribute) {
        [element.style.textAlign || element.getAttribute('align'), element.style.color || tag === 'FONT' && 'forecolor', element.style.backgroundColor && 'backcolor']
          .filter((item) => item)
          .forEach((item) => tags.push(item));
      }

      if (tag === 'DIV') {
        return tags;
      }

      tags.push(tag);

      return getTagsRecursive(element, tags).filter((_tag) => _tag != null);
    };

    const saveRange = (editor) => {
      const documentSelection = document.getSelection();

      t.range = null;

      if (documentSelection.rangeCount) {
        let savedRange = t.range = documentSelection.getRangeAt(0);
        let range = document.createRange();
        let rangeStart;
        range.selectNodeContents(editor);
        range.setEnd(savedRange.startContainer, savedRange.startOffset);
        rangeStart = (range + '').length;
        t.metaRange = {
          start: rangeStart,
          end: rangeStart + (savedRange + '').length
        };
      }
    };
    const restoreRange = (editor) => {
      let metaRange = t.metaRange;
      let savedRange = t.range;
      let documentSelection = document.getSelection();
      let range;

      if (!savedRange) {
        return;
      }

      if (metaRange && metaRange.start !== metaRange.end) { // Algorithm from http://jsfiddle.net/WeWy7/3/
        let charIndex = 0,
            nodeStack = [editor],
            node,
            foundStart = false,
            stop = false;

        range = document.createRange();

        while (!stop && (node = nodeStack.pop())) {
          if (node.nodeType === 3) {
            let nextCharIndex = charIndex + node.length;
            if (!foundStart && metaRange.start >= charIndex && metaRange.start <= nextCharIndex) {
              range.setStart(node, metaRange.start - charIndex);
              foundStart = true;
            }
            if (foundStart && metaRange.end >= charIndex && metaRange.end <= nextCharIndex) {
              range.setEnd(node, metaRange.end - charIndex);
              stop = true;
            }
            charIndex = nextCharIndex;
          } else {
            let cn = node.childNodes;
            let i = cn.length;

            while (i > 0) {
              i -= 1;
              nodeStack.push(cn[i]);
            }
          }
        }
      }

      documentSelection.removeAllRanges();
      documentSelection.addRange(range || savedRange);
    };

    const cleanHtml = (input) => {
      const html = input.match(/<!--StartFragment-->(.*?)<!--EndFragment-->/);
      let output = html && html[1] || input;
      output = output
        .replace(/\r?\n|\r/g, ' ')
        .replace(/<!--(.*?)-->/g, '')
        .replace(new RegExp('<(/)*(meta|link|span|\\?xml:|st1:|o:|font|w:sdt)(.*?)>', 'gi'), '')
        .replace(/<!\[if !supportLists\]>(.*?)<!\[endif\]>/gi, '')
        .replace(/style="[^"]*"/gi, '')
        .replace(/style='[^']*'/gi, '')
        .replace(/&nbsp;/gi, ' ')
        .replace(/>(\s+)</g, '><')
        .replace(/class="[^"]*"/gi, '')
        .replace(/class='[^']*'/gi, '')
        .replace(/<[^/].*?>/g, i => i.split(/[ >]/g)[0] + '>')
        .trim();

        output = removeBadTags(output);
        return output;
    };

    const unwrap = (wrapper) => {
    	const docFrag = document.createDocumentFragment();
    	while (wrapper.firstChild) {
    		const child = wrapper.removeChild(wrapper.firstChild);
    		docFrag.appendChild(child);
    	}

    	// replace wrapper with document fragment
    	wrapper.parentNode.replaceChild(docFrag, wrapper);
    };

    const removeBlockTagsRecursive = (elements, tagsToRemove) => {
      Array.from(elements).forEach((item) => {
        if (tagsToRemove.some((tag) => tag === item.tagName.toLowerCase())) {
          if (item.children.length) {
            removeBlockTagsRecursive(item.children, tagsToRemove);
          }
          unwrap(item);
        }
      });
    };

    const getActionBtns = (actions) => {
      return Object.keys(actions).map((action) => actions[action]);
    };

    const getNewActionObj = (actions, userActions = []) => {
        if (userActions && userActions.length) {
          const newActions = {};
          userActions.forEach((action) => {
            if (typeof action === 'string') {
              newActions[action] = Object.assign({}, actions[action]);
            } else if (actions[action.name]) {
              newActions[action.name] = Object.assign(actions[action.name], action);
            } else {
              newActions[action.name] = Object.assign({}, action);
            }
          });

          return newActions;
        } else {
          return actions;
        }
    };

    const removeBadTags = (html) => {
      ['style', 'script', 'applet', 'embed', 'noframes', 'noscript'].forEach((badTag) => {
        html = html.replace(new RegExp(`<${badTag}.*?${badTag}(.*?)>`, 'gi'), '');
      });

      return html;
    };

    const isEditorClick = (target, editorWrapper) => {
      if (target === editorWrapper) {
        return true;
      }
      if (target.parentElement) {
        return isEditorClick(target.parentElement, editorWrapper);
      }
      return false;
    };

    const linkSvg =
    	'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M31.1 48.9l-6.7 6.7c-.8.8-1.6.9-2.1.9s-1.4-.1-2.1-.9L15 50.4c-1.1-1.1-1.1-3.1 0-4.2l6.1-6.1.2-.2 6.5-6.5c-1.2-.6-2.5-.9-3.8-.9-2.3 0-4.6.9-6.3 2.6L11 41.8c-3.5 3.5-3.5 9.2 0 12.7l5.2 5.2c1.7 1.7 4 2.6 6.3 2.6s4.6-.9 6.3-2.6l6.7-6.7c2.5-2.6 3.1-6.7 1.5-10l-5.9 5.9zM38.7 22.5l6.7-6.7c.8-.8 1.6-.9 2.1-.9s1.4.1 2.1.9l5.2 5.2c1.1 1.1 1.1 3.1 0 4.2l-6.1 6.1-.2.2L42 38c1.2.6 2.5.9 3.8.9 2.3 0 4.6-.9 6.3-2.6l6.7-6.7c3.5-3.5 3.5-9.2 0-12.7l-5.2-5.2c-1.7-1.7-4-2.6-6.3-2.6s-4.6.9-6.3 2.6l-6.7 6.7c-2.7 2.7-3.3 6.9-1.7 10.2l6.1-6.1c0 .1 0 .1 0 0z"></path><path d="M44.2 30.5c.2-.2.4-.6.4-.9 0-.3-.1-.6-.4-.9l-2.3-2.3c-.3-.2-.6-.4-.9-.4-.3 0-.6.1-.9.4L25.9 40.6c-.2.2-.4.6-.4.9 0 .3.1.6.4.9l2.3 2.3c.2.2.6.4.9.4.3 0 .6-.1.9-.4l14.2-14.2zM49.9 55.4h-8.5v-5h8.5v-8.9h5.2v8.9h8.5v5h-8.5v8.9h-5.2v-8.9z"></path></svg>';
    const unlinkSvg =
    	'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M30.9 49.1l-6.7 6.7c-.8.8-1.6.9-2.1.9s-1.4-.1-2.1-.9l-5.2-5.2c-1.1-1.1-1.1-3.1 0-4.2l6.1-6.1.2-.2 6.5-6.5c-1.2-.6-2.5-.9-3.8-.9-2.3 0-4.6.9-6.3 2.6L10.8 42c-3.5 3.5-3.5 9.2 0 12.7l5.2 5.2c1.7 1.7 4 2.6 6.3 2.6s4.6-.9 6.3-2.6l6.7-6.7C38 50.5 38.6 46.3 37 43l-6.1 6.1zM38.5 22.7l6.7-6.7c.8-.8 1.6-.9 2.1-.9s1.4.1 2.1.9l5.2 5.2c1.1 1.1 1.1 3.1 0 4.2l-6.1 6.1-.2.2-6.5 6.5c1.2.6 2.5.9 3.8.9 2.3 0 4.6-.9 6.3-2.6l6.7-6.7c3.5-3.5 3.5-9.2 0-12.7l-5.2-5.2c-1.7-1.7-4-2.6-6.3-2.6s-4.6.9-6.3 2.6l-6.7 6.7c-2.7 2.7-3.3 6.9-1.7 10.2l6.1-6.1z"></path><path d="M44.1 30.7c.2-.2.4-.6.4-.9 0-.3-.1-.6-.4-.9l-2.3-2.3c-.2-.2-.6-.4-.9-.4-.3 0-.6.1-.9.4L25.8 40.8c-.2.2-.4.6-.4.9 0 .3.1.6.4.9l2.3 2.3c.2.2.6.4.9.4.3 0 .6-.1.9-.4l14.2-14.2zM41.3 55.8v-5h22.2v5H41.3z"></path></svg>';

    var defaultActions = {
    	viewHtml: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path fill="none" stroke="currentColor" stroke-width="8" stroke-miterlimit="10" d="M26.9 17.9L9 36.2 26.9 54M45 54l17.9-18.3L45 17.9"></path></svg>',
    		title: "View HTML",
    		result: function() {
    			let refs = get_store_value(this.references);
    			let actionObj = get_store_value(this.state).actionObj;
    			let helper = get_store_value(this.helper);

    			helper.showEditor = !helper.showEditor;
    			refs.editor.style.display = helper.showEditor ? "block" : "none";
    			refs.raw.style.display = helper.showEditor ? "none" : "block";
    			if (helper.showEditor) {
    				refs.editor.innerHTML = refs.raw.value;
    			} else {
    				refs.raw.value = refs.editor.innerHTML;
    			}
    			setTimeout(() => {
    				Object.keys(actionObj).forEach(
    					action => (actionObj[action].disabled = !helper.showEditor)
    				);
    				actionObj.viewHtml.disabled = false;
    				actionObj.viewHtml.active = !helper.showEditor;

    				this.state.update(state => {
    					state.actionBtns = getActionBtns(actionObj);
    					state.actionObj = actionObj;
    					return state;
    				});
    			});
    		}
    	},
    	undo: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M61.2 51.2c0-5.1-2.1-9.7-5.4-13.1-3.3-3.3-8-5.4-13.1-5.4H26.1v-12L10.8 36l15.3 15.3V39.1h16.7c3.3 0 6.4 1.3 8.5 3.5 2.2 2.2 3.5 5.2 3.5 8.5h6.4z"></path></svg>',
    		title: "Undo",
    		result: () => exec("undo")
    	},
    	redo: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M10.8 51.2c0-5.1 2.1-9.7 5.4-13.1 3.3-3.3 8-5.4 13.1-5.4H46v-12L61.3 36 45.9 51.3V39.1H29.3c-3.3 0-6.4 1.3-8.5 3.5-2.2 2.2-3.5 5.2-3.5 8.5h-6.5z"></path></svg>',
    		title: "Redo",
    		result: () => exec("redo")
    	},
    	b: {
    		icon: "<b>B</b>",
    		title: "Bold",
    		result: () => exec("bold")
    	},
    	i: {
    		icon: "<i>I</i>",
    		title: "Italic",
    		result: () => exec("italic")
    	},
    	u: {
    		icon: "<u>U</u>",
    		title: "Underline",
    		result: () => exec("underline")
    	},
    	strike: {
    		icon: "<strike>S</strike>",
    		title: "Strike-through",
    		result: () => exec("strikeThrough")
    	},
    	sup: {
    		icon: "A<sup>2</sup>",
    		title: "Superscript",
    		result: () => exec("superscript")
    	},
    	sub: {
    		icon: "A<sub>2</sub>",
    		title: "Subscript",
    		result: () => exec("subscript")
    	},
    	h1: {
    		icon: "<b>H<sub>1</sub></b>",
    		title: "Heading 1",
    		result: () => exec("formatBlock", "<H1>")
    	},
    	h2: {
    		icon: "<b>H<sub>2</sub></b>",
    		title: "Heading 2",
    		result: () => exec("formatBlock", "<H2>")
    	},
    	p: {
    		icon: "&#182;",
    		title: "Paragraph",
    		result: () => exec("formatBlock", "<P>")
    	},
    	blockquote: {
    		icon: "&#8220; &#8221;",
    		title: "Quote",
    		result: () => exec("formatBlock", "<BLOCKQUOTE>")
    	},
    	ol: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M27 14h36v8H27zM27 50h36v8H27zM27 32h36v8H27zM11.8 15.8V22h1.8v-7.8h-1.5l-2.1 1 .3 1.3zM12.1 38.5l.7-.6c1.1-1 2.1-2.1 2.1-3.4 0-1.4-1-2.4-2.7-2.4-1.1 0-2 .4-2.6.8l.5 1.3c.4-.3 1-.6 1.7-.6.9 0 1.3.5 1.3 1.1 0 .9-.9 1.8-2.6 3.3l-1 .9V40H15v-1.5h-2.9zM13.3 53.9c1-.4 1.4-1 1.4-1.8 0-1.1-.9-1.9-2.6-1.9-1 0-1.9.3-2.4.6l.4 1.3c.3-.2 1-.5 1.6-.5.8 0 1.2.3 1.2.8 0 .7-.8.9-1.4.9h-.7v1.3h.7c.8 0 1.6.3 1.6 1.1 0 .6-.5 1-1.4 1-.7 0-1.5-.3-1.8-.5l-.4 1.4c.5.3 1.3.6 2.3.6 2 0 3.2-1 3.2-2.4 0-1.1-.8-1.8-1.7-1.9z"></path></svg>',
    		title: "Ordered List",
    		result: () => exec("insertOrderedList")
    	},
    	ul: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M27 14h36v8H27zM27 50h36v8H27zM9 50h9v8H9zM9 32h9v8H9zM9 14h9v8H9zM27 32h36v8H27z"></path></svg>',
    		title: "Unordered List",
    		result: () => exec("insertUnorderedList")
    	},
    	hr: {
    		icon: "&#8213;",
    		title: "Horizontal Line",
    		result: () => exec("insertHorizontalRule")
    	},
    	left: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM9 32h36v8H9z"></path></svg>',
    		title: "Justify left",
    		result: () => exec("justifyLeft")
    	},
    	right: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM27 32h36v8H27z"></path></svg>',
    		title: "Justify right",
    		result: () => exec("justifyRight")
    	},
    	center: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM18 32h36v8H18z"></path></svg>',
    		title: "Justify center",
    		result: () => exec("justifyCenter")
    	},
    	justify: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M9 14h54v8H9zM9 50h54v8H9zM9 32h54v8H9z"></path></svg>',
    		title: "Justify full",
    		result: () => exec("justifyFull")
    	},
    	a: {
    		icon: linkSvg,
    		title: "Insert link",
    		result: function() {
    			const actionObj = get_store_value(this.state).actionObj;
    			const refs = get_store_value(this.references);

    			if (actionObj.a.active) {
    				const selection = window.getSelection();
    				const range = document.createRange();
    				range.selectNodeContents(document.getSelection().focusNode);
    				selection.removeAllRanges();
    				selection.addRange(range);
    				exec("unlink");
    				actionObj.a.title = "Insert link";
    				actionObj.a.icon = linkSvg;
    				this.state.update(state => {
    					state.actionBtn = getActionBtns(actionObj);
    					state.actionObj = actionObj;
    					return state;
    				});
    			} else {
    				saveRange(refs.editor);
    				refs.modal.$set({
    					show: true,
    					event: "linkUrl",
    					title: "Insert link",
    					label: "Url"
    				});
    				if (!get_store_value(this.helper).link) {
    					this.helper.update(state => {
    						state.link = true;
    						return state;
    					});
    					refs.modal.$on("linkUrl", event => {
    						restoreRange(refs.editor);
    						exec("createLink", event.detail);
    						actionObj.a.title = "Unlink";
    						actionObj.a.icon = unlinkSvg;

    						this.state.update(state => {
    							state.actionBtn = getActionBtns(actionObj);
    							state.actionObj = actionObj;
    							return state;
    						});
    					});
    				}
    			}
    		}
    	},
    	image: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M64 17v38H8V17h56m8-8H0v54h72V9z"></path><path d="M17.5 22C15 22 13 24 13 26.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5zM16 50h27L29.5 32zM36 36.2l8.9-8.5L60.2 50H45.9S35.6 35.9 36 36.2z"></path></svg>',
    		title: "Image",
    		result: function() {
    			const refs = get_store_value(this.references);
    			saveRange(refs.editor);
    			refs.modal.$set({
    				show: true,
    				event: "imageUrl",
    				title: "Insert image",
    				label: "Url"
    			});
    			if (!get_store_value(this.helper).image) {
    				this.helper.update(state => {
    					state.image = true;
    					return state;
    				});
    				refs.modal.$on("imageUrl", event => {
    					restoreRange(refs.editor);
    					exec("insertImage", event.detail);
    				});
    			}
    		}
    	},
    	forecolor: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M32 15h7.8L56 57.1h-7.9l-4-11.1H27.4l-4 11.1h-7.6L32 15zm-2.5 25.4h12.9L36 22.3h-.2l-6.3 18.1z"></path></svg>',
    		title: "Text color",
    		colorPicker: true,
    		result: function() {
    			showColorPicker.call(this, "foreColor");
    		}
    	},
    	backcolor: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M36.5 22.3l-6.3 18.1H43l-6.3-18.1z"></path><path d="M9 8.9v54.2h54.1V8.9H9zm39.9 48.2L45 46H28.2l-3.9 11.1h-7.6L32.8 15h7.8l16.2 42.1h-7.9z"></path></svg>',
    		title: "Background color",
    		colorPicker: true,
    		result: function() {
    			showColorPicker.call(this, "backColor");
    		}
    	},
    	removeFormat: {
    		icon:
    			'<svg viewBox="0 0 72 72" width="17px" height="100%"><path d="M58.2 54.6L52 48.5l3.6-3.6 6.1 6.1 6.4-6.4 3.8 3.8-6.4 6.4 6.1 6.1-3.6 3.6-6.1-6.1-6.4 6.4-3.7-3.8 6.4-6.4zM21.7 52.1H50V57H21.7zM18.8 15.2h34.1v6.4H39.5v24.2h-7.4V21.5H18.8v-6.3z"></path></svg>',
    		title: "Remove format",
    		result: function() {
    			const refs = get_store_value(this.references);
    			const selection = window.getSelection();
    			if (!selection.toString().length) {
    				removeBlockTagsRecursive(
    					refs.editor.children,
    					this.removeFormatTags
    				);
    				const range = document.createRange();
    				range.selectNodeContents(refs.editor);
    				selection.removeAllRanges();
    				selection.addRange(range);
    			}
    			exec("removeFormat");
    			selection.removeAllRanges();
    		}
    	}
    };

    const showColorPicker = function(cmd) {
    	const refs = get_store_value(this.references);
    	saveRange(refs.editor);
    	console.log(refs.colorPicker);
    	refs.colorPicker.$set({show: true, event: cmd});
    	if (!get_store_value(this.helper)[cmd]) {
    		this.helper.update(state => {
    			state[cmd] = true;
    			return state;
    		});
    		refs.colorPicker.$on(cmd, event => {
    			let item = event.detail;
    			if (item.modal) {
    				this.modal.$set({
    					show: true,
    					event: "colorHref",
    					title: "Text color",
    					label:
    						cmd === "foreColor" ? "Text color" : "Background color"
    				});
    				const command = cmd;
    				if (!get_store_value(this.helper)[`${command}Modal`]) {
    					get_store_value(this.helper)[`${command}Modal`] = true;
    					this.modal.$on("colorHref", event => {
    						let color = event.detail;
    						restoreRange(refs.editor);
    						exec(command, color);
    					});
    				}
    			} else {
    				restoreRange(refs.editor);
    				exec(cmd, item.color);
    			}
    		});
    	}
    };

    /* node_modules/cl-editor/src/helpers/EditorModal.svelte generated by Svelte v3.42.4 */

    function create_if_block$1(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			span.textContent = "Required";
    			attr(span, "class", "msg-error svelte-42yfje");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    function create_fragment$c(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let span0;
    	let t1;
    	let t2;
    	let form;
    	let label_1;
    	let input;
    	let t3;
    	let span2;
    	let span1;
    	let t4;
    	let t5;
    	let t6;
    	let button0;
    	let t8;
    	let button1;
    	let mounted;
    	let dispose;
    	let if_block = /*error*/ ctx[2] && create_if_block$1();

    	return {
    		c() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			span0 = element("span");
    			t1 = text(/*title*/ ctx[3]);
    			t2 = space();
    			form = element("form");
    			label_1 = element("label");
    			input = element("input");
    			t3 = space();
    			span2 = element("span");
    			span1 = element("span");
    			t4 = text(/*label*/ ctx[4]);
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			button0 = element("button");
    			button0.textContent = "Confirm";
    			t8 = space();
    			button1 = element("button");
    			button1.textContent = "Cancel";
    			attr(div0, "class", "cl-editor-overlay svelte-42yfje");
    			attr(span0, "class", "modal-title svelte-42yfje");
    			attr(input, "type", "text");
    			attr(input, "name", "text");
    			attr(input, "class", "svelte-42yfje");
    			attr(span1, "class", "svelte-42yfje");
    			attr(span2, "class", "input-info svelte-42yfje");
    			attr(label_1, "class", "modal-label svelte-42yfje");
    			toggle_class(label_1, "input-error", /*error*/ ctx[2]);
    			attr(button0, "class", "modal-button modal-submit svelte-42yfje");
    			attr(button0, "type", "submit");
    			attr(button1, "class", "modal-button modal-reset svelte-42yfje");
    			attr(button1, "type", "reset");
    			attr(div1, "class", "modal-box svelte-42yfje");
    			attr(div2, "class", "cl-editor-modal svelte-42yfje");
    			set_style(div3, "display", /*show*/ ctx[0] ? 'block' : 'none');
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div0);
    			append(div3, t0);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, span0);
    			append(span0, t1);
    			append(div1, t2);
    			append(div1, form);
    			append(form, label_1);
    			append(label_1, input);
    			/*input_binding*/ ctx[10](input);
    			set_input_value(input, /*text*/ ctx[1]);
    			append(label_1, t3);
    			append(label_1, span2);
    			append(span2, span1);
    			append(span1, t4);
    			append(span2, t5);
    			if (if_block) if_block.m(span2, null);
    			append(form, t6);
    			append(form, button0);
    			append(form, t8);
    			append(form, button1);

    			if (!mounted) {
    				dispose = [
    					listen(div0, "click", /*cancel*/ ctx[7]),
    					listen(input, "keyup", /*hideError*/ ctx[8]),
    					listen(input, "input", /*input_input_handler*/ ctx[11]),
    					listen(button1, "click", /*cancel*/ ctx[7]),
    					listen(form, "submit", prevent_default(/*submit_handler*/ ctx[12]))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*title*/ 8) set_data(t1, /*title*/ ctx[3]);

    			if (dirty & /*text*/ 2 && input.value !== /*text*/ ctx[1]) {
    				set_input_value(input, /*text*/ ctx[1]);
    			}

    			if (dirty & /*label*/ 16) set_data(t4, /*label*/ ctx[4]);

    			if (/*error*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block$1();
    					if_block.c();
    					if_block.m(span2, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*error*/ 4) {
    				toggle_class(label_1, "input-error", /*error*/ ctx[2]);
    			}

    			if (dirty & /*show*/ 1) {
    				set_style(div3, "display", /*show*/ ctx[0] ? 'block' : 'none');
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div3);
    			/*input_binding*/ ctx[10](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let dispatcher = new createEventDispatcher();
    	let { show = false } = $$props;
    	let { text = '' } = $$props;
    	let { event = '' } = $$props;
    	let { title = '' } = $$props;
    	let { label = '' } = $$props;
    	let { error = false } = $$props;
    	let refs = {};

    	function confirm() {
    		if (text) {
    			console.log('dispatcher', text, event);
    			dispatcher(event, text);
    			cancel();
    		} else {
    			$$invalidate(2, error = true);
    			refs.text.focus();
    		}
    	}

    	function cancel() {
    		$$invalidate(0, show = false);
    		$$invalidate(1, text = '');
    		$$invalidate(2, error = false);
    	}

    	function hideError() {
    		$$invalidate(2, error = false);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			refs.text = $$value;
    			$$invalidate(5, refs);
    		});
    	}

    	function input_input_handler() {
    		text = this.value;
    		$$invalidate(1, text);
    	}

    	const submit_handler = event => confirm();

    	$$self.$$set = $$props => {
    		if ('show' in $$props) $$invalidate(0, show = $$props.show);
    		if ('text' in $$props) $$invalidate(1, text = $$props.text);
    		if ('event' in $$props) $$invalidate(9, event = $$props.event);
    		if ('title' in $$props) $$invalidate(3, title = $$props.title);
    		if ('label' in $$props) $$invalidate(4, label = $$props.label);
    		if ('error' in $$props) $$invalidate(2, error = $$props.error);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*show, refs*/ 33) {
    			{
    				if (show) {
    					setTimeout(() => {
    						refs.text.focus();
    					});
    				}
    			}
    		}
    	};

    	return [
    		show,
    		text,
    		error,
    		title,
    		label,
    		refs,
    		confirm,
    		cancel,
    		hideError,
    		event,
    		input_binding,
    		input_input_handler,
    		submit_handler
    	];
    }

    class EditorModal extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$a, create_fragment$c, safe_not_equal, {
    			show: 0,
    			text: 1,
    			event: 9,
    			title: 3,
    			label: 4,
    			error: 2
    		});
    	}

    	get show() {
    		return this.$$.ctx[0];
    	}

    	set show(show) {
    		this.$$set({ show });
    		flush();
    	}

    	get text() {
    		return this.$$.ctx[1];
    	}

    	set text(text) {
    		this.$$set({ text });
    		flush();
    	}

    	get event() {
    		return this.$$.ctx[9];
    	}

    	set event(event) {
    		this.$$set({ event });
    		flush();
    	}

    	get title() {
    		return this.$$.ctx[3];
    	}

    	set title(title) {
    		this.$$set({ title });
    		flush();
    	}

    	get label() {
    		return this.$$.ctx[4];
    	}

    	set label(label) {
    		this.$$set({ label });
    		flush();
    	}

    	get error() {
    		return this.$$.ctx[2];
    	}

    	set error(error) {
    		this.$$set({ error });
    		flush();
    	}
    }

    /* node_modules/cl-editor/src/helpers/EditorColorPicker.svelte generated by Svelte v3.42.4 */

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (4:4) {#each btns as btn}
    function create_each_block$2(ctx) {
    	let button;
    	let t_value = (/*btn*/ ctx[9].text || '') + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[5](/*btn*/ ctx[9], ...args);
    	}

    	return {
    		c() {
    			button = element("button");
    			t = text(t_value);
    			attr(button, "type", "button");
    			attr(button, "class", "color-picker-btn svelte-njq4pk");
    			set_style(button, "background-color", /*btn*/ ctx[9].color);
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", click_handler);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*btns*/ 2 && t_value !== (t_value = (/*btn*/ ctx[9].text || '') + "")) set_data(t, t_value);

    			if (dirty & /*btns*/ 2) {
    				set_style(button, "background-color", /*btn*/ ctx[9].color);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$b(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let mounted;
    	let dispose;
    	let each_value = /*btns*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr(div0, "class", "color-picker-overlay svelte-njq4pk");
    			attr(div1, "class", "color-picker-wrapper svelte-njq4pk");
    			set_style(div2, "display", /*show*/ ctx[0] ? 'block' : 'none');
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t);
    			append(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			if (!mounted) {
    				dispose = listen(div0, "click", /*close*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*btns, selectColor*/ 10) {
    				each_value = /*btns*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*show*/ 1) {
    				set_style(div2, "display", /*show*/ ctx[0] ? 'block' : 'none');
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$9($$self, $$props, $$invalidate) {
    	const dispatcher = new createEventDispatcher();

    	const colors = [
    		'ffffff',
    		'000000',
    		'eeece1',
    		'1f497d',
    		'4f81bd',
    		'c0504d',
    		'9bbb59',
    		'8064a2',
    		'4bacc6',
    		'f79646',
    		'ffff00',
    		'f2f2f2',
    		'7f7f7f',
    		'ddd9c3',
    		'c6d9f0',
    		'dbe5f1',
    		'f2dcdb',
    		'ebf1dd',
    		'e5e0ec',
    		'dbeef3',
    		'fdeada',
    		'fff2ca',
    		'd8d8d8',
    		'595959',
    		'c4bd97',
    		'8db3e2',
    		'b8cce4',
    		'e5b9b7',
    		'd7e3bc',
    		'ccc1d9',
    		'b7dde8',
    		'fbd5b5',
    		'ffe694',
    		'bfbfbf',
    		'3f3f3f',
    		'938953',
    		'548dd4',
    		'95b3d7',
    		'd99694',
    		'c3d69b',
    		'b2a2c7',
    		'b7dde8',
    		'fac08f',
    		'f2c314',
    		'a5a5a5',
    		'262626',
    		'494429',
    		'17365d',
    		'366092',
    		'953734',
    		'76923c',
    		'5f497a',
    		'92cddc',
    		'e36c09',
    		'c09100',
    		'7f7f7f',
    		'0c0c0c',
    		'1d1b10',
    		'0f243e',
    		'244061',
    		'632423',
    		'4f6128',
    		'3f3151',
    		'31859b',
    		'974806',
    		'7f6000'
    	];

    	const getBtns = () => {
    		const btns = colors.map(color => ({ color: `#${color}` }));
    		btns.push({ text: '#', modal: true });
    		return btns;
    	};

    	let { show = false } = $$props;
    	let { btns = [] } = $$props;
    	let { event = '' } = $$props;

    	onMount(() => {
    		$$invalidate(1, btns = getBtns());
    	});

    	function close() {
    		$$invalidate(0, show = false);
    	}

    	function selectColor(btn) {
    		dispatcher(event, btn);
    		close();
    	}

    	const click_handler = (btn, event) => selectColor(btn);

    	$$self.$$set = $$props => {
    		if ('show' in $$props) $$invalidate(0, show = $$props.show);
    		if ('btns' in $$props) $$invalidate(1, btns = $$props.btns);
    		if ('event' in $$props) $$invalidate(4, event = $$props.event);
    	};

    	return [show, btns, close, selectColor, event, click_handler];
    }

    class EditorColorPicker extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$9, create_fragment$b, safe_not_equal, { show: 0, btns: 1, event: 4 });
    	}
    }

    const state = (function(name) {
      let state = {
        actionBtns: [],
        actionObj: {}
      };

      const { subscribe, set, update } = writable(state);

      return {
        name,
        set,
        update,
        subscribe
      }
    });

    const createStateStore = state;

    /* node_modules/cl-editor/src/Editor.svelte generated by Svelte v3.42.4 */

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	return child_ctx;
    }

    // (8:4) {#each $state.actionBtns as action}
    function create_each_block$1(ctx) {
    	let button;
    	let html_tag;
    	let raw_value = /*action*/ ctx[37].icon + "";
    	let t;
    	let button_class_value;
    	let button_title_value;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[23](/*action*/ ctx[37], ...args);
    	}

    	return {
    		c() {
    			button = element("button");
    			html_tag = new HtmlTag();
    			t = space();
    			html_tag.a = t;
    			attr(button, "type", "button");
    			attr(button, "class", button_class_value = "cl-button " + (/*action*/ ctx[37].active ? 'active' : '') + " svelte-1a534py");
    			attr(button, "title", button_title_value = /*action*/ ctx[37].title);
    			button.disabled = button_disabled_value = /*action*/ ctx[37].disabled;
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			html_tag.m(raw_value, button);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", click_handler_1);
    				mounted = true;
    			}
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*$state*/ 8 && raw_value !== (raw_value = /*action*/ ctx[37].icon + "")) html_tag.p(raw_value);

    			if (dirty[0] & /*$state*/ 8 && button_class_value !== (button_class_value = "cl-button " + (/*action*/ ctx[37].active ? 'active' : '') + " svelte-1a534py")) {
    				attr(button, "class", button_class_value);
    			}

    			if (dirty[0] & /*$state*/ 8 && button_title_value !== (button_title_value = /*action*/ ctx[37].title)) {
    				attr(button, "title", button_title_value);
    			}

    			if (dirty[0] & /*$state*/ 8 && button_disabled_value !== (button_disabled_value = /*action*/ ctx[37].disabled)) {
    				button.disabled = button_disabled_value;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$a(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let textarea;
    	let t2;
    	let editormodal;
    	let t3;
    	let editorcolorpicker;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$state*/ ctx[3].actionBtns;
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	let editormodal_props = {};
    	editormodal = new EditorModal({ props: editormodal_props });
    	/*editormodal_binding*/ ctx[30](editormodal);
    	let editorcolorpicker_props = {};
    	editorcolorpicker = new EditorColorPicker({ props: editorcolorpicker_props });
    	/*editorcolorpicker_binding*/ ctx[31](editorcolorpicker);

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			create_component(editormodal.$$.fragment);
    			t3 = space();
    			create_component(editorcolorpicker.$$.fragment);
    			attr(div0, "class", "cl-actionbar svelte-1a534py");
    			attr(div1, "id", /*contentId*/ ctx[1]);
    			attr(div1, "class", "cl-content svelte-1a534py");
    			set_style(div1, "height", /*height*/ ctx[0]);
    			attr(div1, "contenteditable", "true");
    			attr(textarea, "class", "cl-textarea svelte-1a534py");
    			set_style(textarea, "max-height", /*height*/ ctx[0]);
    			set_style(textarea, "min-height", /*height*/ ctx[0]);
    			attr(div2, "class", "cl svelte-1a534py");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append(div2, t0);
    			append(div2, div1);
    			/*div1_binding*/ ctx[24](div1);
    			append(div2, t1);
    			append(div2, textarea);
    			/*textarea_binding*/ ctx[29](textarea);
    			append(div2, t2);
    			mount_component(editormodal, div2, null);
    			append(div2, t3);
    			mount_component(editorcolorpicker, div2, null);
    			/*div2_binding*/ ctx[32](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(window, "click", /*click_handler*/ ctx[22]),
    					listen(div1, "input", /*input_handler*/ ctx[25]),
    					listen(div1, "mouseup", /*mouseup_handler*/ ctx[26]),
    					listen(div1, "keyup", /*keyup_handler*/ ctx[27]),
    					listen(div1, "paste", /*paste_handler*/ ctx[28])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*$state, _btnClicked*/ 136) {
    				each_value = /*$state*/ ctx[3].actionBtns;
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty[0] & /*contentId*/ 2) {
    				attr(div1, "id", /*contentId*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(div1, "height", /*height*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(textarea, "max-height", /*height*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*height*/ 1) {
    				set_style(textarea, "min-height", /*height*/ ctx[0]);
    			}

    			const editormodal_changes = {};
    			editormodal.$set(editormodal_changes);
    			const editorcolorpicker_changes = {};
    			editorcolorpicker.$set(editorcolorpicker_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(editormodal.$$.fragment, local);
    			transition_in(editorcolorpicker.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(editormodal.$$.fragment, local);
    			transition_out(editorcolorpicker.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_each(each_blocks, detaching);
    			/*div1_binding*/ ctx[24](null);
    			/*textarea_binding*/ ctx[29](null);
    			/*editormodal_binding*/ ctx[30](null);
    			destroy_component(editormodal);
    			/*editorcolorpicker_binding*/ ctx[31](null);
    			destroy_component(editorcolorpicker);
    			/*div2_binding*/ ctx[32](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const editors = [];

    function instance$8($$self, $$props, $$invalidate) {
    	let $references;
    	let $helper;
    	let $state;
    	let dispatcher = new createEventDispatcher();
    	let { actions = [] } = $$props;
    	let { height = '300px' } = $$props;
    	let { html = '' } = $$props;
    	let { contentId = '' } = $$props;
    	let { removeFormatTags = ['h1', 'h2', 'blockquote'] } = $$props;

    	let helper = writable({
    		foreColor: false,
    		backColor: false,
    		foreColorModal: false,
    		backColorModal: false,
    		image: false,
    		link: false,
    		showEditor: true,
    		blurActive: false
    	});

    	component_subscribe($$self, helper, value => $$invalidate(33, $helper = value));
    	editors.push({});
    	let contextKey = "editor_" + editors.length;
    	let state = createStateStore(contextKey);
    	component_subscribe($$self, state, value => $$invalidate(3, $state = value));
    	let references = writable({});
    	component_subscribe($$self, references, value => $$invalidate(2, $references = value));
    	set_store_value(state, $state.actionObj = getNewActionObj(defaultActions, actions), $state);

    	let context = {
    		exec: exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange: saveRange$1,
    		restoreRange: restoreRange$1,
    		helper,
    		references,
    		state,
    		removeFormatTags
    	};

    	setContext(contextKey, context);

    	onMount(() => {
    		set_store_value(state, $state.actionBtns = getActionBtns($state.actionObj), $state);
    		setHtml(html);
    	});

    	function _btnClicked(action) {
    		$references.editor.focus();
    		saveRange$1($references.editor);
    		restoreRange$1($references.editor);
    		action.result.call(context);
    		_handleButtonStatus();
    	}

    	function _handleButtonStatus(clearBtns) {
    		const tags = clearBtns
    		? []
    		: getTagsRecursive(document.getSelection().focusNode);

    		Object.keys($state.actionObj).forEach(action => set_store_value(state, $state.actionObj[action].active = false, $state));
    		tags.forEach(tag => ($state.actionObj[tag.toLowerCase()] || {}).active = true);
    		set_store_value(state, $state.actionBtns = getActionBtns($state.actionObj), $state);
    		state.set($state);
    	}

    	function _onPaste(event) {
    		event.preventDefault();

    		exec$1('insertHTML', event.clipboardData.getData('text/html')
    		? cleanHtml(event.clipboardData.getData('text/html'))
    		: event.clipboardData.getData('text'));
    	}

    	function _onChange(event) {
    		dispatcher('change', event);
    	}

    	function _documentClick(event) {
    		if (!isEditorClick(event.target, $references.editorWrapper) && $helper.blurActive) {
    			dispatcher('blur', event);
    		}

    		set_store_value(helper, $helper.blurActive = true, $helper);
    	}

    	function exec$1(cmd, value) {
    		exec(cmd, value);
    	}

    	

    	function getHtml(sanitize) {
    		return sanitize
    		? removeBadTags($references.editor.innerHTML)
    		: $references.editor.innerHTML;
    	}

    	function getText() {
    		return $references.editor.innerText;
    	}

    	function setHtml(html, sanitize) {
    		const htmlData = sanitize ? removeBadTags(html) : html || '';
    		set_store_value(references, $references.editor.innerHTML = htmlData, $references);
    		set_store_value(references, $references.raw.value = htmlData, $references);
    	}

    	function saveRange$1() {
    		saveRange($references.editor);
    	}

    	function restoreRange$1() {
    		restoreRange($references.editor);
    	}

    	const refs = $references;
    	const click_handler = event => _documentClick(event);
    	const click_handler_1 = (action, event) => _btnClicked(action);

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.editor = $$value;
    			references.set($references);
    		});
    	}

    	const input_handler = event => _onChange(event.target.innerHTML);
    	const mouseup_handler = () => _handleButtonStatus();
    	const keyup_handler = () => _handleButtonStatus();
    	const paste_handler = event => _onPaste(event);

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.raw = $$value;
    			references.set($references);
    		});
    	}

    	function editormodal_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.modal = $$value;
    			references.set($references);
    		});
    	}

    	function editorcolorpicker_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.colorPicker = $$value;
    			references.set($references);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$references.editorWrapper = $$value;
    			references.set($references);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('actions' in $$props) $$invalidate(12, actions = $$props.actions);
    		if ('height' in $$props) $$invalidate(0, height = $$props.height);
    		if ('html' in $$props) $$invalidate(13, html = $$props.html);
    		if ('contentId' in $$props) $$invalidate(1, contentId = $$props.contentId);
    		if ('removeFormatTags' in $$props) $$invalidate(14, removeFormatTags = $$props.removeFormatTags);
    	};

    	return [
    		height,
    		contentId,
    		$references,
    		$state,
    		helper,
    		state,
    		references,
    		_btnClicked,
    		_handleButtonStatus,
    		_onPaste,
    		_onChange,
    		_documentClick,
    		actions,
    		html,
    		removeFormatTags,
    		exec$1,
    		getHtml,
    		getText,
    		setHtml,
    		saveRange$1,
    		restoreRange$1,
    		refs,
    		click_handler,
    		click_handler_1,
    		div1_binding,
    		input_handler,
    		mouseup_handler,
    		keyup_handler,
    		paste_handler,
    		textarea_binding,
    		editormodal_binding,
    		editorcolorpicker_binding,
    		div2_binding
    	];
    }

    class Editor extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$8,
    			create_fragment$a,
    			safe_not_equal,
    			{
    				actions: 12,
    				height: 0,
    				html: 13,
    				contentId: 1,
    				removeFormatTags: 14,
    				exec: 15,
    				getHtml: 16,
    				getText: 17,
    				setHtml: 18,
    				saveRange: 19,
    				restoreRange: 20,
    				refs: 21
    			},
    			null,
    			[-1, -1]
    		);
    	}

    	get actions() {
    		return this.$$.ctx[12];
    	}

    	set actions(actions) {
    		this.$$set({ actions });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[0];
    	}

    	set height(height) {
    		this.$$set({ height });
    		flush();
    	}

    	get html() {
    		return this.$$.ctx[13];
    	}

    	set html(html) {
    		this.$$set({ html });
    		flush();
    	}

    	get contentId() {
    		return this.$$.ctx[1];
    	}

    	set contentId(contentId) {
    		this.$$set({ contentId });
    		flush();
    	}

    	get removeFormatTags() {
    		return this.$$.ctx[14];
    	}

    	set removeFormatTags(removeFormatTags) {
    		this.$$set({ removeFormatTags });
    		flush();
    	}

    	get exec() {
    		return this.$$.ctx[15];
    	}

    	get getHtml() {
    		return this.$$.ctx[16];
    	}

    	get getText() {
    		return this.$$.ctx[17];
    	}

    	get setHtml() {
    		return this.$$.ctx[18];
    	}

    	get saveRange() {
    		return this.$$.ctx[19];
    	}

    	get restoreRange() {
    		return this.$$.ctx[20];
    	}

    	get refs() {
    		return this.$$.ctx[21];
    	}
    }

    /* src/components/Dashboard/Notes/Editor.svelte generated by Svelte v3.42.4 */

    function create_fragment$9(ctx) {
    	let div;
    	let editor;
    	let current;
    	let mounted;
    	let dispose;

    	editor = new Editor({
    			props: {
    				html: /*contentHtml*/ ctx[0],
    				actions: [
    					"b",
    					"i",
    					"u",
    					"ul",
    					"ol",
    					"h1",
    					"h2",
    					"forecolor",
    					{
    						name: "save", // required
    						icon: "<b>Speichern</b>", // string or html string (ex. <svg>...</svg>)
    						title: "Speichern",
    						result: /*func*/ ctx[5]
    					}
    				],
    				height: /*heightPx*/ ctx[1] - actionBarHeightPx + "px",
    				contentId: "notes-content"
    			}
    		});

    	editor.$on("change", /*change_handler*/ ctx[6]);

    	return {
    		c() {
    			div = element("div");
    			create_component(editor.$$.fragment);
    			set_style(div, "--editor-width", /*widthPx*/ ctx[2] + "px");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(editor, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen(div, "dragstart", stop_propagation(prevent_default(/*dragstart_handler*/ ctx[4])));
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			const editor_changes = {};
    			if (dirty & /*contentHtml*/ 1) editor_changes.html = /*contentHtml*/ ctx[0];
    			if (dirty & /*heightPx*/ 2) editor_changes.height = /*heightPx*/ ctx[1] - actionBarHeightPx + "px";
    			editor.$set(editor_changes);

    			if (!current || dirty & /*widthPx*/ 4) {
    				set_style(div, "--editor-width", /*widthPx*/ ctx[2] + "px");
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(editor.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(editor.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(editor);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    const actionBarHeightPx = 36;

    function instance$7($$self, $$props, $$invalidate) {
    	onMount(() => {
    		const textInputElement = document.getElementById("notes-content");
    		textInputElement.focus();
    	});

    	let { heightPx } = $$props;
    	let { widthPx } = $$props;
    	let { contentHtml = "" } = $$props;
    	const dispatch = createEventDispatcher();

    	function dragstart_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const func = () => {
    		dispatch("save");
    	};

    	const change_handler = evt => {
    		$$invalidate(0, contentHtml = evt.detail);
    		dispatch("change");
    	};

    	$$self.$$set = $$props => {
    		if ('heightPx' in $$props) $$invalidate(1, heightPx = $$props.heightPx);
    		if ('widthPx' in $$props) $$invalidate(2, widthPx = $$props.widthPx);
    		if ('contentHtml' in $$props) $$invalidate(0, contentHtml = $$props.contentHtml);
    	};

    	return [
    		contentHtml,
    		heightPx,
    		widthPx,
    		dispatch,
    		dragstart_handler,
    		func,
    		change_handler
    	];
    }

    class Editor_1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$7, create_fragment$9, safe_not_equal, { heightPx: 1, widthPx: 2, contentHtml: 0 });
    	}
    }

    /* src/components/Dashboard/Notes/Note.svelte generated by Svelte v3.42.4 */

    function create_else_block(ctx) {
    	let div4;
    	let div0;
    	let html_tag;
    	let t0;
    	let t1;
    	let div3;
    	let div1;
    	let trashcan;
    	let t2;
    	let div2;
    	let t3_value = /*toDateString*/ ctx[11](new Date(/*timestamp*/ ctx[1])) + "";
    	let t3;
    	let div4_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*contentHtml*/ ctx[0] === "" && create_if_block_1();
    	trashcan = new TrashCan({});
    	trashcan.$on("click", /*onTrashCanClicked*/ ctx[12]);

    	return {
    		c() {
    			div4 = element("div");
    			div0 = element("div");
    			html_tag = new HtmlTag();
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div3 = element("div");
    			div1 = element("div");
    			create_component(trashcan.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(t3_value);
    			html_tag.a = t0;
    			attr(div0, "class", "noteviewcontent svelte-1c1kny");
    			attr(div1, "class", "deletebutton svelte-1c1kny");
    			attr(div2, "class", "lastedit");
    			attr(div3, "class", "footer svelte-1c1kny");
    			attr(div4, "class", "noteview svelte-1c1kny");
    			set_style(div4, "background-color", /*backgroundColor*/ ctx[2]);
    			set_style(div4, "--note-width", /*lastNoteViewElementWidth*/ ctx[7] + "px");
    			set_style(div4, "--note-height", /*lastNoteViewElementHeight*/ ctx[8] + "px");
    			attr(div4, "draggable", true);
    			attr(div4, "ondragover", "return false");
    			add_render_callback(() => /*div4_elementresize_handler*/ ctx[19].call(div4));
    		},
    		m(target, anchor) {
    			insert(target, div4, anchor);
    			append(div4, div0);
    			html_tag.m(/*contentHtml*/ ctx[0], div0);
    			append(div0, t0);
    			if (if_block) if_block.m(div0, null);
    			append(div4, t1);
    			append(div4, div3);
    			append(div3, div1);
    			mount_component(trashcan, div1, null);
    			append(div3, t2);
    			append(div3, div2);
    			append(div2, t3);
    			div4_resize_listener = add_resize_listener(div4, /*div4_elementresize_handler*/ ctx[19].bind(div4));
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(div0, "click", /*enableEditMode*/ ctx[9]),
    					action_destroyer(observeResize.call(null, div4, /*onNoteResize*/ ctx[13])),
    					listen(div4, "dragstart", /*dragstart_handler*/ ctx[15]),
    					listen(div4, "drop", prevent_default(/*drop_handler*/ ctx[16]))
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (!current || dirty & /*contentHtml*/ 1) html_tag.p(/*contentHtml*/ ctx[0]);

    			if (/*contentHtml*/ ctx[0] === "") {
    				if (if_block) ; else {
    					if_block = create_if_block_1();
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((!current || dirty & /*timestamp*/ 2) && t3_value !== (t3_value = /*toDateString*/ ctx[11](new Date(/*timestamp*/ ctx[1])) + "")) set_data(t3, t3_value);

    			if (!current || dirty & /*backgroundColor*/ 4) {
    				set_style(div4, "background-color", /*backgroundColor*/ ctx[2]);
    			}

    			if (!current || dirty & /*lastNoteViewElementWidth*/ 128) {
    				set_style(div4, "--note-width", /*lastNoteViewElementWidth*/ ctx[7] + "px");
    			}

    			if (!current || dirty & /*lastNoteViewElementHeight*/ 256) {
    				set_style(div4, "--note-height", /*lastNoteViewElementHeight*/ ctx[8] + "px");
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(trashcan.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(trashcan.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div4);
    			if (if_block) if_block.d();
    			destroy_component(trashcan);
    			div4_resize_listener();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (85:4) {#if editMode}
    function create_if_block(ctx) {
    	let editor;
    	let updating_contentHtml;
    	let current;

    	function editor_contentHtml_binding(value) {
    		/*editor_contentHtml_binding*/ ctx[17](value);
    	}

    	let editor_props = {
    		heightPx: /*lastNoteViewElementHeight*/ ctx[8],
    		widthPx: /*lastNoteViewElementWidth*/ ctx[7]
    	};

    	if (/*contentHtml*/ ctx[0] !== void 0) {
    		editor_props.contentHtml = /*contentHtml*/ ctx[0];
    	}

    	editor = new Editor_1({ props: editor_props });
    	binding_callbacks.push(() => bind$1(editor, 'contentHtml', editor_contentHtml_binding));
    	editor.$on("change", /*change_handler*/ ctx[18]);
    	editor.$on("save", /*disableEditMode*/ ctx[10]);

    	return {
    		c() {
    			create_component(editor.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(editor, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const editor_changes = {};
    			if (dirty & /*lastNoteViewElementHeight*/ 256) editor_changes.heightPx = /*lastNoteViewElementHeight*/ ctx[8];
    			if (dirty & /*lastNoteViewElementWidth*/ 128) editor_changes.widthPx = /*lastNoteViewElementWidth*/ ctx[7];

    			if (!updating_contentHtml && dirty & /*contentHtml*/ 1) {
    				updating_contentHtml = true;
    				editor_changes.contentHtml = /*contentHtml*/ ctx[0];
    				add_flush_callback(() => updating_contentHtml = false);
    			}

    			editor.$set(editor_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(editor.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(editor.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(editor, detaching);
    		}
    	};
    }

    // (107:10) {#if contentHtml === ""}
    function create_if_block_1(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			div.textContent = "Zum Bearbeiten hier klicken";
    			attr(div, "class", "helptext svelte-1c1kny");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    function create_fragment$8(ctx) {
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*editMode*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			attr(div0, "class", "note svelte-1c1kny");
    			attr(div1, "class", "notecontainer svelte-1c1kny");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(clickOutside.call(null, div0)),
    					listen(div0, "click_outside", /*disableEditMode*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { contentHtml = "" } = $$props;
    	let { timestamp = new Date().getTime() } = $$props;
    	let { backgroundColor } = $$props;
    	let { id } = $$props;
    	const convertRemToPixels = rem => rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    	const INITIAL_WIDTH_HEIGHT = convertRemToPixels(24);
    	let editMode = false;
    	let contentChanged = false;
    	let noteViewElementWidth;
    	let noteViewElementHeight;
    	let lastNoteViewElementWidth = INITIAL_WIDTH_HEIGHT;
    	let lastNoteViewElementHeight = INITIAL_WIDTH_HEIGHT;
    	let initialResizeDone = false;
    	const dispatch = createEventDispatcher();

    	const enableEditMode = () => {
    		if (!editMode) {
    			$$invalidate(3, editMode = true);
    		}
    	};

    	const disableEditMode = () => {
    		$$invalidate(3, editMode = false);

    		if (contentChanged) {
    			dispatch("change", contentHtml);
    			$$invalidate(4, contentChanged = false);
    		}
    	};

    	const toDateString = date => {
    		const padZero = value => value.toString().padStart(2, "0");
    		return `${padZero(date.getDate())}.${padZero(date.getMonth() + 1)}.${date.getFullYear()}`;
    	};

    	const onTrashCanClicked = event => {
    		if (confirm("Soll diese Notiz wirklich gelöscht werden?")) {
    			dispatch("delete");
    		}
    	};

    	const onNoteResize = () => {
    		// ignore initial resize (would reset the size to initial value)
    		if (initialResizeDone) {
    			localStorage.setItem(id + "_size", JSON.stringify({
    				width: noteViewElementWidth,
    				height: noteViewElementHeight
    			}));

    			$$invalidate(7, lastNoteViewElementWidth = noteViewElementWidth);
    			$$invalidate(8, lastNoteViewElementHeight = noteViewElementHeight);
    		}

    		initialResizeDone = true;
    	};

    	onMount(() => {
    		const storedSize = localStorage.getItem(id + "_size");

    		if (storedSize !== null) {
    			let size = JSON.parse(storedSize);
    			$$invalidate(7, lastNoteViewElementWidth = size.width);
    			$$invalidate(8, lastNoteViewElementHeight = size.height);
    		}
    	});

    	function dragstart_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function drop_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function editor_contentHtml_binding(value) {
    		contentHtml = value;
    		$$invalidate(0, contentHtml);
    	}

    	const change_handler = e => $$invalidate(4, contentChanged = true);

    	function div4_elementresize_handler() {
    		noteViewElementWidth = this.offsetWidth;
    		noteViewElementHeight = this.offsetHeight;
    		$$invalidate(5, noteViewElementWidth);
    		$$invalidate(6, noteViewElementHeight);
    	}

    	$$self.$$set = $$props => {
    		if ('contentHtml' in $$props) $$invalidate(0, contentHtml = $$props.contentHtml);
    		if ('timestamp' in $$props) $$invalidate(1, timestamp = $$props.timestamp);
    		if ('backgroundColor' in $$props) $$invalidate(2, backgroundColor = $$props.backgroundColor);
    		if ('id' in $$props) $$invalidate(14, id = $$props.id);
    	};

    	return [
    		contentHtml,
    		timestamp,
    		backgroundColor,
    		editMode,
    		contentChanged,
    		noteViewElementWidth,
    		noteViewElementHeight,
    		lastNoteViewElementWidth,
    		lastNoteViewElementHeight,
    		enableEditMode,
    		disableEditMode,
    		toDateString,
    		onTrashCanClicked,
    		onNoteResize,
    		id,
    		dragstart_handler,
    		drop_handler,
    		editor_contentHtml_binding,
    		change_handler,
    		div4_elementresize_handler
    	];
    }

    class Note extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$6, create_fragment$8, safe_not_equal, {
    			contentHtml: 0,
    			timestamp: 1,
    			backgroundColor: 2,
    			id: 14
    		});
    	}
    }

    /* src/components/svgs/Plus.svelte generated by Svelte v3.42.4 */

    function create_fragment$7(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let polygon;

    	return {
    		c() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			polygon = svg_element("polygon");
    			attr(polygon, "points", "289.391,222.609 289.391,0 222.609,0 222.609,222.609 0,222.609 0,289.391 222.609,289.391 222.609,512 \n\t\t\t289.391,512 289.391,289.391 512,289.391 512,222.609");
    			attr(svg, "x", "0px");
    			attr(svg, "y", "0px");
    			attr(svg, "viewBox", "0 0 512 512");
    			attr(svg, "width", "6em");
    			attr(svg, "height", "6em");
    		},
    		m(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, g1);
    			append(g1, g0);
    			append(g0, polygon);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(svg);
    		}
    	};
    }

    class Plus extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$7, safe_not_equal, {});
    	}
    }

    /* src/components/Dashboard/Notes/AddNote.svelte generated by Svelte v3.42.4 */

    function create_fragment$6(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let plus;
    	let t0;
    	let div0;
    	let current;
    	let mounted;
    	let dispose;
    	plus = new Plus({});

    	return {
    		c() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			create_component(plus.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "Neue Notiz";
    			attr(div0, "class", "text svelte-13ow87f");
    			attr(div1, "class", "addnotecontent svelte-13ow87f");
    			attr(div2, "class", "addnote svelte-13ow87f");
    			attr(div3, "class", "addnotecontainer svelte-13ow87f");
    			attr(div3, "id", "addnotecontainer");
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			append(div2, div1);
    			mount_component(plus, div1, null);
    			append(div1, t0);
    			append(div1, div0);
    			current = true;

    			if (!mounted) {
    				dispose = listen(div2, "click", /*click_handler*/ ctx[0]);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(plus.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(plus.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div3);
    			destroy_component(plus);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$5($$self) {
    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	return [click_handler];
    }

    class AddNote extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$5, create_fragment$6, safe_not_equal, {});
    	}
    }

    /* src/components/Dashboard/Notes/Notes.svelte generated by Svelte v3.42.4 */

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (125:4) {#each notes as note, index (note._id)}
    function create_each_block(key_1, ctx) {
    	let div;
    	let note;
    	let rect;
    	let stop_animation = noop$1;
    	let current;

    	function delete_handler(...args) {
    		return /*delete_handler*/ ctx[6](/*note*/ ctx[14], ...args);
    	}

    	function change_handler(...args) {
    		return /*change_handler*/ ctx[7](/*note*/ ctx[14], ...args);
    	}

    	function dragstart_handler(...args) {
    		return /*dragstart_handler*/ ctx[8](/*index*/ ctx[16], ...args);
    	}

    	function drop_handler(...args) {
    		return /*drop_handler*/ ctx[9](/*index*/ ctx[16], ...args);
    	}

    	note = new Note({
    			props: {
    				id: /*note*/ ctx[14]._id,
    				contentHtml: /*note*/ ctx[14].contentHtml,
    				timestamp: /*note*/ ctx[14].timestamp,
    				backgroundColor: /*note*/ ctx[14].backgroundColor
    			}
    		});

    	note.$on("delete", delete_handler);
    	note.$on("change", change_handler);
    	note.$on("dragstart", dragstart_handler);
    	note.$on("drop", drop_handler);

    	return {
    		key: key_1,
    		first: null,
    		c() {
    			div = element("div");
    			create_component(note.$$.fragment);
    			this.first = div;
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(note, div, null);
    			current = true;
    		},
    		p(new_ctx, dirty) {
    			ctx = new_ctx;
    			const note_changes = {};
    			if (dirty & /*notes*/ 1) note_changes.id = /*note*/ ctx[14]._id;
    			if (dirty & /*notes*/ 1) note_changes.contentHtml = /*note*/ ctx[14].contentHtml;
    			if (dirty & /*notes*/ 1) note_changes.timestamp = /*note*/ ctx[14].timestamp;
    			if (dirty & /*notes*/ 1) note_changes.backgroundColor = /*note*/ ctx[14].backgroundColor;
    			note.$set(note_changes);
    		},
    		r() {
    			rect = div.getBoundingClientRect();
    		},
    		f() {
    			fix_position(div);
    			stop_animation();
    		},
    		a() {
    			stop_animation();
    			stop_animation = create_animation(div, rect, flip, { duration: flipDurationMs });
    		},
    		i(local) {
    			if (current) return;
    			transition_in(note.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(note.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(note);
    		}
    	};
    }

    function create_fragment$5(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t2;
    	let addnote;
    	let current;
    	let each_value = /*notes*/ ctx[0];
    	const get_key = ctx => /*note*/ ctx[14]._id;

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	addnote = new AddNote({});
    	addnote.$on("click", /*onAddNodeButtonClicked*/ ctx[1]);

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Notizen";
    			t1 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			create_component(addnote.$$.fragment);
    			attr(div0, "class", "notescontainerheader svelte-t4qyib");
    			attr(div1, "class", "notescontainercontent svelte-t4qyib");
    			attr(div2, "class", "notescontainer svelte-t4qyib");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t1);
    			append(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append(div1, t2);
    			mount_component(addnote, div1, null);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*notes, onNoteDeleted, onNoteChanged, onNoteDragStart, onNoteDrop*/ 61) {
    				each_value = /*notes*/ ctx[0];
    				group_outros();
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, fix_and_outro_and_destroy_block, create_each_block, t2, get_each_context);
    				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(addnote.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(addnote.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(addnote);
    		}
    	};
    }

    const flipDurationMs = 300;
    const docType = "note";

    function instance$4($$self, $$props, $$invalidate) {
    	const colors = ["#ffd8c0", "#a1f5cf", "#f1bff4", "#d9bafd", "#a4e2fb", "#fdb7b8"];
    	const randomColor = () => colors[Math.floor(Math.random() * colors.length)];
    	let notes = [];

    	const loadNotesFromDatabase = (forceRefreshCache = false) => Database.fetchByType("note", forceRefreshCache).then(result => $$invalidate(0, notes = result.sort((noteA, noteB) => noteA.orderIndex - noteB.orderIndex))).catch(error => {
    		Logger.error(`Failed to load notes`, error);
    		danger("Notizen konnten nicht geladen werden!", { persist: true });
    	});

    	onMount(() => {
    		loadNotesFromDatabase().then(() => Database.listenForChanges(() => loadNotesFromDatabase(true), docType));
    	});

    	onDestroy(() => {
    		Database.cancelListenerForDocType(docType);
    	});

    	const initializeNode = () => ({
    		_id: v4(),
    		contentHtml: "",
    		timestamp: new Date().getTime(),
    		backgroundColor: randomColor(),
    		orderIndex: Math.min(notes.map(note => note.orderIndex)) - 1,
    		type: "note"
    	});

    	const onAddNodeButtonClicked = () => {
    		const newNote = initializeNode();
    		$$invalidate(0, notes = [newNote, ...notes]);

    		Database.createDoc(newNote).then(response => newNote._rev = response.rev).catch(error => {
    			Logger.error(`Failed to create note ${newNote._id}`, error);
    			danger("Notiz konnte nicht gespeichert werden!", { persist: true });
    		});
    	};

    	const onNoteDeleted = noteId => {
    		const noteToRemove = notes.find(note => note._id === noteId);
    		$$invalidate(0, notes = notes.filter(note => note._id !== noteId));

    		Database.removeDoc(noteToRemove).catch(error => {
    			Logger.error(`Failed to remove note ${noteId}`, error);
    			danger("Notiz konnte nicht gelöscht werden!", { persist: true });
    		});
    	};

    	const onNoteChanged = (noteId, changedContentHtml) => {
    		const note = notes.find(note => note._id === noteId);
    		note.timestamp = new Date().getTime();
    		note.contentHtml = changedContentHtml;
    		$$invalidate(0, notes = [...notes]);

    		Database.updateDoc(note, false).then(response => note._rev = response.rev).catch(error => {
    			Logger.error(`Failed to save note ${noteId}`, error);
    			danger("Notiz konnte nicht gespeichert werden!", { persist: true });
    		});
    	};

    	const onNoteDrop = (event, dragEndIndex) => {
    		event.dataTransfer.dropEffect = "move";
    		const dragStartIndex = parseInt(event.dataTransfer.getData("text/plain"));

    		if (dragStartIndex !== dragEndIndex) {
    			const draggedNote = notes[dragStartIndex];
    			$$invalidate(0, notes[dragStartIndex] = notes[dragEndIndex], notes);
    			$$invalidate(0, notes[dragEndIndex] = draggedNote, notes);
    			notes.forEach((note, i) => note.orderIndex = i);
    			$$invalidate(0, notes = [...notes]);

    			// TODO: improve, reduce db updates
    			notes.forEach(note => Database.updateDoc(note));
    		}
    	};

    	const onNoteDragStart = (event, i) => {
    		event.dataTransfer.effectAllowed = "move";
    		event.dataTransfer.dropEffect = "move";
    		const startIndex = i;
    		event.dataTransfer.setData("text/plain", startIndex);
    	};

    	const delete_handler = (note, e) => onNoteDeleted(note._id);
    	const change_handler = (note, e) => onNoteChanged(note._id, e.detail);
    	const dragstart_handler = (index, event) => onNoteDragStart(event, index);
    	const drop_handler = (index, event) => onNoteDrop(event, index);

    	return [
    		notes,
    		onAddNodeButtonClicked,
    		onNoteDeleted,
    		onNoteChanged,
    		onNoteDrop,
    		onNoteDragStart,
    		delete_handler,
    		change_handler,
    		dragstart_handler,
    		drop_handler
    	];
    }

    class Notes extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$4, create_fragment$5, safe_not_equal, {});
    	}
    }

    function clean($$props, extra_keys) {
      let keys = ["children", "$$scope", "$$slots"].concat(extra_keys);
      const rest = {};
      for (const key of Object.keys($$props)) {
        if (!(keys.includes(key))) {
          rest[key] = $$props[key];
        }
      }
      return rest;
    }

    /*!
     * Chart.js v3.6.0
     * https://www.chartjs.org
     * (c) 2021 Chart.js Contributors
     * Released under the MIT License
     */
    const requestAnimFrame = (function() {
      if (typeof window === 'undefined') {
        return function(callback) {
          return callback();
        };
      }
      return window.requestAnimationFrame;
    }());
    function throttled(fn, thisArg, updateFn) {
      const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));
      let ticking = false;
      let args = [];
      return function(...rest) {
        args = updateArgs(rest);
        if (!ticking) {
          ticking = true;
          requestAnimFrame.call(window, () => {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        if (delay) {
          clearTimeout(timeout);
          timeout = setTimeout(fn, delay, args);
        } else {
          fn.apply(this, args);
        }
        return delay;
      };
    }
    const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
    const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
    const _textX = (align, left, right, rtl) => {
      const check = rtl ? 'left' : 'right';
      return align === check ? right : align === 'center' ? (left + right) / 2 : left;
    };

    function noop() {}
    const uid = (function() {
      let id = 0;
      return function() {
        return id++;
      };
    }());
    function isNullOrUndef(value) {
      return value === null || typeof value === 'undefined';
    }
    function isArray(value) {
      if (Array.isArray && Array.isArray(value)) {
        return true;
      }
      const type = Object.prototype.toString.call(value);
      if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
        return true;
      }
      return false;
    }
    function isObject(value) {
      return value !== null && Object.prototype.toString.call(value) === '[object Object]';
    }
    const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);
    function finiteOrDefault(value, defaultValue) {
      return isNumberFinite(value) ? value : defaultValue;
    }
    function valueOrDefault(value, defaultValue) {
      return typeof value === 'undefined' ? defaultValue : value;
    }
    const toPercentage = (value, dimension) =>
      typeof value === 'string' && value.endsWith('%') ?
        parseFloat(value) / 100
        : value / dimension;
    const toDimension = (value, dimension) =>
      typeof value === 'string' && value.endsWith('%') ?
        parseFloat(value) / 100 * dimension
        : +value;
    function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === 'function') {
        return fn.apply(thisArg, args);
      }
    }
    function each(loopable, fn, thisArg, reverse) {
      let i, len, keys;
      if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) {
          for (i = len - 1; i >= 0; i--) {
            fn.call(thisArg, loopable[i], i);
          }
        } else {
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[i], i);
          }
        }
      } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
      }
    }
    function _elementsEqual(a0, a1) {
      let i, ilen, v0, v1;
      if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
      }
      for (i = 0, ilen = a0.length; i < ilen; ++i) {
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
          return false;
        }
      }
      return true;
    }
    function clone$1(source) {
      if (isArray(source)) {
        return source.map(clone$1);
      }
      if (isObject(source)) {
        const target = Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for (; k < klen; ++k) {
          target[keys[k]] = clone$1(source[keys[k]]);
        }
        return target;
      }
      return source;
    }
    function isValidKey(key) {
      return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
    }
    function _merger(key, target, source, options) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source[key];
      if (isObject(tval) && isObject(sval)) {
        merge(tval, sval, options);
      } else {
        target[key] = clone$1(sval);
      }
    }
    function merge(target, source, options) {
      const sources = isArray(source) ? source : [source];
      const ilen = sources.length;
      if (!isObject(target)) {
        return target;
      }
      options = options || {};
      const merger = options.merger || _merger;
      for (let i = 0; i < ilen; ++i) {
        source = sources[i];
        if (!isObject(source)) {
          continue;
        }
        const keys = Object.keys(source);
        for (let k = 0, klen = keys.length; k < klen; ++k) {
          merger(keys[k], target, source, options);
        }
      }
      return target;
    }
    function mergeIf(target, source) {
      return merge(target, source, {merger: _mergerIf});
    }
    function _mergerIf(key, target, source) {
      if (!isValidKey(key)) {
        return;
      }
      const tval = target[key];
      const sval = source[key];
      if (isObject(tval) && isObject(sval)) {
        mergeIf(tval, sval);
      } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = clone$1(sval);
      }
    }
    const emptyString = '';
    const dot = '.';
    function indexOfDotOrLength(key, start) {
      const idx = key.indexOf(dot, start);
      return idx === -1 ? key.length : idx;
    }
    function resolveObjectKey(obj, key) {
      if (key === emptyString) {
        return obj;
      }
      let pos = 0;
      let idx = indexOfDotOrLength(key, pos);
      while (obj && idx > pos) {
        obj = obj[key.substr(pos, idx - pos)];
        pos = idx + 1;
        idx = indexOfDotOrLength(key, pos);
      }
      return obj;
    }
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    const defined = (value) => typeof value !== 'undefined';
    const isFunction = (value) => typeof value === 'function';
    const setsEqual = (a, b) => {
      if (a.size !== b.size) {
        return false;
      }
      for (const item of a) {
        if (!b.has(item)) {
          return false;
        }
      }
      return true;
    };

    const PI = Math.PI;
    const TAU = 2 * PI;
    const PITAU = TAU + PI;
    const INFINITY = Number.POSITIVE_INFINITY;
    const RAD_PER_DEG = PI / 180;
    const HALF_PI = PI / 2;
    const QUARTER_PI = PI / 4;
    const TWO_THIRDS_PI = PI * 2 / 3;
    const log10 = Math.log10;
    const sign = Math.sign;
    function niceNum(range) {
      const roundedRange = Math.round(range);
      range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
      const niceRange = Math.pow(10, Math.floor(log10(range)));
      const fraction = range / niceRange;
      const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
      return niceFraction * niceRange;
    }
    function _factorize(value) {
      const result = [];
      const sqrt = Math.sqrt(value);
      let i;
      for (i = 1; i < sqrt; i++) {
        if (value % i === 0) {
          result.push(i);
          result.push(value / i);
        }
      }
      if (sqrt === (sqrt | 0)) {
        result.push(sqrt);
      }
      result.sort((a, b) => a - b).pop();
      return result;
    }
    function isNumber(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function almostEquals(x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
    }
    function almostWhole(x, epsilon) {
      const rounded = Math.round(x);
      return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);
    }
    function _setMinAndMaxByKey(array, target, property) {
      let i, ilen, value;
      for (i = 0, ilen = array.length; i < ilen; i++) {
        value = array[i][property];
        if (!isNaN(value)) {
          target.min = Math.min(target.min, value);
          target.max = Math.max(target.max, value);
        }
      }
    }
    function toRadians(degrees) {
      return degrees * (PI / 180);
    }
    function toDegrees(radians) {
      return radians * (180 / PI);
    }
    function _decimalPlaces(x) {
      if (!isNumberFinite(x)) {
        return;
      }
      let e = 1;
      let p = 0;
      while (Math.round(x * e) / e !== x) {
        e *= 10;
        p++;
      }
      return p;
    }
    function getAngleFromPoint(centrePoint, anglePoint) {
      const distanceFromXCenter = anglePoint.x - centrePoint.x;
      const distanceFromYCenter = anglePoint.y - centrePoint.y;
      const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
      if (angle < (-0.5 * PI)) {
        angle += TAU;
      }
      return {
        angle,
        distance: radialDistanceFromCenter
      };
    }
    function distanceBetweenPoints(pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    }
    function _angleDiff(a, b) {
      return (a - b + PITAU) % TAU - PI;
    }
    function _normalizeAngle(a) {
      return (a % TAU + TAU) % TAU;
    }
    function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
      const a = _normalizeAngle(angle);
      const s = _normalizeAngle(start);
      const e = _normalizeAngle(end);
      const angleToStart = _normalizeAngle(s - a);
      const angleToEnd = _normalizeAngle(e - a);
      const startToAngle = _normalizeAngle(a - s);
      const endToAngle = _normalizeAngle(a - e);
      return a === s || a === e || (sameAngleIsFullCircle && s === e)
        || (angleToStart > angleToEnd && startToAngle < endToAngle);
    }
    function _limitValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    function _int16Range(value) {
      return _limitValue(value, -32768, 32767);
    }

    const atEdge = (t) => t === 0 || t === 1;
    const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
    const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
    const effects = {
      linear: t => t,
      easeInQuad: t => t * t,
      easeOutQuad: t => -t * (t - 2),
      easeInOutQuad: t => ((t /= 0.5) < 1)
        ? 0.5 * t * t
        : -0.5 * ((--t) * (t - 2) - 1),
      easeInCubic: t => t * t * t,
      easeOutCubic: t => (t -= 1) * t * t + 1,
      easeInOutCubic: t => ((t /= 0.5) < 1)
        ? 0.5 * t * t * t
        : 0.5 * ((t -= 2) * t * t + 2),
      easeInQuart: t => t * t * t * t,
      easeOutQuart: t => -((t -= 1) * t * t * t - 1),
      easeInOutQuart: t => ((t /= 0.5) < 1)
        ? 0.5 * t * t * t * t
        : -0.5 * ((t -= 2) * t * t * t - 2),
      easeInQuint: t => t * t * t * t * t,
      easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
      easeInOutQuint: t => ((t /= 0.5) < 1)
        ? 0.5 * t * t * t * t * t
        : 0.5 * ((t -= 2) * t * t * t * t + 2),
      easeInSine: t => -Math.cos(t * HALF_PI) + 1,
      easeOutSine: t => Math.sin(t * HALF_PI),
      easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
      easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,
      easeInOutExpo: t => atEdge(t) ? t : t < 0.5
        ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
        : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
      easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),
      easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
      easeInOutCirc: t => ((t /= 0.5) < 1)
        ? -0.5 * (Math.sqrt(1 - t * t) - 1)
        : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
      easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
      easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
      easeInOutElastic(t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t :
          t < 0.5
            ? 0.5 * elasticIn(t * 2, s, p)
            : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
      },
      easeInBack(t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack(t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack(t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
      },
      easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
      easeOutBounce(t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < (1 / d)) {
          return m * t * t;
        }
        if (t < (2 / d)) {
          return m * (t -= (1.5 / d)) * t + 0.75;
        }
        if (t < (2.5 / d)) {
          return m * (t -= (2.25 / d)) * t + 0.9375;
        }
        return m * (t -= (2.625 / d)) * t + 0.984375;
      },
      easeInOutBounce: t => (t < 0.5)
        ? effects.easeInBounce(t * 2) * 0.5
        : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
    };

    /*!
     * @kurkle/color v0.1.9
     * https://github.com/kurkle/color#readme
     * (c) 2020 Jukka Kurkela
     * Released under the MIT License
     */
    const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
    const hex = '0123456789ABCDEF';
    const h1 = (b) => hex[b & 0xF];
    const h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
    const eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));
    function isShort(v) {
    	return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
    }
    function hexParse(str) {
    	var len = str.length;
    	var ret;
    	if (str[0] === '#') {
    		if (len === 4 || len === 5) {
    			ret = {
    				r: 255 & map$1[str[1]] * 17,
    				g: 255 & map$1[str[2]] * 17,
    				b: 255 & map$1[str[3]] * 17,
    				a: len === 5 ? map$1[str[4]] * 17 : 255
    			};
    		} else if (len === 7 || len === 9) {
    			ret = {
    				r: map$1[str[1]] << 4 | map$1[str[2]],
    				g: map$1[str[3]] << 4 | map$1[str[4]],
    				b: map$1[str[5]] << 4 | map$1[str[6]],
    				a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
    			};
    		}
    	}
    	return ret;
    }
    function hexString(v) {
    	var f = isShort(v) ? h1 : h2;
    	return v
    		? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')
    		: v;
    }
    function round(v) {
    	return v + 0.5 | 0;
    }
    const lim = (v, l, h) => Math.max(Math.min(v, h), l);
    function p2b(v) {
    	return lim(round(v * 2.55), 0, 255);
    }
    function n2b(v) {
    	return lim(round(v * 255), 0, 255);
    }
    function b2n(v) {
    	return lim(round(v / 2.55) / 100, 0, 1);
    }
    function n2p(v) {
    	return lim(round(v * 100), 0, 100);
    }
    const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function rgbParse(str) {
    	const m = RGB_RE.exec(str);
    	let a = 255;
    	let r, g, b;
    	if (!m) {
    		return;
    	}
    	if (m[7] !== r) {
    		const v = +m[7];
    		a = 255 & (m[8] ? p2b(v) : v * 255);
    	}
    	r = +m[1];
    	g = +m[3];
    	b = +m[5];
    	r = 255 & (m[2] ? p2b(r) : r);
    	g = 255 & (m[4] ? p2b(g) : g);
    	b = 255 & (m[6] ? p2b(b) : b);
    	return {
    		r: r,
    		g: g,
    		b: b,
    		a: a
    	};
    }
    function rgbString(v) {
    	return v && (
    		v.a < 255
    			? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
    			: `rgb(${v.r}, ${v.g}, ${v.b})`
    	);
    }
    const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function hsl2rgbn(h, s, l) {
    	const a = s * Math.min(l, 1 - l);
    	const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    	return [f(0), f(8), f(4)];
    }
    function hsv2rgbn(h, s, v) {
    	const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    	return [f(5), f(3), f(1)];
    }
    function hwb2rgbn(h, w, b) {
    	const rgb = hsl2rgbn(h, 1, 0.5);
    	let i;
    	if (w + b > 1) {
    		i = 1 / (w + b);
    		w *= i;
    		b *= i;
    	}
    	for (i = 0; i < 3; i++) {
    		rgb[i] *= 1 - w - b;
    		rgb[i] += w;
    	}
    	return rgb;
    }
    function rgb2hsl(v) {
    	const range = 255;
    	const r = v.r / range;
    	const g = v.g / range;
    	const b = v.b / range;
    	const max = Math.max(r, g, b);
    	const min = Math.min(r, g, b);
    	const l = (max + min) / 2;
    	let h, s, d;
    	if (max !== min) {
    		d = max - min;
    		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    		h = max === r
    			? ((g - b) / d) + (g < b ? 6 : 0)
    			: max === g
    				? (b - r) / d + 2
    				: (r - g) / d + 4;
    		h = h * 60 + 0.5;
    	}
    	return [h | 0, s || 0, l];
    }
    function calln(f, a, b, c) {
    	return (
    		Array.isArray(a)
    			? f(a[0], a[1], a[2])
    			: f(a, b, c)
    	).map(n2b);
    }
    function hsl2rgb(h, s, l) {
    	return calln(hsl2rgbn, h, s, l);
    }
    function hwb2rgb(h, w, b) {
    	return calln(hwb2rgbn, h, w, b);
    }
    function hsv2rgb(h, s, v) {
    	return calln(hsv2rgbn, h, s, v);
    }
    function hue(h) {
    	return (h % 360 + 360) % 360;
    }
    function hueParse(str) {
    	const m = HUE_RE.exec(str);
    	let a = 255;
    	let v;
    	if (!m) {
    		return;
    	}
    	if (m[5] !== v) {
    		a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    	}
    	const h = hue(+m[2]);
    	const p1 = +m[3] / 100;
    	const p2 = +m[4] / 100;
    	if (m[1] === 'hwb') {
    		v = hwb2rgb(h, p1, p2);
    	} else if (m[1] === 'hsv') {
    		v = hsv2rgb(h, p1, p2);
    	} else {
    		v = hsl2rgb(h, p1, p2);
    	}
    	return {
    		r: v[0],
    		g: v[1],
    		b: v[2],
    		a: a
    	};
    }
    function rotate(v, deg) {
    	var h = rgb2hsl(v);
    	h[0] = hue(h[0] + deg);
    	h = hsl2rgb(h);
    	v.r = h[0];
    	v.g = h[1];
    	v.b = h[2];
    }
    function hslString(v) {
    	if (!v) {
    		return;
    	}
    	const a = rgb2hsl(v);
    	const h = a[0];
    	const s = n2p(a[1]);
    	const l = n2p(a[2]);
    	return v.a < 255
    		? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
    		: `hsl(${h}, ${s}%, ${l}%)`;
    }
    const map$1$1 = {
    	x: 'dark',
    	Z: 'light',
    	Y: 're',
    	X: 'blu',
    	W: 'gr',
    	V: 'medium',
    	U: 'slate',
    	A: 'ee',
    	T: 'ol',
    	S: 'or',
    	B: 'ra',
    	C: 'lateg',
    	D: 'ights',
    	R: 'in',
    	Q: 'turquois',
    	E: 'hi',
    	P: 'ro',
    	O: 'al',
    	N: 'le',
    	M: 'de',
    	L: 'yello',
    	F: 'en',
    	K: 'ch',
    	G: 'arks',
    	H: 'ea',
    	I: 'ightg',
    	J: 'wh'
    };
    const names = {
    	OiceXe: 'f0f8ff',
    	antiquewEte: 'faebd7',
    	aqua: 'ffff',
    	aquamarRe: '7fffd4',
    	azuY: 'f0ffff',
    	beige: 'f5f5dc',
    	bisque: 'ffe4c4',
    	black: '0',
    	blanKedOmond: 'ffebcd',
    	Xe: 'ff',
    	XeviTet: '8a2be2',
    	bPwn: 'a52a2a',
    	burlywood: 'deb887',
    	caMtXe: '5f9ea0',
    	KartYuse: '7fff00',
    	KocTate: 'd2691e',
    	cSO: 'ff7f50',
    	cSnflowerXe: '6495ed',
    	cSnsilk: 'fff8dc',
    	crimson: 'dc143c',
    	cyan: 'ffff',
    	xXe: '8b',
    	xcyan: '8b8b',
    	xgTMnPd: 'b8860b',
    	xWay: 'a9a9a9',
    	xgYF: '6400',
    	xgYy: 'a9a9a9',
    	xkhaki: 'bdb76b',
    	xmagFta: '8b008b',
    	xTivegYF: '556b2f',
    	xSange: 'ff8c00',
    	xScEd: '9932cc',
    	xYd: '8b0000',
    	xsOmon: 'e9967a',
    	xsHgYF: '8fbc8f',
    	xUXe: '483d8b',
    	xUWay: '2f4f4f',
    	xUgYy: '2f4f4f',
    	xQe: 'ced1',
    	xviTet: '9400d3',
    	dAppRk: 'ff1493',
    	dApskyXe: 'bfff',
    	dimWay: '696969',
    	dimgYy: '696969',
    	dodgerXe: '1e90ff',
    	fiYbrick: 'b22222',
    	flSOwEte: 'fffaf0',
    	foYstWAn: '228b22',
    	fuKsia: 'ff00ff',
    	gaRsbSo: 'dcdcdc',
    	ghostwEte: 'f8f8ff',
    	gTd: 'ffd700',
    	gTMnPd: 'daa520',
    	Way: '808080',
    	gYF: '8000',
    	gYFLw: 'adff2f',
    	gYy: '808080',
    	honeyMw: 'f0fff0',
    	hotpRk: 'ff69b4',
    	RdianYd: 'cd5c5c',
    	Rdigo: '4b0082',
    	ivSy: 'fffff0',
    	khaki: 'f0e68c',
    	lavFMr: 'e6e6fa',
    	lavFMrXsh: 'fff0f5',
    	lawngYF: '7cfc00',
    	NmoncEffon: 'fffacd',
    	ZXe: 'add8e6',
    	ZcSO: 'f08080',
    	Zcyan: 'e0ffff',
    	ZgTMnPdLw: 'fafad2',
    	ZWay: 'd3d3d3',
    	ZgYF: '90ee90',
    	ZgYy: 'd3d3d3',
    	ZpRk: 'ffb6c1',
    	ZsOmon: 'ffa07a',
    	ZsHgYF: '20b2aa',
    	ZskyXe: '87cefa',
    	ZUWay: '778899',
    	ZUgYy: '778899',
    	ZstAlXe: 'b0c4de',
    	ZLw: 'ffffe0',
    	lime: 'ff00',
    	limegYF: '32cd32',
    	lRF: 'faf0e6',
    	magFta: 'ff00ff',
    	maPon: '800000',
    	VaquamarRe: '66cdaa',
    	VXe: 'cd',
    	VScEd: 'ba55d3',
    	VpurpN: '9370db',
    	VsHgYF: '3cb371',
    	VUXe: '7b68ee',
    	VsprRggYF: 'fa9a',
    	VQe: '48d1cc',
    	VviTetYd: 'c71585',
    	midnightXe: '191970',
    	mRtcYam: 'f5fffa',
    	mistyPse: 'ffe4e1',
    	moccasR: 'ffe4b5',
    	navajowEte: 'ffdead',
    	navy: '80',
    	Tdlace: 'fdf5e6',
    	Tive: '808000',
    	TivedBb: '6b8e23',
    	Sange: 'ffa500',
    	SangeYd: 'ff4500',
    	ScEd: 'da70d6',
    	pOegTMnPd: 'eee8aa',
    	pOegYF: '98fb98',
    	pOeQe: 'afeeee',
    	pOeviTetYd: 'db7093',
    	papayawEp: 'ffefd5',
    	pHKpuff: 'ffdab9',
    	peru: 'cd853f',
    	pRk: 'ffc0cb',
    	plum: 'dda0dd',
    	powMrXe: 'b0e0e6',
    	purpN: '800080',
    	YbeccapurpN: '663399',
    	Yd: 'ff0000',
    	Psybrown: 'bc8f8f',
    	PyOXe: '4169e1',
    	saddNbPwn: '8b4513',
    	sOmon: 'fa8072',
    	sandybPwn: 'f4a460',
    	sHgYF: '2e8b57',
    	sHshell: 'fff5ee',
    	siFna: 'a0522d',
    	silver: 'c0c0c0',
    	skyXe: '87ceeb',
    	UXe: '6a5acd',
    	UWay: '708090',
    	UgYy: '708090',
    	snow: 'fffafa',
    	sprRggYF: 'ff7f',
    	stAlXe: '4682b4',
    	tan: 'd2b48c',
    	teO: '8080',
    	tEstN: 'd8bfd8',
    	tomato: 'ff6347',
    	Qe: '40e0d0',
    	viTet: 'ee82ee',
    	JHt: 'f5deb3',
    	wEte: 'ffffff',
    	wEtesmoke: 'f5f5f5',
    	Lw: 'ffff00',
    	LwgYF: '9acd32'
    };
    function unpack() {
    	const unpacked = {};
    	const keys = Object.keys(names);
    	const tkeys = Object.keys(map$1$1);
    	let i, j, k, ok, nk;
    	for (i = 0; i < keys.length; i++) {
    		ok = nk = keys[i];
    		for (j = 0; j < tkeys.length; j++) {
    			k = tkeys[j];
    			nk = nk.replace(k, map$1$1[k]);
    		}
    		k = parseInt(names[ok], 16);
    		unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
    	}
    	return unpacked;
    }
    let names$1;
    function nameParse(str) {
    	if (!names$1) {
    		names$1 = unpack();
    		names$1.transparent = [0, 0, 0, 0];
    	}
    	const a = names$1[str.toLowerCase()];
    	return a && {
    		r: a[0],
    		g: a[1],
    		b: a[2],
    		a: a.length === 4 ? a[3] : 255
    	};
    }
    function modHSL(v, i, ratio) {
    	if (v) {
    		let tmp = rgb2hsl(v);
    		tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    		tmp = hsl2rgb(tmp);
    		v.r = tmp[0];
    		v.g = tmp[1];
    		v.b = tmp[2];
    	}
    }
    function clone(v, proto) {
    	return v ? Object.assign(proto || {}, v) : v;
    }
    function fromObject(input) {
    	var v = {r: 0, g: 0, b: 0, a: 255};
    	if (Array.isArray(input)) {
    		if (input.length >= 3) {
    			v = {r: input[0], g: input[1], b: input[2], a: 255};
    			if (input.length > 3) {
    				v.a = n2b(input[3]);
    			}
    		}
    	} else {
    		v = clone(input, {r: 0, g: 0, b: 0, a: 1});
    		v.a = n2b(v.a);
    	}
    	return v;
    }
    function functionParse(str) {
    	if (str.charAt(0) === 'r') {
    		return rgbParse(str);
    	}
    	return hueParse(str);
    }
    class Color {
    	constructor(input) {
    		if (input instanceof Color) {
    			return input;
    		}
    		const type = typeof input;
    		let v;
    		if (type === 'object') {
    			v = fromObject(input);
    		} else if (type === 'string') {
    			v = hexParse(input) || nameParse(input) || functionParse(input);
    		}
    		this._rgb = v;
    		this._valid = !!v;
    	}
    	get valid() {
    		return this._valid;
    	}
    	get rgb() {
    		var v = clone(this._rgb);
    		if (v) {
    			v.a = b2n(v.a);
    		}
    		return v;
    	}
    	set rgb(obj) {
    		this._rgb = fromObject(obj);
    	}
    	rgbString() {
    		return this._valid ? rgbString(this._rgb) : this._rgb;
    	}
    	hexString() {
    		return this._valid ? hexString(this._rgb) : this._rgb;
    	}
    	hslString() {
    		return this._valid ? hslString(this._rgb) : this._rgb;
    	}
    	mix(color, weight) {
    		const me = this;
    		if (color) {
    			const c1 = me.rgb;
    			const c2 = color.rgb;
    			let w2;
    			const p = weight === w2 ? 0.5 : weight;
    			const w = 2 * p - 1;
    			const a = c1.a - c2.a;
    			const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
    			w2 = 1 - w1;
    			c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
    			c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
    			c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
    			c1.a = p * c1.a + (1 - p) * c2.a;
    			me.rgb = c1;
    		}
    		return me;
    	}
    	clone() {
    		return new Color(this.rgb);
    	}
    	alpha(a) {
    		this._rgb.a = n2b(a);
    		return this;
    	}
    	clearer(ratio) {
    		const rgb = this._rgb;
    		rgb.a *= 1 - ratio;
    		return this;
    	}
    	greyscale() {
    		const rgb = this._rgb;
    		const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    		rgb.r = rgb.g = rgb.b = val;
    		return this;
    	}
    	opaquer(ratio) {
    		const rgb = this._rgb;
    		rgb.a *= 1 + ratio;
    		return this;
    	}
    	negate() {
    		const v = this._rgb;
    		v.r = 255 - v.r;
    		v.g = 255 - v.g;
    		v.b = 255 - v.b;
    		return this;
    	}
    	lighten(ratio) {
    		modHSL(this._rgb, 2, ratio);
    		return this;
    	}
    	darken(ratio) {
    		modHSL(this._rgb, 2, -ratio);
    		return this;
    	}
    	saturate(ratio) {
    		modHSL(this._rgb, 1, ratio);
    		return this;
    	}
    	desaturate(ratio) {
    		modHSL(this._rgb, 1, -ratio);
    		return this;
    	}
    	rotate(deg) {
    		rotate(this._rgb, deg);
    		return this;
    	}
    }
    function index_esm(input) {
    	return new Color(input);
    }

    const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
    function color(value) {
      return isPatternOrGradient(value) ? value : index_esm(value);
    }
    function getHoverColor(value) {
      return isPatternOrGradient(value)
        ? value
        : index_esm(value).saturate(0.5).darken(0.1).hexString();
    }

    const overrides = Object.create(null);
    const descriptors = Object.create(null);
    function getScope$1(node, key) {
      if (!key) {
        return node;
      }
      const keys = key.split('.');
      for (let i = 0, n = keys.length; i < n; ++i) {
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
      }
      return node;
    }
    function set(root, scope, values) {
      if (typeof scope === 'string') {
        return merge(getScope$1(root, scope), values);
      }
      return merge(getScope$1(root, ''), scope);
    }
    class Defaults {
      constructor(_descriptors) {
        this.animation = undefined;
        this.backgroundColor = 'rgba(0,0,0,0.1)';
        this.borderColor = 'rgba(0,0,0,0.1)';
        this.color = '#666';
        this.datasets = {};
        this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
          'mousemove',
          'mouseout',
          'click',
          'touchstart',
          'touchmove'
        ];
        this.font = {
          family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          size: 12,
          style: 'normal',
          lineHeight: 1.2,
          weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options) => getHoverColor(options.color);
        this.indexAxis = 'x';
        this.interaction = {
          mode: 'nearest',
          intersect: true
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.describe(_descriptors);
      }
      set(scope, values) {
        return set(this, scope, values);
      }
      get(scope) {
        return getScope$1(this, scope);
      }
      describe(scope, values) {
        return set(descriptors, scope, values);
      }
      override(scope, values) {
        return set(overrides, scope, values);
      }
      route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = '_' + name;
        Object.defineProperties(scopeObject, {
          [privateName]: {
            value: scopeObject[name],
            writable: true
          },
          [name]: {
            enumerable: true,
            get() {
              const local = this[privateName];
              const target = targetScopeObject[targetName];
              if (isObject(local)) {
                return Object.assign({}, target, local);
              }
              return valueOrDefault(local, target);
            },
            set(value) {
              this[privateName] = value;
            }
          }
        });
      }
    }
    var defaults = new Defaults({
      _scriptable: (name) => !name.startsWith('on'),
      _indexable: (name) => name !== 'events',
      hover: {
        _fallback: 'interaction'
      },
      interaction: {
        _scriptable: false,
        _indexable: false,
      }
    });

    function toFontString(font) {
      if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
        return null;
      }
      return (font.style ? font.style + ' ' : '')
    		+ (font.weight ? font.weight + ' ' : '')
    		+ font.size + 'px '
    		+ font.family;
    }
    function _measureText(ctx, data, gc, longest, string) {
      let textWidth = data[string];
      if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
      }
      if (textWidth > longest) {
        longest = textWidth;
      }
      return longest;
    }
    function _longestText(ctx, font, arrayOfThings, cache) {
      cache = cache || {};
      let data = cache.data = cache.data || {};
      let gc = cache.garbageCollect = cache.garbageCollect || [];
      if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
      }
      ctx.save();
      ctx.font = font;
      let longest = 0;
      const ilen = arrayOfThings.length;
      let i, j, jlen, thing, nestedThing;
      for (i = 0; i < ilen; i++) {
        thing = arrayOfThings[i];
        if (thing !== undefined && thing !== null && isArray(thing) !== true) {
          longest = _measureText(ctx, data, gc, longest, thing);
        } else if (isArray(thing)) {
          for (j = 0, jlen = thing.length; j < jlen; j++) {
            nestedThing = thing[j];
            if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
              longest = _measureText(ctx, data, gc, longest, nestedThing);
            }
          }
        }
      }
      ctx.restore();
      const gcLen = gc.length / 2;
      if (gcLen > arrayOfThings.length) {
        for (i = 0; i < gcLen; i++) {
          delete data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
      return longest;
    }
    function _alignPixel(chart, pixel, width) {
      const devicePixelRatio = chart.currentDevicePixelRatio;
      const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    }
    function clearCanvas(canvas, ctx) {
      ctx = ctx || canvas.getContext('2d');
      ctx.save();
      ctx.resetTransform();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    function drawPoint(ctx, options, x, y) {
      let type, xOffset, yOffset, size, cornerRadius;
      const style = options.pointStyle;
      const rotation = options.rotation;
      const radius = options.radius;
      let rad = (rotation || 0) * RAD_PER_DEG;
      if (style && typeof style === 'object') {
        type = style.toString();
        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rad);
          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
          ctx.restore();
          return;
        }
      }
      if (isNaN(radius) || radius <= 0) {
        return;
      }
      ctx.beginPath();
      switch (style) {
      default:
        ctx.arc(x, y, radius, 0, TAU);
        ctx.closePath();
        break;
      case 'triangle':
        ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case 'rectRounded':
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case 'rect':
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          ctx.rect(x - size, y - size, 2 * size, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case 'rectRot':
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + yOffset, y - xOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        ctx.closePath();
        break;
      case 'crossRot':
        rad += QUARTER_PI;
      case 'cross':
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.moveTo(x + yOffset, y - xOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        break;
      case 'star':
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.moveTo(x + yOffset, y - xOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        rad += QUARTER_PI;
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        ctx.moveTo(x + yOffset, y - xOffset);
        ctx.lineTo(x - yOffset, y + xOffset);
        break;
      case 'line':
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case 'dash':
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
        break;
      }
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    function _isPointInArea(point, area, margin) {
      margin = margin || 0.5;
      return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&
    		point.y > area.top - margin && point.y < area.bottom + margin);
    }
    function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
    }
    function unclipArea(ctx) {
      ctx.restore();
    }
    function _steppedLineTo(ctx, previous, target, flip, mode) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      if (mode === 'middle') {
        const midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
      } else if (mode === 'after' !== !!flip) {
        ctx.lineTo(previous.x, target.y);
      } else {
        ctx.lineTo(target.x, previous.y);
      }
      ctx.lineTo(target.x, target.y);
    }
    function _bezierCurveTo(ctx, previous, target, flip) {
      if (!previous) {
        return ctx.lineTo(target.x, target.y);
      }
      ctx.bezierCurveTo(
        flip ? previous.cp1x : previous.cp2x,
        flip ? previous.cp1y : previous.cp2y,
        flip ? target.cp2x : target.cp1x,
        flip ? target.cp2y : target.cp1y,
        target.x,
        target.y);
    }
    function renderText(ctx, text, x, y, font, opts = {}) {
      const lines = isArray(text) ? text : [text];
      const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
      let i, line;
      ctx.save();
      ctx.font = font.string;
      setRenderOpts(ctx, opts);
      for (i = 0; i < lines.length; ++i) {
        line = lines[i];
        if (stroke) {
          if (opts.strokeColor) {
            ctx.strokeStyle = opts.strokeColor;
          }
          if (!isNullOrUndef(opts.strokeWidth)) {
            ctx.lineWidth = opts.strokeWidth;
          }
          ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += font.lineHeight;
      }
      ctx.restore();
    }
    function setRenderOpts(ctx, opts) {
      if (opts.translation) {
        ctx.translate(opts.translation[0], opts.translation[1]);
      }
      if (!isNullOrUndef(opts.rotation)) {
        ctx.rotate(opts.rotation);
      }
      if (opts.color) {
        ctx.fillStyle = opts.color;
      }
      if (opts.textAlign) {
        ctx.textAlign = opts.textAlign;
      }
      if (opts.textBaseline) {
        ctx.textBaseline = opts.textBaseline;
      }
    }
    function decorateText(ctx, x, y, line, opts) {
      if (opts.strikethrough || opts.underline) {
        const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
      }
    }
    function addRoundedRectPath(ctx, rect) {
      const {x, y, w, h, radius} = rect;
      ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
      ctx.lineTo(x, y + h - radius.bottomLeft);
      ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
      ctx.lineTo(x + w - radius.bottomRight, y + h);
      ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
      ctx.lineTo(x + w, y + radius.topRight);
      ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
      ctx.lineTo(x + radius.topLeft, y);
    }

    const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
    const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
    function toLineHeight(value, size) {
      const matches = ('' + value).match(LINE_HEIGHT);
      if (!matches || matches[1] === 'normal') {
        return size * 1.2;
      }
      value = +matches[2];
      switch (matches[3]) {
      case 'px':
        return value;
      case '%':
        value /= 100;
        break;
      }
      return size * value;
    }
    const numberOrZero$1 = v => +v || 0;
    function _readValueToProps(value, props) {
      const ret = {};
      const objProps = isObject(props);
      const keys = objProps ? Object.keys(props) : props;
      const read = isObject(value)
        ? objProps
          ? prop => valueOrDefault(value[prop], value[props[prop]])
          : prop => value[prop]
        : () => value;
      for (const prop of keys) {
        ret[prop] = numberOrZero$1(read(prop));
      }
      return ret;
    }
    function toTRBL(value) {
      return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});
    }
    function toTRBLCorners(value) {
      return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
    }
    function toPadding(value) {
      const obj = toTRBL(value);
      obj.width = obj.left + obj.right;
      obj.height = obj.top + obj.bottom;
      return obj;
    }
    function toFont(options, fallback) {
      options = options || {};
      fallback = fallback || defaults.font;
      let size = valueOrDefault(options.size, fallback.size);
      if (typeof size === 'string') {
        size = parseInt(size, 10);
      }
      let style = valueOrDefault(options.style, fallback.style);
      if (style && !('' + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = '';
      }
      const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ''
      };
      font.string = toFontString(font);
      return font;
    }
    function resolve(inputs, context, index, info) {
      let cacheable = true;
      let i, ilen, value;
      for (i = 0, ilen = inputs.length; i < ilen; ++i) {
        value = inputs[i];
        if (value === undefined) {
          continue;
        }
        if (context !== undefined && typeof value === 'function') {
          value = value(context);
          cacheable = false;
        }
        if (index !== undefined && isArray(value)) {
          value = value[index % value.length];
          cacheable = false;
        }
        if (value !== undefined) {
          if (info && !cacheable) {
            info.cacheable = false;
          }
          return value;
        }
      }
    }
    function _addGrace(minmax, grace, beginAtZero) {
      const {min, max} = minmax;
      const change = toDimension(grace, (max - min) / 2);
      const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
      return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
      };
    }
    function createContext(parentContext, context) {
      return Object.assign(Object.create(parentContext), context);
    }

    function _lookup(table, value, cmp) {
      cmp = cmp || ((index) => table[index] < value);
      let hi = table.length - 1;
      let lo = 0;
      let mid;
      while (hi - lo > 1) {
        mid = (lo + hi) >> 1;
        if (cmp(mid)) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
      return {lo, hi};
    }
    const _lookupByKey = (table, key, value) =>
      _lookup(table, value, index => table[index][key] < value);
    const _rlookupByKey = (table, key, value) =>
      _lookup(table, value, index => table[index][key] >= value);
    function _filterBetween(values, min, max) {
      let start = 0;
      let end = values.length;
      while (start < end && values[start] < min) {
        start++;
      }
      while (end > start && values[end - 1] > max) {
        end--;
      }
      return start > 0 || end < values.length
        ? values.slice(start, end)
        : values;
    }
    const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
      }
      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach((key) => {
        const method = '_onData' + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value(...args) {
            const res = base.apply(this, args);
            array._chartjs.listeners.forEach((object) => {
              if (typeof object[method] === 'function') {
                object[method](...args);
              }
            });
            return res;
          }
        });
      });
    }
    function unlistenArrayEvents(array, listener) {
      const stub = array._chartjs;
      if (!stub) {
        return;
      }
      const listeners = stub.listeners;
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
      if (listeners.length > 0) {
        return;
      }
      arrayEvents.forEach((key) => {
        delete array[key];
      });
      delete array._chartjs;
    }
    function _arrayUnique(items) {
      const set = new Set();
      let i, ilen;
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        set.add(items[i]);
      }
      if (set.size === ilen) {
        return items;
      }
      return Array.from(set);
    }

    function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
      if (!defined(fallback)) {
        fallback = _resolve('_fallback', scopes);
      }
      const cache = {
        [Symbol.toStringTag]: 'Object',
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: rootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),
      };
      return new Proxy(cache, {
        deleteProperty(target, prop) {
          delete target[prop];
          delete target._keys;
          delete scopes[0][prop];
          return true;
        },
        get(target, prop) {
          return _cached(target, prop,
            () => _resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        getOwnPropertyDescriptor(target, prop) {
          return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        getPrototypeOf() {
          return Reflect.getPrototypeOf(scopes[0]);
        },
        has(target, prop) {
          return getKeysFromAllScopes(target).includes(prop);
        },
        ownKeys(target) {
          return getKeysFromAllScopes(target);
        },
        set(target, prop, value) {
          const storage = target._storage || (target._storage = getTarget());
          storage[prop] = value;
          delete target[prop];
          delete target._keys;
          return true;
        }
      });
    }
    function _attachContext(proxy, context, subProxy, descriptorDefaults) {
      const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
      };
      return new Proxy(cache, {
        deleteProperty(target, prop) {
          delete target[prop];
          delete proxy[prop];
          return true;
        },
        get(target, prop, receiver) {
          return _cached(target, prop,
            () => _resolveWithContext(target, prop, receiver));
        },
        getOwnPropertyDescriptor(target, prop) {
          return target._descriptors.allKeys
            ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined
            : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        getPrototypeOf() {
          return Reflect.getPrototypeOf(proxy);
        },
        has(target, prop) {
          return Reflect.has(proxy, prop);
        },
        ownKeys() {
          return Reflect.ownKeys(proxy);
        },
        set(target, prop, value) {
          proxy[prop] = value;
          delete target[prop];
          return true;
        }
      });
    }
    function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {
      const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
      return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
      };
    }
    const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
    const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters';
    function _cached(target, prop, resolve) {
      if (Object.prototype.hasOwnProperty.call(target, prop)) {
        return target[prop];
      }
      const value = resolve();
      target[prop] = value;
      return value;
    }
    function _resolveWithContext(target, prop, receiver) {
      const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
      let value = _proxy[prop];
      if (isFunction(value) && descriptors.isScriptable(prop)) {
        value = _resolveScriptable(prop, value, target, receiver);
      }
      if (isArray(value) && value.length) {
        value = _resolveArray(prop, value, target, descriptors.isIndexable);
      }
      if (needsSubResolver(prop, value)) {
        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
      }
      return value;
    }
    function _resolveScriptable(prop, value, target, receiver) {
      const {_proxy, _context, _subProxy, _stack} = target;
      if (_stack.has(prop)) {
        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
      }
      _stack.add(prop);
      value = value(_context, _subProxy || receiver);
      _stack.delete(prop);
      if (isObject(value)) {
        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
      }
      return value;
    }
    function _resolveArray(prop, value, target, isIndexable) {
      const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
      if (defined(_context.index) && isIndexable(prop)) {
        value = value[_context.index % value.length];
      } else if (isObject(value[0])) {
        const arr = value;
        const scopes = _proxy._scopes.filter(s => s !== arr);
        value = [];
        for (const item of arr) {
          const resolver = createSubResolver(scopes, _proxy, prop, item);
          value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
        }
      }
      return value;
    }
    function resolveFallback(fallback, prop, value) {
      return isFunction(fallback) ? fallback(prop, value) : fallback;
    }
    const getScope = (key, parent) => key === true ? parent
      : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
    function addScopes(set, parentScopes, key, parentFallback) {
      for (const parent of parentScopes) {
        const scope = getScope(key, parent);
        if (scope) {
          set.add(scope);
          const fallback = resolveFallback(scope._fallback, key, scope);
          if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
            return fallback;
          }
        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
          return null;
        }
      }
      return false;
    }
    function createSubResolver(parentScopes, resolver, prop, value) {
      const rootScopes = resolver._rootScopes;
      const fallback = resolveFallback(resolver._fallback, prop, value);
      const allScopes = [...parentScopes, ...rootScopes];
      const set = new Set();
      set.add(value);
      let key = addScopesFromKey(set, allScopes, prop, fallback || prop);
      if (key === null) {
        return false;
      }
      if (defined(fallback) && fallback !== prop) {
        key = addScopesFromKey(set, allScopes, fallback, key);
        if (key === null) {
          return false;
        }
      }
      return _createResolver(Array.from(set), [''], rootScopes, fallback,
        () => subGetTarget(resolver, prop, value));
    }
    function addScopesFromKey(set, allScopes, key, fallback) {
      while (key) {
        key = addScopes(set, allScopes, key, fallback);
      }
      return key;
    }
    function subGetTarget(resolver, prop, value) {
      const parent = resolver._getTarget();
      if (!(prop in parent)) {
        parent[prop] = {};
      }
      const target = parent[prop];
      if (isArray(target) && isObject(value)) {
        return value;
      }
      return target;
    }
    function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
      let value;
      for (const prefix of prefixes) {
        value = _resolve(readKey(prefix, prop), scopes);
        if (defined(value)) {
          return needsSubResolver(prop, value)
            ? createSubResolver(scopes, proxy, prop, value)
            : value;
        }
      }
    }
    function _resolve(key, scopes) {
      for (const scope of scopes) {
        if (!scope) {
          continue;
        }
        const value = scope[key];
        if (defined(value)) {
          return value;
        }
      }
    }
    function getKeysFromAllScopes(target) {
      let keys = target._keys;
      if (!keys) {
        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
      }
      return keys;
    }
    function resolveKeysFromAllScopes(scopes) {
      const set = new Set();
      for (const scope of scopes) {
        for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
          set.add(key);
        }
      }
      return Array.from(set);
    }

    const EPSILON = Number.EPSILON || 1e-14;
    const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
    const getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';
    function splineCurve(firstPoint, middlePoint, afterPoint, t) {
      const previous = firstPoint.skip ? middlePoint : firstPoint;
      const current = middlePoint;
      const next = afterPoint.skip ? middlePoint : afterPoint;
      const d01 = distanceBetweenPoints(current, previous);
      const d12 = distanceBetweenPoints(next, current);
      let s01 = d01 / (d01 + d12);
      let s12 = d12 / (d01 + d12);
      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      const fa = t * s01;
      const fb = t * s12;
      return {
        previous: {
          x: current.x - fa * (next.x - previous.x),
          y: current.y - fa * (next.y - previous.y)
        },
        next: {
          x: current.x + fb * (next.x - previous.x),
          y: current.y + fb * (next.y - previous.y)
        }
      };
    }
    function monotoneAdjust(points, deltaK, mK) {
      const pointsLen = points.length;
      let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i = 0; i < pointsLen - 1; ++i) {
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) {
          continue;
        }
        if (almostEquals(deltaK[i], 0, EPSILON)) {
          mK[i] = mK[i + 1] = 0;
          continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
          continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
      }
    }
    function monotoneCompute(points, mK, indexAxis = 'x') {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      let delta, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (let i = 0; i < pointsLen; ++i) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
          continue;
        }
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
          delta = (iPixel - pointBefore[indexAxis]) / 3;
          pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
          pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
          delta = (pointAfter[indexAxis] - iPixel) / 3;
          pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
          pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
      }
    }
    function splineCurveMonotone(points, indexAxis = 'x') {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      const deltaK = Array(pointsLen).fill(0);
      const mK = Array(pointsLen);
      let i, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for (i = 0; i < pointsLen; ++i) {
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) {
          continue;
        }
        if (pointAfter) {
          const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
          deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i]
          : !pointAfter ? deltaK[i - 1]
          : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0
          : (deltaK[i - 1] + deltaK[i]) / 2;
      }
      monotoneAdjust(points, deltaK, mK);
      monotoneCompute(points, mK, indexAxis);
    }
    function capControlPoint(pt, min, max) {
      return Math.max(Math.min(pt, max), min);
    }
    function capBezierPoints(points, area) {
      let i, ilen, point, inArea, inAreaPrev;
      let inAreaNext = _isPointInArea(points[0], area);
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) {
          continue;
        }
        point = points[i];
        if (inAreaPrev) {
          point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
          point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
          point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
          point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
      }
    }
    function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
      let i, ilen, point, controlPoints;
      if (options.spanGaps) {
        points = points.filter((pt) => !pt.skip);
      }
      if (options.cubicInterpolationMode === 'monotone') {
        splineCurveMonotone(points, indexAxis);
      } else {
        let prev = loop ? points[points.length - 1] : points[0];
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          point = points[i];
          controlPoints = splineCurve(
            prev,
            point,
            points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
            options.tension
          );
          point.cp1x = controlPoints.previous.x;
          point.cp1y = controlPoints.previous.y;
          point.cp2x = controlPoints.next.x;
          point.cp2y = controlPoints.next.y;
          prev = point;
        }
      }
      if (options.capBezierPoints) {
        capBezierPoints(points, area);
      }
    }

    function _isDomSupported() {
      return typeof window !== 'undefined' && typeof document !== 'undefined';
    }
    function _getParentNode(domNode) {
      let parent = domNode.parentNode;
      if (parent && parent.toString() === '[object ShadowRoot]') {
        parent = parent.host;
      }
      return parent;
    }
    function parseMaxStyle(styleValue, node, parentProperty) {
      let valueInPixels;
      if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf('%') !== -1) {
          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
      } else {
        valueInPixels = styleValue;
      }
      return valueInPixels;
    }
    const getComputedStyle$1 = (element) => window.getComputedStyle(element, null);
    function getStyle(el, property) {
      return getComputedStyle$1(el).getPropertyValue(property);
    }
    const positions = ['top', 'right', 'bottom', 'left'];
    function getPositionedStyle(styles, style, suffix) {
      const result = {};
      suffix = suffix ? '-' + suffix : '';
      for (let i = 0; i < 4; i++) {
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
      }
      result.width = result.left + result.right;
      result.height = result.top + result.bottom;
      return result;
    }
    const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
    function getCanvasPosition(evt, canvas) {
      const e = evt.native || evt;
      const touches = e.touches;
      const source = touches && touches.length ? touches[0] : e;
      const {offsetX, offsetY} = source;
      let box = false;
      let x, y;
      if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
      } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
      }
      return {x, y, box};
    }
    function getRelativePosition$1(evt, chart) {
      const {canvas, currentDevicePixelRatio} = chart;
      const style = getComputedStyle$1(canvas);
      const borderBox = style.boxSizing === 'border-box';
      const paddings = getPositionedStyle(style, 'padding');
      const borders = getPositionedStyle(style, 'border', 'width');
      const {x, y, box} = getCanvasPosition(evt, canvas);
      const xOffset = paddings.left + (box && borders.left);
      const yOffset = paddings.top + (box && borders.top);
      let {width, height} = chart;
      if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
      };
    }
    function getContainerSize(canvas, width, height) {
      let maxWidth, maxHeight;
      if (width === undefined || height === undefined) {
        const container = _getParentNode(canvas);
        if (!container) {
          width = canvas.clientWidth;
          height = canvas.clientHeight;
        } else {
          const rect = container.getBoundingClientRect();
          const containerStyle = getComputedStyle$1(container);
          const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
          const containerPadding = getPositionedStyle(containerStyle, 'padding');
          width = rect.width - containerPadding.width - containerBorder.width;
          height = rect.height - containerPadding.height - containerBorder.height;
          maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
          maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
        }
      }
      return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
      };
    }
    const round1 = v => Math.round(v * 10) / 10;
    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
      const style = getComputedStyle$1(canvas);
      const margins = getPositionedStyle(style, 'margin');
      const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
      const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
      const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
      let {width, height} = containerSize;
      if (style.boxSizing === 'content-box') {
        const borders = getPositionedStyle(style, 'border', 'width');
        const paddings = getPositionedStyle(style, 'padding');
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
      }
      width = Math.max(0, width - margins.width);
      height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
      width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
      height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
      if (width && !height) {
        height = round1(width / 2);
      }
      return {
        width,
        height
      };
    }
    function retinaScale(chart, forceRatio, forceStyle) {
      const pixelRatio = forceRatio || 1;
      const deviceHeight = Math.floor(chart.height * pixelRatio);
      const deviceWidth = Math.floor(chart.width * pixelRatio);
      chart.height = deviceHeight / pixelRatio;
      chart.width = deviceWidth / pixelRatio;
      const canvas = chart.canvas;
      if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
      }
      if (chart.currentDevicePixelRatio !== pixelRatio
          || canvas.height !== deviceHeight
          || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
      }
      return false;
    }
    const supportsEventListenerOptions = (function() {
      let passiveSupported = false;
      try {
        const options = {
          get passive() {
            passiveSupported = true;
            return false;
          }
        };
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
      } catch (e) {
      }
      return passiveSupported;
    }());
    function readUsedSize(element, property) {
      const value = getStyle(element, property);
      const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? +matches[1] : undefined;
    }

    function _pointInLine(p1, p2, t, mode) {
      return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
      };
    }
    function _steppedInterpolation(p1, p2, t, mode) {
      return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y
        : mode === 'after' ? t < 1 ? p1.y : p2.y
        : t > 0 ? p2.y : p1.y
      };
    }
    function _bezierInterpolation(p1, p2, t, mode) {
      const cp1 = {x: p1.cp2x, y: p1.cp2y};
      const cp2 = {x: p2.cp1x, y: p2.cp1y};
      const a = _pointInLine(p1, cp1, t);
      const b = _pointInLine(cp1, cp2, t);
      const c = _pointInLine(cp2, p2, t);
      const d = _pointInLine(a, b, t);
      const e = _pointInLine(b, c, t);
      return _pointInLine(d, e, t);
    }

    const intlCache = new Map();
    function getNumberFormat(locale, options) {
      options = options || {};
      const cacheKey = locale + JSON.stringify(options);
      let formatter = intlCache.get(cacheKey);
      if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
      }
      return formatter;
    }
    function formatNumber(num, locale, options) {
      return getNumberFormat(locale, options).format(num);
    }

    const getRightToLeftAdapter = function(rectX, width) {
      return {
        x(x) {
          return rectX + rectX + width - x;
        },
        setWidth(w) {
          width = w;
        },
        textAlign(align) {
          if (align === 'center') {
            return align;
          }
          return align === 'right' ? 'left' : 'right';
        },
        xPlus(x, value) {
          return x - value;
        },
        leftForLtr(x, itemWidth) {
          return x - itemWidth;
        },
      };
    };
    const getLeftToRightAdapter = function() {
      return {
        x(x) {
          return x;
        },
        setWidth(w) {
        },
        textAlign(align) {
          return align;
        },
        xPlus(x, value) {
          return x + value;
        },
        leftForLtr(x, _itemWidth) {
          return x;
        },
      };
    };
    function getRtlAdapter(rtl, rectX, width) {
      return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
    }
    function overrideTextDirection(ctx, direction) {
      let style, original;
      if (direction === 'ltr' || direction === 'rtl') {
        style = ctx.canvas.style;
        original = [
          style.getPropertyValue('direction'),
          style.getPropertyPriority('direction'),
        ];
        style.setProperty('direction', direction, 'important');
        ctx.prevTextDirection = original;
      }
    }
    function restoreTextDirection(ctx, original) {
      if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty('direction', original[0], original[1]);
      }
    }

    function propertyFn(property) {
      if (property === 'angle') {
        return {
          between: _angleBetween,
          compare: _angleDiff,
          normalize: _normalizeAngle,
        };
      }
      return {
        between: (n, s, e) => n >= Math.min(s, e) && n <= Math.max(e, s),
        compare: (a, b) => a - b,
        normalize: x => x
      };
    }
    function normalizeSegment({start, end, count, loop, style}) {
      return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
      };
    }
    function getSegment(segment, points, bounds) {
      const {property, start: startBound, end: endBound} = bounds;
      const {between, normalize} = propertyFn(property);
      const count = points.length;
      let {start, end, loop} = segment;
      let i, ilen;
      if (loop) {
        start += count;
        end += count;
        for (i = 0, ilen = count; i < ilen; ++i) {
          if (!between(normalize(points[start % count][property]), startBound, endBound)) {
            break;
          }
          start--;
          end--;
        }
        start %= count;
        end %= count;
      }
      if (end < start) {
        end += count;
      }
      return {start, end, loop, style: segment.style};
    }
    function _boundSegment(segment, points, bounds) {
      if (!bounds) {
        return [segment];
      }
      const {property, start: startBound, end: endBound} = bounds;
      const count = points.length;
      const {compare, between, normalize} = propertyFn(property);
      const {start, end, loop, style} = getSegment(segment, points, bounds);
      const result = [];
      let inside = false;
      let subStart = null;
      let value, point, prevValue;
      const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
      const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
      const shouldStart = () => inside || startIsBefore();
      const shouldStop = () => !inside || endIsBefore();
      for (let i = start, prev = start; i <= end; ++i) {
        point = points[i % count];
        if (point.skip) {
          continue;
        }
        value = normalize(point[property]);
        if (value === prevValue) {
          continue;
        }
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) {
          subStart = compare(value, startBound) === 0 ? i : prev;
        }
        if (subStart !== null && shouldStop()) {
          result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));
          subStart = null;
        }
        prev = i;
        prevValue = value;
      }
      if (subStart !== null) {
        result.push(normalizeSegment({start: subStart, end, loop, count, style}));
      }
      return result;
    }
    function _boundSegments(line, bounds) {
      const result = [];
      const segments = line.segments;
      for (let i = 0; i < segments.length; i++) {
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) {
          result.push(...sub);
        }
      }
      return result;
    }
    function findStartAndEnd(points, count, loop, spanGaps) {
      let start = 0;
      let end = count - 1;
      if (loop && !spanGaps) {
        while (start < count && !points[start].skip) {
          start++;
        }
      }
      while (start < count && points[start].skip) {
        start++;
      }
      start %= count;
      if (loop) {
        end += start;
      }
      while (end > start && points[end % count].skip) {
        end--;
      }
      end %= count;
      return {start, end};
    }
    function solidSegments(points, start, max, loop) {
      const count = points.length;
      const result = [];
      let last = start;
      let prev = points[start];
      let end;
      for (end = start + 1; end <= max; ++end) {
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
          if (!prev.skip) {
            loop = false;
            result.push({start: start % count, end: (end - 1) % count, loop});
            start = last = cur.stop ? end : null;
          }
        } else {
          last = end;
          if (prev.skip) {
            start = end;
          }
        }
        prev = cur;
      }
      if (last !== null) {
        result.push({start: start % count, end: last % count, loop});
      }
      return result;
    }
    function _computeSegments(line, segmentOptions) {
      const points = line.points;
      const spanGaps = line.options.spanGaps;
      const count = points.length;
      if (!count) {
        return [];
      }
      const loop = !!line._loop;
      const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
      if (spanGaps === true) {
        return splitByStyles(line, [{start, end, loop}], points, segmentOptions);
      }
      const max = end < start ? end + count : end;
      const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
      return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
    }
    function splitByStyles(line, segments, points, segmentOptions) {
      if (!segmentOptions || !segmentOptions.setContext || !points) {
        return segments;
      }
      return doSplitByStyles(line, segments, points, segmentOptions);
    }
    function doSplitByStyles(line, segments, points, segmentOptions) {
      const chartContext = line._chart.getContext();
      const baseStyle = readStyle(line.options);
      const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
      const count = points.length;
      const result = [];
      let prevStyle = baseStyle;
      let start = segments[0].start;
      let i = start;
      function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) {
          return;
        }
        s += count;
        while (points[s % count].skip) {
          s -= dir;
        }
        while (points[e % count].skip) {
          e += dir;
        }
        if (s % count !== e % count) {
          result.push({start: s % count, end: e % count, loop: l, style: st});
          prevStyle = st;
          start = e % count;
        }
      }
      for (const segment of segments) {
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for (i = start + 1; i <= segment.end; i++) {
          const pt = points[i % count];
          style = readStyle(segmentOptions.setContext(createContext(chartContext, {
            type: 'segment',
            p0: prev,
            p1: pt,
            p0DataIndex: (i - 1) % count,
            p1DataIndex: i % count,
            datasetIndex
          })));
          if (styleChanged(style, prevStyle)) {
            addStyle(start, i - 1, segment.loop, prevStyle);
          }
          prev = pt;
          prevStyle = style;
        }
        if (start < i - 1) {
          addStyle(start, i - 1, segment.loop, prevStyle);
        }
      }
      return result;
    }
    function readStyle(options) {
      return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
      };
    }
    function styleChanged(style, prevStyle) {
      return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
    }

    /*!
     * Chart.js v3.6.0
     * https://www.chartjs.org
     * (c) 2021 Chart.js Contributors
     * Released under the MIT License
     */

    class Animator {
      constructor() {
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
      }
      _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach(fn => fn({
          chart,
          initial: anims.initial,
          numSteps,
          currentStep: Math.min(date - anims.start, numSteps)
        }));
      }
      _refresh() {
        if (this._request) {
          return;
        }
        this._running = true;
        this._request = requestAnimFrame.call(window, () => {
          this._update();
          this._request = null;
          if (this._running) {
            this._refresh();
          }
        });
      }
      _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart) => {
          if (!anims.running || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          let draw = false;
          let item;
          for (; i >= 0; --i) {
            item = items[i];
            if (item._active) {
              if (item._total > anims.duration) {
                anims.duration = item._total;
              }
              item.tick(date);
              draw = true;
            } else {
              items[i] = items[items.length - 1];
              items.pop();
            }
          }
          if (draw) {
            chart.draw();
            this._notify(chart, anims, date, 'progress');
          }
          if (!items.length) {
            anims.running = false;
            this._notify(chart, anims, date, 'complete');
            anims.initial = false;
          }
          remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) {
          this._running = false;
        }
      }
      _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
          anims = {
            running: false,
            initial: true,
            items: [],
            listeners: {
              complete: [],
              progress: []
            }
          };
          charts.set(chart, anims);
        }
        return anims;
      }
      listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
      }
      add(chart, items) {
        if (!items || !items.length) {
          return;
        }
        this._getAnims(chart).items.push(...items);
      }
      has(chart) {
        return this._getAnims(chart).items.length > 0;
      }
      start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) {
          return;
        }
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
        this._refresh();
      }
      running(chart) {
        if (!this._running) {
          return false;
        }
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) {
          return false;
        }
        return true;
      }
      stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        for (; i >= 0; --i) {
          items[i].cancel();
        }
        anims.items = [];
        this._notify(chart, anims, Date.now(), 'complete');
      }
      remove(chart) {
        return this._charts.delete(chart);
      }
    }
    var animator = new Animator();

    const transparent = 'transparent';
    const interpolators = {
      boolean(from, to, factor) {
        return factor > 0.5 ? to : from;
      },
      color(from, to, factor) {
        const c0 = color(from || transparent);
        const c1 = c0.valid && color(to || transparent);
        return c1 && c1.valid
          ? c1.mix(c0, factor).hexString()
          : to;
      },
      number(from, to, factor) {
        return from + (to - from) * factor;
      }
    };
    class Animation {
      constructor(cfg, target, prop, to) {
        const currentValue = target[prop];
        to = resolve([cfg.to, to, currentValue, cfg.from]);
        const from = resolve([cfg.from, currentValue, to]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = effects[cfg.easing] || effects.linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
      }
      active() {
        return this._active;
      }
      update(cfg, to, date) {
        if (this._active) {
          this._notify(false);
          const currentValue = this._target[this._prop];
          const elapsed = date - this._start;
          const remain = this._duration - elapsed;
          this._start = date;
          this._duration = Math.floor(Math.max(remain, cfg.duration));
          this._total += elapsed;
          this._loop = !!cfg.loop;
          this._to = resolve([cfg.to, to, currentValue, cfg.from]);
          this._from = resolve([cfg.from, currentValue, to]);
        }
      }
      cancel() {
        if (this._active) {
          this.tick(Date.now());
          this._active = false;
          this._notify(false);
        }
      }
      tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop || (elapsed < duration));
        if (!this._active) {
          this._target[prop] = to;
          this._notify(true);
          return;
        }
        if (elapsed < 0) {
          this._target[prop] = from;
          return;
        }
        factor = (elapsed / duration) % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
      }
      wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej) => {
          promises.push({res, rej});
        });
      }
      _notify(resolved) {
        const method = resolved ? 'res' : 'rej';
        const promises = this._promises || [];
        for (let i = 0; i < promises.length; i++) {
          promises[i][method]();
        }
      }
    }

    const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
    const colors = ['color', 'borderColor', 'backgroundColor'];
    defaults.set('animation', {
      delay: undefined,
      duration: 1000,
      easing: 'easeOutQuart',
      fn: undefined,
      from: undefined,
      loop: undefined,
      to: undefined,
      type: undefined,
    });
    const animationOptions = Object.keys(defaults.animation);
    defaults.describe('animation', {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
    });
    defaults.set('animations', {
      colors: {
        type: 'color',
        properties: colors
      },
      numbers: {
        type: 'number',
        properties: numbers
      },
    });
    defaults.describe('animations', {
      _fallback: 'animation',
    });
    defaults.set('transitions', {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: 'transparent'
          },
          visible: {
            type: 'boolean',
            duration: 0
          },
        }
      },
      hide: {
        animations: {
          colors: {
            to: 'transparent'
          },
          visible: {
            type: 'boolean',
            easing: 'linear',
            fn: v => v | 0
          },
        }
      }
    });
    class Animations {
      constructor(chart, config) {
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
      }
      configure(config) {
        if (!isObject(config)) {
          return;
        }
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach(key => {
          const cfg = config[key];
          if (!isObject(cfg)) {
            return;
          }
          const resolved = {};
          for (const option of animationOptions) {
            resolved[option] = cfg[option];
          }
          (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
            if (prop === key || !animatedProps.has(prop)) {
              animatedProps.set(prop, resolved);
            }
          });
        });
      }
      _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) {
          return [];
        }
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) {
          awaitAll(target.options.$animations, newOptions).then(() => {
            target.options = newOptions;
          }, () => {
          });
        }
        return animations;
      }
      _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for (i = props.length - 1; i >= 0; --i) {
          const prop = props[i];
          if (prop.charAt(0) === '$') {
            continue;
          }
          if (prop === 'options') {
            animations.push(...this._animateOptions(target, values));
            continue;
          }
          const value = values[prop];
          let animation = running[prop];
          const cfg = animatedProps.get(prop);
          if (animation) {
            if (cfg && animation.active()) {
              animation.update(cfg, value, date);
              continue;
            } else {
              animation.cancel();
            }
          }
          if (!cfg || !cfg.duration) {
            target[prop] = value;
            continue;
          }
          running[prop] = animation = new Animation(cfg, target, prop, value);
          animations.push(animation);
        }
        return animations;
      }
      update(target, values) {
        if (this._properties.size === 0) {
          Object.assign(target, values);
          return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
          animator.add(this._chart, animations);
          return true;
        }
      }
    }
    function awaitAll(animations, properties) {
      const running = [];
      const keys = Object.keys(properties);
      for (let i = 0; i < keys.length; i++) {
        const anim = animations[keys[i]];
        if (anim && anim.active()) {
          running.push(anim.wait());
        }
      }
      return Promise.all(running);
    }
    function resolveTargetOptions(target, newOptions) {
      if (!newOptions) {
        return;
      }
      let options = target.options;
      if (!options) {
        target.options = newOptions;
        return;
      }
      if (options.$shared) {
        target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});
      }
      return options;
    }

    function scaleClip(scale, allowedOverflow) {
      const opts = scale && scale.options || {};
      const reverse = opts.reverse;
      const min = opts.min === undefined ? allowedOverflow : 0;
      const max = opts.max === undefined ? allowedOverflow : 0;
      return {
        start: reverse ? max : min,
        end: reverse ? min : max
      };
    }
    function defaultClip(xScale, yScale, allowedOverflow) {
      if (allowedOverflow === false) {
        return false;
      }
      const x = scaleClip(xScale, allowedOverflow);
      const y = scaleClip(yScale, allowedOverflow);
      return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
      };
    }
    function toClip(value) {
      let t, r, b, l;
      if (isObject(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
      } else {
        t = r = b = l = value;
      }
      return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
      };
    }
    function getSortedDatasetIndices(chart, filterVisible) {
      const keys = [];
      const metasets = chart._getSortedDatasetMetas(filterVisible);
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        keys.push(metasets[i].index);
      }
      return keys;
    }
    function applyStack(stack, value, dsIndex, options = {}) {
      const keys = stack.keys;
      const singleMode = options.mode === 'single';
      let i, ilen, datasetIndex, otherValue;
      if (value === null) {
        return;
      }
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
          if (options.all) {
            continue;
          }
          break;
        }
        otherValue = stack.values[datasetIndex];
        if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
          value += otherValue;
        }
      }
      return value;
    }
    function convertObjectDataToArray(data) {
      const keys = Object.keys(data);
      const adata = new Array(keys.length);
      let i, ilen, key;
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        adata[i] = {
          x: key,
          y: data[key]
        };
      }
      return adata;
    }
    function isStacked(scale, meta) {
      const stacked = scale && scale.options.stacked;
      return stacked || (stacked === undefined && meta.stack !== undefined);
    }
    function getStackKey(indexScale, valueScale, meta) {
      return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
    }
    function getUserBounds(scale) {
      const {min, max, minDefined, maxDefined} = scale.getUserBounds();
      return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
      };
    }
    function getOrCreateStack(stacks, stackKey, indexValue) {
      const subStack = stacks[stackKey] || (stacks[stackKey] = {});
      return subStack[indexValue] || (subStack[indexValue] = {});
    }
    function getLastIndexInStack(stack, vScale, positive, type) {
      for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
        const value = stack[meta.index];
        if ((positive && value > 0) || (!positive && value < 0)) {
          return meta.index;
        }
      }
      return null;
    }
    function updateStacks(controller, parsed) {
      const {chart, _cachedMeta: meta} = controller;
      const stacks = chart._stacks || (chart._stacks = {});
      const {iScale, vScale, index: datasetIndex} = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const key = getStackKey(iScale, vScale, meta);
      const ilen = parsed.length;
      let stack;
      for (let i = 0; i < ilen; ++i) {
        const item = parsed[i];
        const {[iAxis]: index, [vAxis]: value} = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      }
    }
    function getFirstScaleId(chart, axis) {
      const scales = chart.scales;
      return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
    }
    function createDatasetContext(parent, index) {
      return createContext(parent,
        {
          active: false,
          dataset: undefined,
          datasetIndex: index,
          index,
          mode: 'default',
          type: 'dataset'
        }
      );
    }
    function createDataContext(parent, index, element) {
      return createContext(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element,
        index,
        mode: 'default',
        type: 'data'
      });
    }
    function clearStacks(meta, items) {
      const datasetIndex = meta.controller.index;
      const axis = meta.vScale && meta.vScale.axis;
      if (!axis) {
        return;
      }
      items = items || meta._parsed;
      for (const parsed of items) {
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
          return;
        }
        delete stacks[axis][datasetIndex];
      }
    }
    const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';
    const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
    const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked
      && {keys: getSortedDatasetIndices(chart, true), values: null};
    class DatasetController {
      constructor(chart, datasetIndex) {
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
        this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.$context = undefined;
        this._syncList = [];
        this.initialize();
      }
      initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
      }
      updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) {
          clearStacks(this._cachedMeta);
        }
        this.index = datasetIndex;
      }
      linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;
        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
      }
      getDataset() {
        return this.chart.data.datasets[this.index];
      }
      getMeta() {
        return this.chart.getDatasetMeta(this.index);
      }
      getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
      }
      _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale
          ? meta.vScale
          : meta.iScale;
      }
      reset() {
        this._update('reset');
      }
      _destroy() {
        const meta = this._cachedMeta;
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
        if (meta._stacked) {
          clearStacks(meta);
        }
      }
      _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if (isObject(data)) {
          this._data = convertObjectDataToArray(data);
        } else if (_data !== data) {
          if (_data) {
            unlistenArrayEvents(_data, this);
            const meta = this._cachedMeta;
            clearStacks(meta);
            meta._parsed = [];
          }
          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, this);
          }
          this._syncList = [];
          this._data = data;
        }
      }
      addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) {
          meta.dataset = new this.datasetElementType();
        }
      }
      buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
          stackChanged = true;
          clearStacks(meta);
          meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) {
          updateStacks(this, meta._parsed);
        }
      }
      configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
      }
      parse(start, count) {
        const {_cachedMeta: meta, _data: data} = this;
        const {iScale, _stacked} = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
          meta._parsed = data;
          meta._sorted = true;
          parsed = data;
        } else {
          if (isArray(data[start])) {
            parsed = this.parseArrayData(meta, data, start, count);
          } else if (isObject(data[start])) {
            parsed = this.parseObjectData(meta, data, start, count);
          } else {
            parsed = this.parsePrimitiveData(meta, data, start, count);
          }
          const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
          for (i = 0; i < count; ++i) {
            meta._parsed[i + start] = cur = parsed[i];
            if (sorted) {
              if (isNotInOrderComparedToPrev()) {
                sorted = false;
              }
              prev = cur;
            }
          }
          meta._sorted = sorted;
        }
        if (_stacked) {
          updateStacks(this, parsed);
        }
      }
      parsePrimitiveData(meta, data, start, count) {
        const {iScale, vScale} = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          parsed[i] = {
            [iAxis]: singleScale || iScale.parse(labels[index], index),
            [vAxis]: vScale.parse(data[index], index)
          };
        }
        return parsed;
      }
      parseArrayData(meta, data, start, count) {
        const {xScale, yScale} = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          item = data[index];
          parsed[i] = {
            x: xScale.parse(item[0], index),
            y: yScale.parse(item[1], index)
          };
        }
        return parsed;
      }
      parseObjectData(meta, data, start, count) {
        const {xScale, yScale} = meta;
        const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
          index = i + start;
          item = data[index];
          parsed[i] = {
            x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
            y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
          };
        }
        return parsed;
      }
      getParsed(index) {
        return this._cachedMeta._parsed[index];
      }
      getDataElement(index) {
        return this._cachedMeta.data[index];
      }
      applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
          keys: getSortedDatasetIndices(chart, true),
          values: parsed._stacks[scale.axis]
        };
        return applyStack(stack, value, meta.index, {mode});
      }
      updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
          stack.values = values;
          value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
      }
      getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
        const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
          parsed = _parsed[i];
          const otherValue = parsed[otherScale.axis];
          return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for (i = 0; i < ilen; ++i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale, parsed, stack);
          if (sorted) {
            break;
          }
        }
        if (sorted) {
          for (i = ilen - 1; i >= 0; --i) {
            if (_skip()) {
              continue;
            }
            this.updateRangeFromParsed(range, scale, parsed, stack);
            break;
          }
        }
        return range;
      }
      getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for (i = 0, ilen = parsed.length; i < ilen; ++i) {
          value = parsed[i][scale.axis];
          if (isNumberFinite(value)) {
            values.push(value);
          }
        }
        return values;
      }
      getMaxOverflow() {
        return false;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
          label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
          value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
        };
      }
      _update(mode) {
        const meta = this._cachedMeta;
        this.configure();
        this._cachedDataOpts = {};
        this.update(mode || 'default');
        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
      }
      update(mode) {}
      draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || (elements.length - start);
        let i;
        if (meta.dataset) {
          meta.dataset.draw(ctx, area, start, count);
        }
        for (i = start; i < start + count; ++i) {
          const element = elements[i];
          if (element.hidden) {
            continue;
          }
          if (element.active) {
            active.push(element);
          } else {
            element.draw(ctx, area);
          }
        }
        for (i = 0; i < active.length; ++i) {
          active[i].draw(ctx, area);
        }
      }
      getStyle(index, active) {
        const mode = active ? 'active' : 'default';
        return index === undefined && this._cachedMeta.dataset
          ? this.resolveDatasetElementOptions(mode)
          : this.resolveDataElementOptions(index || 0, mode);
      }
      getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
          const element = this._cachedMeta.data[index];
          context = element.$context ||
            (element.$context = createDataContext(this.getContext(), index, element));
          context.parsed = this.getParsed(index);
          context.raw = dataset.data[index];
          context.index = context.dataIndex = index;
        } else {
          context = this.$context ||
            (this.$context = createDatasetContext(this.chart.getContext(), this.index));
          context.dataset = dataset;
          context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
      }
      resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
      }
      resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
      }
      _resolveElementOptions(elementType, mode = 'default', index) {
        const active = mode === 'active';
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + '-' + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && defined(index);
        if (cached) {
          return cloneIfNotShared(cached, sharing);
        }
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names = Object.keys(defaults.elements[elementType]);
        const context = () => this.getContext(index, active);
        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
        if (values.$shared) {
          values.$shared = sharing;
          cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
      }
      _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) {
          return cached;
        }
        let options;
        if (chart.options.animation !== false) {
          const config = this.chart.config;
          const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) {
          cache[cacheKey] = Object.freeze(animations);
        }
        return animations;
      }
      getSharedOptions(options) {
        if (!options.$shared) {
          return;
        }
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
      }
      includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
      }
      updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) {
          Object.assign(element, properties);
        } else {
          this._resolveAnimations(index, mode).update(element, properties);
        }
      }
      updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) {
          this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
        }
      }
      _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
          options: (!active && this.getSharedOptions(options)) || options
        });
      }
      removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', false);
      }
      setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, 'active', true);
      }
      _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
          this._setStyle(element, undefined, 'active', false);
        }
      }
      _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) {
          this._setStyle(element, undefined, 'active', true);
        }
      }
      _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList) {
          this[method](arg1, arg2);
        }
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) {
          this.parse(0, count);
        }
        if (numData > numMeta) {
          this._insertElements(numMeta, numData - numMeta, resetNewElements);
        } else if (numData < numMeta) {
          this._removeElements(numData, numMeta - numData);
        }
      }
      _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr) => {
          arr.length += count;
          for (i = arr.length - 1; i >= end; i--) {
            arr[i] = arr[i - count];
          }
        };
        move(data);
        for (i = start; i < end; ++i) {
          data[i] = new this.dataElementType();
        }
        if (this._parsing) {
          move(meta._parsed);
        }
        this.parse(start, count);
        if (resetNewElements) {
          this.updateElements(data, start, count, 'reset');
        }
      }
      updateElements(element, start, count, mode) {}
      _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
          const removed = meta._parsed.splice(start, count);
          if (meta._stacked) {
            clearStacks(meta, removed);
          }
        }
        meta.data.splice(start, count);
      }
      _sync(args) {
        if (this._parsing) {
          this._syncList.push(args);
        } else {
          const [method, arg1, arg2] = args;
          this[method](arg1, arg2);
        }
      }
      _onDataPush() {
        const count = arguments.length;
        this._sync(['_insertElements', this.getDataset().data.length - count, count]);
      }
      _onDataPop() {
        this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
      }
      _onDataShift() {
        this._sync(['_removeElements', 0, 1]);
      }
      _onDataSplice(start, count) {
        this._sync(['_removeElements', start, count]);
        this._sync(['_insertElements', start, arguments.length - 2]);
      }
      _onDataUnshift() {
        this._sync(['_insertElements', 0, arguments.length]);
      }
    }
    DatasetController.defaults = {};
    DatasetController.prototype.datasetElementType = null;
    DatasetController.prototype.dataElementType = null;

    function getAllScaleValues(scale, type) {
      if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
          values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        }
        scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
      }
      return scale._cache.$bar;
    }
    function computeMinSampleSize(meta) {
      const scale = meta.iScale;
      const values = getAllScaleValues(scale, meta.type);
      let min = scale._length;
      let i, ilen, curr, prev;
      const updateMinAndPrev = () => {
        if (curr === 32767 || curr === -32768) {
          return;
        }
        if (defined(prev)) {
          min = Math.min(min, Math.abs(curr - prev) || min);
        }
        prev = curr;
      };
      for (i = 0, ilen = values.length; i < ilen; ++i) {
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
      }
      prev = undefined;
      for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
      }
      return min;
    }
    function computeFitCategoryTraits(index, ruler, options, stackCount) {
      const thickness = options.barThickness;
      let size, ratio;
      if (isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        size = thickness * stackCount;
        ratio = 1;
      }
      return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - (size / 2)
      };
    }
    function computeFlexCategoryTraits(index, ruler, options, stackCount) {
      const pixels = ruler.pixels;
      const curr = pixels[index];
      let prev = index > 0 ? pixels[index - 1] : null;
      let next = index < pixels.length - 1 ? pixels[index + 1] : null;
      const percent = options.categoryPercentage;
      if (prev === null) {
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }
      if (next === null) {
        next = curr + curr - prev;
      }
      const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      const size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
      };
    }
    function parseFloatBar(entry, item, vScale, i) {
      const startValue = vScale.parse(entry[0], i);
      const endValue = vScale.parse(entry[1], i);
      const min = Math.min(startValue, endValue);
      const max = Math.max(startValue, endValue);
      let barStart = min;
      let barEnd = max;
      if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
      }
      item[vScale.axis] = barEnd;
      item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
      };
    }
    function parseValue(entry, item, vScale, i) {
      if (isArray(entry)) {
        parseFloatBar(entry, item, vScale, i);
      } else {
        item[vScale.axis] = vScale.parse(entry, i);
      }
      return item;
    }
    function parseArrayOrPrimitive(meta, data, start, count) {
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = [];
      let i, ilen, item, entry;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
      }
      return parsed;
    }
    function isFloatBar(custom) {
      return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
    }
    function barSign(size, vScale, actualBase) {
      if (size !== 0) {
        return sign(size);
      }
      return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
    }
    function borderProps(properties) {
      let reverse, start, end, top, bottom;
      if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = 'left';
        end = 'right';
      } else {
        reverse = properties.base < properties.y;
        start = 'bottom';
        end = 'top';
      }
      if (reverse) {
        top = 'end';
        bottom = 'start';
      } else {
        top = 'start';
        bottom = 'end';
      }
      return {start, end, reverse, top, bottom};
    }
    function setBorderSkipped(properties, options, stack, index) {
      let edge = options.borderSkipped;
      const res = {};
      if (!edge) {
        properties.borderSkipped = res;
        return;
      }
      const {start, end, reverse, top, bottom} = borderProps(properties);
      if (edge === 'middle' && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) {
          edge = top;
        } else if ((stack._bottom || 0) === index) {
          edge = bottom;
        } else {
          res[parseEdge(bottom, start, end, reverse)] = true;
          edge = top;
        }
      }
      res[parseEdge(edge, start, end, reverse)] = true;
      properties.borderSkipped = res;
    }
    function parseEdge(edge, a, b, reverse) {
      if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
      } else {
        edge = startEnd(edge, a, b);
      }
      return edge;
    }
    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }
    function startEnd(v, start, end) {
      return v === 'start' ? start : v === 'end' ? end : v;
    }
    function setInflateAmount(properties, {inflateAmount}, ratio) {
      properties.inflateAmount = inflateAmount === 'auto'
        ? ratio === 1 ? 0.33 : 0
        : inflateAmount;
    }
    class BarController extends DatasetController {
      parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
      }
      parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
      }
      parseObjectData(meta, data, start, count) {
        const {iScale, vScale} = meta;
        const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          obj = data[i];
          item = {};
          item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
          parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
      }
      updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
          range.min = Math.min(range.min, custom.min);
          range.max = Math.max(range.max, custom.max);
        }
      }
      getMaxOverflow() {
        return 0;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const {iScale, vScale} = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom)
          ? '[' + custom.start + ', ' + custom.end + ']'
          : '' + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
          label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
          value
        };
      }
      initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
      }
      update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
      }
      updateElements(bars, start, count, mode) {
        const reset = mode === 'reset';
        const {index, _cachedMeta: {vScale}} = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        for (let i = start; i < start + count; i++) {
          const parsed = this.getParsed(i);
          const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);
          const ipixels = this._calculateBarIndexPixels(i, ruler);
          const stack = (parsed._stacks || {})[vScale.axis];
          const properties = {
            horizontal,
            base: vpixels.base,
            enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
            x: horizontal ? vpixels.head : ipixels.center,
            y: horizontal ? ipixels.center : vpixels.head,
            height: horizontal ? ipixels.size : Math.abs(vpixels.size),
            width: horizontal ? Math.abs(vpixels.size) : ipixels.size
          };
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
          }
          const options = properties.options || bars[i].options;
          setBorderSkipped(properties, options, stack, index);
          setInflateAmount(properties, options, ruler.ratio);
          this.updateElement(bars[i], i, properties, mode);
        }
      }
      _getStacks(last, dataIndex) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const metasets = iScale.getMatchingVisibleMetas(this._type);
        const stacked = iScale.options.stacked;
        const ilen = metasets.length;
        const stacks = [];
        let i, item;
        for (i = 0; i < ilen; ++i) {
          item = metasets[i];
          if (!item.controller.options.grouped) {
            continue;
          }
          if (typeof dataIndex !== 'undefined') {
            const val = item.controller.getParsed(dataIndex)[
              item.controller._cachedMeta.vScale.axis
            ];
            if (isNullOrUndef(val) || isNaN(val)) {
              continue;
            }
          }
          if (stacked === false || stacks.indexOf(item.stack) === -1 ||
    				(stacked === undefined && item.stack === undefined)) {
            stacks.push(item.stack);
          }
          if (item.index === last) {
            break;
          }
        }
        if (!stacks.length) {
          stacks.push(undefined);
        }
        return stacks;
      }
      _getStackCount(index) {
        return this._getStacks(undefined, index).length;
      }
      _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = (name !== undefined)
          ? stacks.indexOf(name)
          : -1;
        return (index === -1)
          ? stacks.length - 1
          : index;
      }
      _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
          pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        }
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
          min,
          pixels,
          start: iScale._startPixel,
          end: iScale._endPixel,
          stackCount: this._getStackCount(),
          scale: iScale,
          grouped: opts.grouped,
          ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
      }
      _calculateBarValuePixels(index) {
        const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
          start = length - value;
          length = value;
        }
        if (floating) {
          value = custom.barStart;
          length = custom.barEnd - custom.barStart;
          if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
            start = 0;
          }
          start += value;
        }
        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) {
          head = vScale.getPixelForValue(start + length);
        } else {
          head = base;
        }
        size = head - base;
        if (Math.abs(size) < minBarLength) {
          size = barSign(size, vScale, actualBase) * minBarLength;
          if (value === actualBase) {
            base -= size / 2;
          }
          head = base + size;
        }
        if (base === vScale.getPixelForValue(actualBase)) {
          const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
          base += halfGrid;
          size -= halfGrid;
        }
        return {
          size,
          base,
          head,
          center: head + size / 2
        };
      }
      _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
        let center, size;
        if (ruler.grouped) {
          const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
          const range = options.barThickness === 'flex'
            ? computeFlexCategoryTraits(index, ruler, options, stackCount)
            : computeFitCategoryTraits(index, ruler, options, stackCount);
          const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
          center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
          size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
          center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
          size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
          base: center - size / 2,
          head: center + size / 2,
          center,
          size
        };
      }
      draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for (; i < ilen; ++i) {
          if (this.getParsed(i)[vScale.axis] !== null) {
            rects[i].draw(this._ctx);
          }
        }
      }
    }
    BarController.id = 'bar';
    BarController.defaults = {
      datasetElementType: false,
      dataElementType: 'bar',
      categoryPercentage: 0.8,
      barPercentage: 0.9,
      grouped: true,
      animations: {
        numbers: {
          type: 'number',
          properties: ['x', 'y', 'base', 'width', 'height']
        }
      }
    };
    BarController.overrides = {
      scales: {
        _index_: {
          type: 'category',
          offset: true,
          grid: {
            offset: true
          }
        },
        _value_: {
          type: 'linear',
          beginAtZero: true,
        }
      }
    };

    class BubbleController extends DatasetController {
      initialize() {
        this.enableOptionSharing = true;
        super.initialize();
      }
      parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for (let i = 0; i < parsed.length; i++) {
          parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        }
        return parsed;
      }
      parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for (let i = 0; i < parsed.length; i++) {
          const item = data[start + i];
          parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
      }
      parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for (let i = 0; i < parsed.length; i++) {
          const item = data[start + i];
          parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
      }
      getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const {xScale, yScale} = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
          label: meta.label,
          value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
        };
      }
      update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
      }
      updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const {iScale, vScale} = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for (let i = start; i < start + count; i++) {
          const point = points[i];
          const parsed = !reset && this.getParsed(i);
          const properties = {};
          const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
          const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
          properties.skip = isNaN(iPixel) || isNaN(vPixel);
          if (includeOptions) {
            properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
            if (reset) {
              properties.options.radius = 0;
            }
          }
          this.updateElement(point, i, properties, mode);
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
      resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) {
          values = Object.assign({}, values, {$shared: false});
        }
        const radius = values.radius;
        if (mode !== 'active') {
          values.radius = 0;
        }
        values.radius += valueOrDefault(parsed && parsed._custom, radius);
        return values;
      }
    }
    BubbleController.id = 'bubble';
    BubbleController.defaults = {
      datasetElementType: false,
      dataElementType: 'point',
      animations: {
        numbers: {
          type: 'number',
          properties: ['x', 'y', 'borderWidth', 'radius']
        }
      }
    };
    BubbleController.overrides = {
      scales: {
        x: {
          type: 'linear'
        },
        y: {
          type: 'linear'
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            title() {
              return '';
            }
          }
        }
      }
    };

    function getRatioAndOffset(rotation, circumference, cutout) {
      let ratioX = 1;
      let ratioY = 1;
      let offsetX = 0;
      let offsetY = 0;
      if (circumference < TAU) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax(HALF_PI, startY, endY);
        const minX = calcMin(PI, startX, endX);
        const minY = calcMin(PI + HALF_PI, startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
      }
      return {ratioX, ratioY, offsetX, offsetY};
    }
    class DoughnutController extends DatasetController {
      constructor(chart, datasetIndex) {
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.offsetX = undefined;
        this.offsetY = undefined;
      }
      linkScales() {}
      parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) {
          meta._parsed = data;
        } else {
          let getter = (i) => +data[i];
          if (isObject(data[start])) {
            const {key = 'value'} = this._parsing;
            getter = (i) => +resolveObjectKey(data[i], key);
          }
          let i, ilen;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            meta._parsed[i] = getter(i);
          }
        }
      }
      _getRotation() {
        return toRadians(this.options.rotation - 90);
      }
      _getCircumference() {
        return toRadians(this.options.circumference);
      }
      _getRotationExtents() {
        let min = TAU;
        let max = -TAU;
        for (let i = 0; i < this.chart.data.datasets.length; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            const controller = this.chart.getDatasetMeta(i).controller;
            const rotation = controller._getRotation();
            const circumference = controller._getCircumference();
            min = Math.min(min, rotation);
            max = Math.max(max, rotation + circumference);
          }
        }
        return {
          rotation: min,
          circumference: max - min,
        };
      }
      update(mode) {
        const chart = this.chart;
        const {chartArea} = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const {circumference, rotation} = this._getRotationExtents();
        const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = toDimension(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
      }
      _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
          return 0;
        }
        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
      }
      updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        let startAngle = this._getRotation();
        let i;
        for (i = 0; i < start; ++i) {
          startAngle += this._circumference(i, reset);
        }
        for (i = start; i < start + count; ++i) {
          const circumference = this._circumference(i, reset);
          const arc = arcs[i];
          const properties = {
            x: centerX + this.offsetX,
            y: centerY + this.offsetY,
            startAngle,
            endAngle: startAngle + circumference,
            circumference,
            outerRadius,
            innerRadius
          };
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
          }
          startAngle += circumference;
          this.updateElement(arc, i, properties, mode);
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
      calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for (i = 0; i < metaData.length; i++) {
          const value = meta._parsed[i];
          if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
            total += Math.abs(value);
          }
        }
        return total;
      }
      calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) {
          return TAU * (Math.abs(value) / total);
        }
        return 0;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index], chart.options.locale);
        return {
          label: labels[index] || '',
          value,
        };
      }
      getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;
              controller = meta.controller;
              if (controller !== this) {
                controller.configure();
              }
              break;
            }
          }
        }
        if (!arcs) {
          return 0;
        }
        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          options = controller.resolveDataElementOptions(i);
          if (options.borderAlign !== 'inner') {
            max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
          }
        }
        return max;
      }
      getMaxOffset(arcs) {
        let max = 0;
        for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
          const options = this.resolveDataElementOptions(i);
          max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
      }
      _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for (let i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }
        return ringWeightOffset;
      }
      _getRingWeight(datasetIndex) {
        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
      }
      _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
      }
    }
    DoughnutController.id = 'doughnut';
    DoughnutController.defaults = {
      datasetElementType: false,
      dataElementType: 'arc',
      animation: {
        animateRotate: true,
        animateScale: false
      },
      animations: {
        numbers: {
          type: 'number',
          properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
        },
      },
      cutout: '50%',
      rotation: 0,
      circumference: 360,
      radius: '100%',
      spacing: 0,
      indexAxis: 'r',
    };
    DoughnutController.descriptors = {
      _scriptable: (name) => name !== 'spacing',
      _indexable: (name) => name !== 'spacing',
    };
    DoughnutController.overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const {labels: {pointStyle}} = chart.legend.options;
                return data.labels.map((label, i) => {
                  const meta = chart.getDatasetMeta(0);
                  const style = meta.controller.getStyle(i);
                  return {
                    text: label,
                    fillStyle: style.backgroundColor,
                    strokeStyle: style.borderColor,
                    lineWidth: style.borderWidth,
                    pointStyle: pointStyle,
                    hidden: !chart.getDataVisibility(i),
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onClick(e, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        },
        tooltip: {
          callbacks: {
            title() {
              return '';
            },
            label(tooltipItem) {
              let dataLabel = tooltipItem.label;
              const value = ': ' + tooltipItem.formattedValue;
              if (isArray(dataLabel)) {
                dataLabel = dataLabel.slice();
                dataLabel[0] += value;
              } else {
                dataLabel += value;
              }
              return dataLabel;
            }
          }
        }
      }
    };

    class LineController extends DatasetController {
      initialize() {
        this.enableOptionSharing = true;
        super.initialize();
      }
      update(mode) {
        const meta = this._cachedMeta;
        const {dataset: line, data: points = [], _dataset} = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if (scaleRangesChanged(meta)) {
          start = 0;
          count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        options.segment = this.options.segment;
        this.updateElement(line, undefined, {
          animated: !animationsDisabled,
          options
        }, mode);
        this.updateElements(points, start, count, mode);
      }
      updateElements(points, start, count, mode) {
        const reset = mode === 'reset';
        const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const {spanGaps, segment} = this.options;
        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for (let i = start; i < start + count; ++i) {
          const point = points[i];
          const parsed = this.getParsed(i);
          const properties = directUpdate ? point : {};
          const nullData = isNullOrUndef(parsed[vAxis]);
          const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
          const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
          properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
          properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
          if (segment) {
            properties.parsed = parsed;
            properties.raw = _dataset.data[i];
          }
          if (includeOptions) {
            properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
          }
          if (!directUpdate) {
            this.updateElement(point, i, properties, mode);
          }
          prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
      getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) {
          return border;
        }
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
      }
      draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
      }
    }
    LineController.id = 'line';
    LineController.defaults = {
      datasetElementType: 'line',
      dataElementType: 'point',
      showLine: true,
      spanGaps: false,
    };
    LineController.overrides = {
      scales: {
        _index_: {
          type: 'category',
        },
        _value_: {
          type: 'linear',
        },
      }
    };
    function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
      const pointCount = points.length;
      let start = 0;
      let count = pointCount;
      if (meta._sorted) {
        const {iScale, _parsed} = meta;
        const axis = iScale.axis;
        const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
        if (minDefined) {
          start = _limitValue(Math.min(
            _lookupByKey(_parsed, iScale.axis, min).lo,
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),
          0, pointCount - 1);
        }
        if (maxDefined) {
          count = _limitValue(Math.max(
            _lookupByKey(_parsed, iScale.axis, max).hi + 1,
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),
          start, pointCount) - start;
        } else {
          count = pointCount - start;
        }
      }
      return {start, count};
    }
    function scaleRangesChanged(meta) {
      const {xScale, yScale, _scaleRanges} = meta;
      const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
      };
      if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
      }
      const changed = _scaleRanges.xmin !== xScale.min
    		|| _scaleRanges.xmax !== xScale.max
    		|| _scaleRanges.ymin !== yScale.min
    		|| _scaleRanges.ymax !== yScale.max;
      Object.assign(_scaleRanges, newRanges);
      return changed;
    }

    class PolarAreaController extends DatasetController {
      constructor(chart, datasetIndex) {
        super(chart, datasetIndex);
        this.innerRadius = undefined;
        this.outerRadius = undefined;
      }
      getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = formatNumber(meta._parsed[index].r, chart.options.locale);
        return {
          label: labels[index] || '',
          value,
        };
      }
      update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
      }
      _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - (radiusLength * this.index);
        this.innerRadius = this.outerRadius - radiusLength;
      }
      updateElements(arcs, start, count, mode) {
        const reset = mode === 'reset';
        const chart = this.chart;
        const dataset = this.getDataset();
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for (i = 0; i < start; ++i) {
          angle += this._computeAngle(i, mode, defaultAngle);
        }
        for (i = start; i < start + count; i++) {
          const arc = arcs[i];
          let startAngle = angle;
          let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
          let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
          angle = endAngle;
          if (reset) {
            if (animationOpts.animateScale) {
              outerRadius = 0;
            }
            if (animationOpts.animateRotate) {
              startAngle = endAngle = datasetStartAngle;
            }
          }
          const properties = {
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius,
            startAngle,
            endAngle,
            options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
          };
          this.updateElement(arc, i, properties, mode);
        }
      }
      countVisibleElements() {
        const dataset = this.getDataset();
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element, index) => {
          if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
            count++;
          }
        });
        return count;
      }
      _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index)
          ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)
          : 0;
      }
    }
    PolarAreaController.id = 'polarArea';
    PolarAreaController.defaults = {
      dataElementType: 'arc',
      animation: {
        animateRotate: true,
        animateScale: true
      },
      animations: {
        numbers: {
          type: 'number',
          properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
        },
      },
      indexAxis: 'r',
      startAngle: 0,
    };
    PolarAreaController.overrides = {
      aspectRatio: 1,
      plugins: {
        legend: {
          labels: {
            generateLabels(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const {labels: {pointStyle}} = chart.legend.options;
                return data.labels.map((label, i) => {
                  const meta = chart.getDatasetMeta(0);
                  const style = meta.controller.getStyle(i);
                  return {
                    text: label,
                    fillStyle: style.backgroundColor,
                    strokeStyle: style.borderColor,
                    lineWidth: style.borderWidth,
                    pointStyle: pointStyle,
                    hidden: !chart.getDataVisibility(i),
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onClick(e, legendItem, legend) {
            legend.chart.toggleDataVisibility(legendItem.index);
            legend.chart.update();
          }
        },
        tooltip: {
          callbacks: {
            title() {
              return '';
            },
            label(context) {
              return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;
            }
          }
        }
      },
      scales: {
        r: {
          type: 'radialLinear',
          angleLines: {
            display: false
          },
          beginAtZero: true,
          grid: {
            circular: true
          },
          pointLabels: {
            display: false
          },
          startAngle: 0
        }
      }
    };

    class PieController extends DoughnutController {
    }
    PieController.id = 'pie';
    PieController.defaults = {
      cutout: 0,
      rotation: 0,
      circumference: 360,
      radius: '100%'
    };

    class RadarController extends DatasetController {
      getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
          label: vScale.getLabels()[index],
          value: '' + vScale.getLabelForValue(parsed[vScale.axis])
        };
      }
      update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== 'resize') {
          const options = this.resolveDatasetElementOptions(mode);
          if (!this.options.showLine) {
            options.borderWidth = 0;
          }
          const properties = {
            _loop: true,
            _fullLoop: labels.length === points.length,
            options
          };
          this.updateElement(line, undefined, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
      }
      updateElements(points, start, count, mode) {
        const dataset = this.getDataset();
        const scale = this._cachedMeta.rScale;
        const reset = mode === 'reset';
        for (let i = start; i < start + count; i++) {
          const point = points[i];
          const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
          const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
          const x = reset ? scale.xCenter : pointPosition.x;
          const y = reset ? scale.yCenter : pointPosition.y;
          const properties = {
            x,
            y,
            angle: pointPosition.angle,
            skip: isNaN(x) || isNaN(y),
            options
          };
          this.updateElement(point, i, properties, mode);
        }
      }
    }
    RadarController.id = 'radar';
    RadarController.defaults = {
      datasetElementType: 'line',
      dataElementType: 'point',
      indexAxis: 'r',
      showLine: true,
      elements: {
        line: {
          fill: 'start'
        }
      },
    };
    RadarController.overrides = {
      aspectRatio: 1,
      scales: {
        r: {
          type: 'radialLinear',
        }
      }
    };

    class ScatterController extends LineController {
    }
    ScatterController.id = 'scatter';
    ScatterController.defaults = {
      showLine: false,
      fill: false
    };
    ScatterController.overrides = {
      interaction: {
        mode: 'point'
      },
      plugins: {
        tooltip: {
          callbacks: {
            title() {
              return '';
            },
            label(item) {
              return '(' + item.label + ', ' + item.formattedValue + ')';
            }
          }
        }
      },
      scales: {
        x: {
          type: 'linear'
        },
        y: {
          type: 'linear'
        }
      }
    };

    var controllers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BarController: BarController,
    BubbleController: BubbleController,
    DoughnutController: DoughnutController,
    LineController: LineController,
    PolarAreaController: PolarAreaController,
    PieController: PieController,
    RadarController: RadarController,
    ScatterController: ScatterController
    });

    function abstract() {
      throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
    }
    class DateAdapter {
      constructor(options) {
        this.options = options || {};
      }
      formats() {
        return abstract();
      }
      parse(value, format) {
        return abstract();
      }
      format(timestamp, format) {
        return abstract();
      }
      add(timestamp, amount, unit) {
        return abstract();
      }
      diff(a, b, unit) {
        return abstract();
      }
      startOf(timestamp, unit, weekday) {
        return abstract();
      }
      endOf(timestamp, unit) {
        return abstract();
      }
    }
    DateAdapter.override = function(members) {
      Object.assign(DateAdapter.prototype, members);
    };
    var adapters = {
      _date: DateAdapter
    };

    function getRelativePosition(e, chart) {
      if ('native' in e) {
        return {
          x: e.x,
          y: e.y
        };
      }
      return getRelativePosition$1(e, chart);
    }
    function evaluateAllVisibleItems(chart, handler) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      let index, data, element;
      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
        ({index, data} = metasets[i]);
        for (let j = 0, jlen = data.length; j < jlen; ++j) {
          element = data[j];
          if (!element.skip) {
            handler(element, index, j);
          }
        }
      }
    }
    function binarySearch(metaset, axis, value, intersect) {
      const {controller, data, _sorted} = metaset;
      const iScale = controller._cachedMeta.iScale;
      if (iScale && axis === iScale.axis && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
        if (!intersect) {
          return lookupMethod(data, axis, value);
        } else if (controller._sharedOptions) {
          const el = data[0];
          const range = typeof el.getRange === 'function' && el.getRange(axis);
          if (range) {
            const start = lookupMethod(data, axis, value - range);
            const end = lookupMethod(data, axis, value + range);
            return {lo: start.lo, hi: end.hi};
          }
        }
      }
      return {lo: 0, hi: data.length - 1};
    }
    function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      const value = position[axis];
      for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
        const {index, data} = metasets[i];
        const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
        for (let j = lo; j <= hi; ++j) {
          const element = data[j];
          if (!element.skip) {
            handler(element, index, j);
          }
        }
      }
    }
    function getDistanceMetricForAxis(axis) {
      const useX = axis.indexOf('x') !== -1;
      const useY = axis.indexOf('y') !== -1;
      return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }
    function getIntersectItems(chart, position, axis, useFinalPosition) {
      const items = [];
      if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
        return items;
      }
      const evaluationFunc = function(element, datasetIndex, index) {
        if (element.inRange(position.x, position.y, useFinalPosition)) {
          items.push({element, datasetIndex, index});
        }
      };
      optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
      return items;
    }
    function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
      const distanceMetric = getDistanceMetricForAxis(axis);
      let minDistance = Number.POSITIVE_INFINITY;
      let items = [];
      if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
        return items;
      }
      const evaluationFunc = function(element, datasetIndex, index) {
        if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {
          return;
        }
        const center = element.getCenterPoint(useFinalPosition);
        if (!_isPointInArea(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) {
          return;
        }
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
          items = [{element, datasetIndex, index}];
          minDistance = distance;
        } else if (distance === minDistance) {
          items.push({element, datasetIndex, index});
        }
      };
      optimizedEvaluateItems(chart, axis, position, evaluationFunc);
      return items;
    }
    function getAxisItems(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const items = [];
      const axis = options.axis;
      const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
      let intersectsItem = false;
      evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {
        if (element[rangeMethod](position[axis], useFinalPosition)) {
          items.push({element, datasetIndex, index});
        }
        if (element.inRange(position.x, position.y, useFinalPosition)) {
          intersectsItem = true;
        }
      });
      if (options.intersect && !intersectsItem) {
        return [];
      }
      return items;
    }
    var Interaction = {
      modes: {
        index(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || 'x';
          const items = options.intersect
            ? getIntersectItems(chart, position, axis, useFinalPosition)
            : getNearestItems(chart, position, axis, false, useFinalPosition);
          const elements = [];
          if (!items.length) {
            return [];
          }
          chart.getSortedVisibleDatasetMetas().forEach((meta) => {
            const index = items[0].index;
            const element = meta.data[index];
            if (element && !element.skip) {
              elements.push({element, datasetIndex: meta.index, index});
            }
          });
          return elements;
        },
        dataset(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || 'xy';
          let items = options.intersect
            ? getIntersectItems(chart, position, axis, useFinalPosition) :
            getNearestItems(chart, position, axis, false, useFinalPosition);
          if (items.length > 0) {
            const datasetIndex = items[0].datasetIndex;
            const data = chart.getDatasetMeta(datasetIndex).data;
            items = [];
            for (let i = 0; i < data.length; ++i) {
              items.push({element: data[i], datasetIndex, index: i});
            }
          }
          return items;
        },
        point(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || 'xy';
          return getIntersectItems(chart, position, axis, useFinalPosition);
        },
        nearest(chart, e, options, useFinalPosition) {
          const position = getRelativePosition(e, chart);
          const axis = options.axis || 'xy';
          return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
        },
        x(chart, e, options, useFinalPosition) {
          options.axis = 'x';
          return getAxisItems(chart, e, options, useFinalPosition);
        },
        y(chart, e, options, useFinalPosition) {
          options.axis = 'y';
          return getAxisItems(chart, e, options, useFinalPosition);
        }
      }
    };

    const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
    function filterByPosition(array, position) {
      return array.filter(v => v.pos === position);
    }
    function filterDynamicPositionByAxis(array, axis) {
      return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
    }
    function sortByWeight(array, reverse) {
      return array.sort((a, b) => {
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ?
          v0.index - v1.index :
          v0.weight - v1.weight;
      });
    }
    function wrapBoxes(boxes) {
      const layoutBoxes = [];
      let i, ilen, box, pos, stack, stackWeight;
      for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
        box = boxes[i];
        ({position: pos, options: {stack, stackWeight = 1}} = box);
        layoutBoxes.push({
          index: i,
          box,
          pos,
          horizontal: box.isHorizontal(),
          weight: box.weight,
          stack: stack && (pos + stack),
          stackWeight
        });
      }
      return layoutBoxes;
    }
    function buildStacks(layouts) {
      const stacks = {};
      for (const wrap of layouts) {
        const {stack, pos, stackWeight} = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) {
          continue;
        }
        const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});
        _stack.count++;
        _stack.weight += stackWeight;
      }
      return stacks;
    }
    function setLayoutDims(layouts, params) {
      const stacks = buildStacks(layouts);
      const {vBoxMaxWidth, hBoxMaxHeight} = params;
      let i, ilen, layout;
      for (i = 0, ilen = layouts.length; i < ilen; ++i) {
        layout = layouts[i];
        const {fullSize} = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
          layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
          layout.height = hBoxMaxHeight;
        } else {
          layout.width = vBoxMaxWidth;
          layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
      }
      return stacks;
    }
    function buildLayoutBoxes(boxes) {
      const layoutBoxes = wrapBoxes(boxes);
      const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
      const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
      const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
      const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
      const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
      const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
      const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
      return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, 'chartArea'),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
      };
    }
    function getCombinedMax(maxPadding, chartArea, a, b) {
      return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
    }
    function updateMaxPadding(maxPadding, boxPadding) {
      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }
    function updateDims(chartArea, params, layout, stacks) {
      const {pos, box} = layout;
      const maxPadding = chartArea.maxPadding;
      if (!isObject(pos)) {
        if (layout.size) {
          chartArea[pos] -= layout.size;
        }
        const stack = stacks[layout.stack] || {size: 0, count: 1};
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
      }
      if (box.getPadding) {
        updateMaxPadding(maxPadding, box.getPadding());
      }
      const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
      const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
      const widthChanged = newWidth !== chartArea.w;
      const heightChanged = newHeight !== chartArea.h;
      chartArea.w = newWidth;
      chartArea.h = newHeight;
      return layout.horizontal
        ? {same: widthChanged, other: heightChanged}
        : {same: heightChanged, other: widthChanged};
    }
    function handleMaxPadding(chartArea) {
      const maxPadding = chartArea.maxPadding;
      function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
      }
      chartArea.y += updatePos('top');
      chartArea.x += updatePos('left');
      updatePos('right');
      updatePos('bottom');
    }
    function getMargins(horizontal, chartArea) {
      const maxPadding = chartArea.maxPadding;
      function marginForPositions(positions) {
        const margin = {left: 0, top: 0, right: 0, bottom: 0};
        positions.forEach((pos) => {
          margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
      }
      return horizontal
        ? marginForPositions(['left', 'right'])
        : marginForPositions(['top', 'bottom']);
    }
    function fitBoxes(boxes, chartArea, params, stacks) {
      const refitBoxes = [];
      let i, ilen, layout, box, refit, changed;
      for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
        layout = boxes[i];
        box = layout.box;
        box.update(
          layout.width || chartArea.w,
          layout.height || chartArea.h,
          getMargins(layout.horizontal, chartArea)
        );
        const {same, other} = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) {
          refitBoxes.push(layout);
        }
      }
      return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
    }
    function setBoxDims(box, left, top, width, height) {
      box.top = top;
      box.left = left;
      box.right = left + width;
      box.bottom = top + height;
      box.width = width;
      box.height = height;
    }
    function placeBoxes(boxes, chartArea, params, stacks) {
      const userPadding = params.padding;
      let {x, y} = chartArea;
      for (const layout of boxes) {
        const box = layout.box;
        const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};
        const weight = (layout.stackWeight / stack.weight) || 1;
        if (layout.horizontal) {
          const width = chartArea.w * weight;
          const height = stack.size || box.height;
          if (defined(stack.start)) {
            y = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
          } else {
            setBoxDims(box, chartArea.left + stack.placed, y, width, height);
          }
          stack.start = y;
          stack.placed += width;
          y = box.bottom;
        } else {
          const height = chartArea.h * weight;
          const width = stack.size || box.width;
          if (defined(stack.start)) {
            x = stack.start;
          }
          if (box.fullSize) {
            setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
          } else {
            setBoxDims(box, x, chartArea.top + stack.placed, width, height);
          }
          stack.start = x;
          stack.placed += height;
          x = box.right;
        }
      }
      chartArea.x = x;
      chartArea.y = y;
    }
    defaults.set('layout', {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
    var layouts = {
      addBox(chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        }
        item.fullSize = item.fullSize || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
          return [{
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }];
        };
        chart.boxes.push(item);
      },
      removeBox(chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },
      configure(chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
      },
      update(chart, width, height, minPadding) {
        if (!chart) {
          return;
        }
        const padding = toPadding(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        each(chart.boxes, box => {
          if (typeof box.beforeLayout === 'function') {
            box.beforeLayout();
          }
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>
          wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
          outerWidth: width,
          outerHeight: height,
          padding,
          availableWidth,
          availableHeight,
          vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
          hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, toPadding(minPadding));
        const chartArea = Object.assign({
          maxPadding,
          w: availableWidth,
          h: availableHeight,
          x: padding.left,
          y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
          fitBoxes(verticalBoxes, chartArea, params, stacks);
        }
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
          left: chartArea.left,
          top: chartArea.top,
          right: chartArea.left + chartArea.w,
          bottom: chartArea.top + chartArea.h,
          height: chartArea.h,
          width: chartArea.w,
        };
        each(boxes.chartArea, (layout) => {
          const box = layout.box;
          Object.assign(box, chart.chartArea);
          box.update(chartArea.w, chartArea.h);
        });
      }
    };

    class BasePlatform {
      acquireContext(canvas, aspectRatio) {}
      releaseContext(context) {
        return false;
      }
      addEventListener(chart, type, listener) {}
      removeEventListener(chart, type, listener) {}
      getDevicePixelRatio() {
        return 1;
      }
      getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
          width,
          height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
      }
      isAttached(canvas) {
        return true;
      }
      updateConfig(config) {
      }
    }

    class BasicPlatform extends BasePlatform {
      acquireContext(item) {
        return item && item.getContext && item.getContext('2d') || null;
      }
      updateConfig(config) {
        config.options.animation = false;
      }
    }

    const EXPANDO_KEY = '$chartjs';
    const EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    const isNullOrEmpty = value => value === null || value === '';
    function initCanvas(canvas, aspectRatio) {
      const style = canvas.style;
      const renderHeight = canvas.getAttribute('height');
      const renderWidth = canvas.getAttribute('width');
      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      };
      style.display = style.display || 'block';
      style.boxSizing = style.boxSizing || 'border-box';
      if (isNullOrEmpty(renderWidth)) {
        const displayWidth = readUsedSize(canvas, 'width');
        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }
      if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === '') {
          canvas.height = canvas.width / (aspectRatio || 2);
        } else {
          const displayHeight = readUsedSize(canvas, 'height');
          if (displayHeight !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }
      return canvas;
    }
    const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
    function removeListener(chart, type, listener) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
    function fromNativeEvent(event, chart) {
      const type = EVENT_TYPES[event.type] || event.type;
      const {x, y} = getRelativePosition$1(event, chart);
      return {
        type,
        chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null,
      };
    }
    function createAttachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver(entries => {
        for (const entry of entries) {
          for (const node of entry.addedNodes) {
            if (node === canvas || node.contains(canvas)) {
              return listener();
            }
          }
        }
      });
      observer.observe(document, {childList: true, subtree: true});
      return observer;
    }
    function createDetachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver(entries => {
        for (const entry of entries) {
          for (const node of entry.removedNodes) {
            if (node === canvas || node.contains(canvas)) {
              return listener();
            }
          }
        }
      });
      observer.observe(document, {childList: true, subtree: true});
      return observer;
    }
    const drpListeningCharts = new Map();
    let oldDevicePixelRatio = 0;
    function onWindowResize() {
      const dpr = window.devicePixelRatio;
      if (dpr === oldDevicePixelRatio) {
        return;
      }
      oldDevicePixelRatio = dpr;
      drpListeningCharts.forEach((resize, chart) => {
        if (chart.currentDevicePixelRatio !== dpr) {
          resize();
        }
      });
    }
    function listenDevicePixelRatioChanges(chart, resize) {
      if (!drpListeningCharts.size) {
        window.addEventListener('resize', onWindowResize);
      }
      drpListeningCharts.set(chart, resize);
    }
    function unlistenDevicePixelRatioChanges(chart) {
      drpListeningCharts.delete(chart);
      if (!drpListeningCharts.size) {
        window.removeEventListener('resize', onWindowResize);
      }
    }
    function createResizeObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        return;
      }
      const resize = throttled((width, height) => {
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) {
          listener();
        }
      }, window);
      const observer = new ResizeObserver(entries => {
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) {
          return;
        }
        resize(width, height);
      });
      observer.observe(container);
      listenDevicePixelRatioChanges(chart, resize);
      return observer;
    }
    function releaseObserver(chart, type, observer) {
      if (observer) {
        observer.disconnect();
      }
      if (type === 'resize') {
        unlistenDevicePixelRatioChanges(chart);
      }
    }
    function createProxyAndListen(chart, type, listener) {
      const canvas = chart.canvas;
      const proxy = throttled((event) => {
        if (chart.ctx !== null) {
          listener(fromNativeEvent(event, chart));
        }
      }, chart, (args) => {
        const event = args[0];
        return [event, event.offsetX, event.offsetY];
      });
      addListener(canvas, type, proxy);
      return proxy;
    }
    class DomPlatform extends BasePlatform {
      acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext('2d');
        if (context && context.canvas === canvas) {
          initCanvas(canvas, aspectRatio);
          return context;
        }
        return null;
      }
      releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) {
          return false;
        }
        const initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach((prop) => {
          const value = initial[prop];
          if (isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key) => {
          canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
      }
      addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
          attach: createAttachObserver,
          detach: createDetachObserver,
          resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
      }
      removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) {
          return;
        }
        const handlers = {
          attach: releaseObserver,
          detach: releaseObserver,
          resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = undefined;
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
      getMaximumSize(canvas, width, height, aspectRatio) {
        return getMaximumSize(canvas, width, height, aspectRatio);
      }
      isAttached(canvas) {
        const container = _getParentNode(canvas);
        return !!(container && container.isConnected);
      }
    }

    function _detectPlatform(canvas) {
      if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {
        return BasicPlatform;
      }
      return DomPlatform;
    }

    class Element {
      constructor() {
        this.x = undefined;
        this.y = undefined;
        this.active = false;
        this.options = undefined;
        this.$animations = undefined;
      }
      tooltipPosition(useFinalPosition) {
        const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
        return {x, y};
      }
      hasValue() {
        return isNumber(this.x) && isNumber(this.y);
      }
      getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) {
          return this;
        }
        const ret = {};
        props.forEach(prop => {
          ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
      }
    }
    Element.defaults = {};
    Element.defaultRoutes = undefined;

    const formatters = {
      values(value) {
        return isArray(value) ? value : '' + value;
      },
      numeric(tickValue, index, ticks) {
        if (tickValue === 0) {
          return '0';
        }
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
          const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
          if (maxTick < 1e-4 || maxTick > 1e+15) {
            notation = 'scientific';
          }
          delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
      },
      logarithmic(tickValue, index, ticks) {
        if (tickValue === 0) {
          return '0';
        }
        const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));
        if (remain === 1 || remain === 2 || remain === 5) {
          return formatters.numeric.call(this, tickValue, index, ticks);
        }
        return '';
      }
    };
    function calculateDelta(tickValue, ticks) {
      let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
      if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
        delta = tickValue - Math.floor(tickValue);
      }
      return delta;
    }
    var Ticks = {formatters};

    defaults.set('scale', {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: 'ticks',
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false,
        borderDash: [],
        borderDashOffset: 0.0,
        borderWidth: 1
      },
      title: {
        display: false,
        text: '',
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: '',
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: 'center',
        crossAlign: 'near',
        showLabelBackdrop: false,
        backdropColor: 'rgba(255, 255, 255, 0.75)',
        backdropPadding: 2,
      }
    });
    defaults.route('scale.ticks', 'color', '', 'color');
    defaults.route('scale.grid', 'color', '', 'borderColor');
    defaults.route('scale.grid', 'borderColor', '', 'borderColor');
    defaults.route('scale.title', 'color', '', 'color');
    defaults.describe('scale', {
      _fallback: false,
      _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
      _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',
    });
    defaults.describe('scales', {
      _fallback: 'scale',
    });
    defaults.describe('scale.ticks', {
      _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',
      _indexable: (name) => name !== 'backdropPadding',
    });

    function autoSkip(scale, ticks) {
      const tickOpts = scale.options.ticks;
      const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
      const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
      const numMajorIndices = majorIndices.length;
      const first = majorIndices[0];
      const last = majorIndices[numMajorIndices - 1];
      const newTicks = [];
      if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
      }
      const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
      if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
          skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        }
        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
      }
      skip(ticks, newTicks, spacing);
      return newTicks;
    }
    function determineMaxTicks(scale) {
      const offset = scale.options.offset;
      const tickLength = scale._tickSize();
      const maxScale = scale._length / tickLength + (offset ? 0 : 1);
      const maxChart = scale._maxLength / tickLength;
      return Math.floor(Math.min(maxScale, maxChart));
    }
    function calculateSpacing(majorIndices, ticks, ticksLimit) {
      const evenMajorSpacing = getEvenSpacing(majorIndices);
      const spacing = ticks.length / ticksLimit;
      if (!evenMajorSpacing) {
        return Math.max(spacing, 1);
      }
      const factors = _factorize(evenMajorSpacing);
      for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
        const factor = factors[i];
        if (factor > spacing) {
          return factor;
        }
      }
      return Math.max(spacing, 1);
    }
    function getMajorIndices(ticks) {
      const result = [];
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (ticks[i].major) {
          result.push(i);
        }
      }
      return result;
    }
    function skipMajors(ticks, newTicks, majorIndices, spacing) {
      let count = 0;
      let next = majorIndices[0];
      let i;
      spacing = Math.ceil(spacing);
      for (i = 0; i < ticks.length; i++) {
        if (i === next) {
          newTicks.push(ticks[i]);
          count++;
          next = majorIndices[count * spacing];
        }
      }
    }
    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
      const start = valueOrDefault(majorStart, 0);
      const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
      let count = 0;
      let length, i, next;
      spacing = Math.ceil(spacing);
      if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
      }
      next = start;
      while (next < 0) {
        count++;
        next = Math.round(start + count * spacing);
      }
      for (i = Math.max(start, 0); i < end; i++) {
        if (i === next) {
          newTicks.push(ticks[i]);
          count++;
          next = Math.round(start + count * spacing);
        }
      }
    }
    function getEvenSpacing(arr) {
      const len = arr.length;
      let i, diff;
      if (len < 2) {
        return false;
      }
      for (diff = arr[0], i = 1; i < len; ++i) {
        if (arr[i] - arr[i - 1] !== diff) {
          return false;
        }
      }
      return diff;
    }

    const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;
    const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
    function sample(arr, numItems) {
      const result = [];
      const increment = arr.length / numItems;
      const len = arr.length;
      let i = 0;
      for (; i < len; i += increment) {
        result.push(arr[Math.floor(i)]);
      }
      return result;
    }
    function getPixelForGridLine(scale, index, offsetGridLines) {
      const length = scale.ticks.length;
      const validIndex = Math.min(index, length - 1);
      const start = scale._startPixel;
      const end = scale._endPixel;
      const epsilon = 1e-6;
      let lineValue = scale.getPixelForTick(validIndex);
      let offset;
      if (offsetGridLines) {
        if (length === 1) {
          offset = Math.max(lineValue - start, end - lineValue);
        } else if (index === 0) {
          offset = (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        }
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) {
          return;
        }
      }
      return lineValue;
    }
    function garbageCollect(caches, length) {
      each(caches, (cache) => {
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
          for (i = 0; i < gcLen; ++i) {
            delete cache.data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
      });
    }
    function getTickMarkLength(options) {
      return options.drawTicks ? options.tickLength : 0;
    }
    function getTitleHeight(options, fallback) {
      if (!options.display) {
        return 0;
      }
      const font = toFont(options.font, fallback);
      const padding = toPadding(options.padding);
      const lines = isArray(options.text) ? options.text.length : 1;
      return (lines * font.lineHeight) + padding.height;
    }
    function createScaleContext(parent, scale) {
      return createContext(parent, {
        scale,
        type: 'scale'
      });
    }
    function createTickContext(parent, index, tick) {
      return createContext(parent, {
        tick,
        index,
        type: 'tick'
      });
    }
    function titleAlign(align, position, reverse) {
      let ret = _toLeftRightCenter(align);
      if ((reverse && position !== 'right') || (!reverse && position === 'right')) {
        ret = reverseAlign(ret);
      }
      return ret;
    }
    function titleArgs(scale, offset, position, align) {
      const {top, left, bottom, right, chart} = scale;
      const {chartArea, scales} = chart;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      const height = bottom - top;
      const width = right - left;
      if (scale.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === 'center') {
          titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        } else {
          titleY = offsetFromEdge(scale, position, offset);
        }
        maxWidth = right - left;
      } else {
        if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === 'center') {
          titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        } else {
          titleX = offsetFromEdge(scale, position, offset);
        }
        titleY = _alignStartEnd(align, bottom, top);
        rotation = position === 'left' ? -HALF_PI : HALF_PI;
      }
      return {titleX, titleY, maxWidth, rotation};
    }
    class Scale extends Element {
      constructor(cfg) {
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = undefined;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this._margins = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        this.maxWidth = undefined;
        this.maxHeight = undefined;
        this.paddingTop = undefined;
        this.paddingBottom = undefined;
        this.paddingLeft = undefined;
        this.paddingRight = undefined;
        this.axis = undefined;
        this.labelRotation = undefined;
        this.min = undefined;
        this.max = undefined;
        this._range = undefined;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = undefined;
        this._endPixel = undefined;
        this._reversePixels = false;
        this._userMax = undefined;
        this._userMin = undefined;
        this._suggestedMax = undefined;
        this._suggestedMin = undefined;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = undefined;
      }
      init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
      }
      parse(raw, index) {
        return raw;
      }
      getUserBounds() {
        let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
          min: finiteOrDefault(_userMin, _suggestedMin),
          max: finiteOrDefault(_userMax, _suggestedMax),
          minDefined: isNumberFinite(_userMin),
          maxDefined: isNumberFinite(_userMax)
        };
      }
      getMinMax(canStack) {
        let {min, max, minDefined, maxDefined} = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) {
          return {min, max};
        }
        const metas = this.getMatchingVisibleMetas();
        for (let i = 0, ilen = metas.length; i < ilen; ++i) {
          range = metas[i].controller.getMinMax(this, canStack);
          if (!minDefined) {
            min = Math.min(min, range.min);
          }
          if (!maxDefined) {
            max = Math.max(max, range.max);
          }
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
          min: finiteOrDefault(min, finiteOrDefault(max, min)),
          max: finiteOrDefault(max, finiteOrDefault(min, max))
        };
      }
      getPadding() {
        return {
          left: this.paddingLeft || 0,
          top: this.paddingTop || 0,
          right: this.paddingRight || 0,
          bottom: this.paddingBottom || 0
        };
      }
      getTicks() {
        return this.ticks;
      }
      getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
      }
      beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
      }
      beforeUpdate() {
        callback(this.options.beforeUpdate, [this]);
      }
      update(maxWidth, maxHeight, margins) {
        const {beginAtZero, grace, ticks: tickOpts} = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal()
          ? this.width + margins.left + margins.right
          : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
          this.beforeDataLimits();
          this.determineDataLimits();
          this.afterDataLimits();
          this._range = _addGrace(this, grace, beginAtZero);
          this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
          this.ticks = autoSkip(this, this.ticks);
          this._labelSizes = null;
        }
        if (samplingEnabled) {
          this._convertTicksToLabels(this.ticks);
        }
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
      }
      configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
          startPixel = this.left;
          endPixel = this.right;
        } else {
          startPixel = this.top;
          endPixel = this.bottom;
          reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
      }
      afterUpdate() {
        callback(this.options.afterUpdate, [this]);
      }
      beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [this]);
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = 0;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = 0;
          this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
      }
      afterSetDimensions() {
        callback(this.options.afterSetDimensions, [this]);
      }
      _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        callback(this.options[name], [this]);
      }
      beforeDataLimits() {
        this._callHooks('beforeDataLimits');
      }
      determineDataLimits() {}
      afterDataLimits() {
        this._callHooks('afterDataLimits');
      }
      beforeBuildTicks() {
        this._callHooks('beforeBuildTicks');
      }
      buildTicks() {
        return [];
      }
      afterBuildTicks() {
        this._callHooks('afterBuildTicks');
      }
      beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [this]);
      }
      generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          tick = ticks[i];
          tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
        }
      }
      afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [this]);
      }
      beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [this]);
      }
      calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = this.ticks.length;
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
          this.labelRotation = minRotation;
          return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
          tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
          maxHeight = this.maxHeight - getTickMarkLength(options.grid)
    				- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
          maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
          labelRotation = toDegrees(Math.min(
            Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
            Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
          ));
          labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
      }
      afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [this]);
      }
      beforeFit() {
        callback(this.options.beforeFit, [this]);
      }
      fit() {
        const minSize = {
          width: 0,
          height: 0
        };
        const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
          const titleHeight = getTitleHeight(titleOpts, chart.options.font);
          if (isHorizontal) {
            minSize.width = this.maxWidth;
            minSize.height = getTickMarkLength(gridOpts) + titleHeight;
          } else {
            minSize.height = this.maxHeight;
            minSize.width = getTickMarkLength(gridOpts) + titleHeight;
          }
          if (tickOpts.display && this.ticks.length) {
            const {first, last, widest, highest} = this._getLabelSizes();
            const tickPadding = tickOpts.padding * 2;
            const angleRadians = toRadians(this.labelRotation);
            const cos = Math.cos(angleRadians);
            const sin = Math.sin(angleRadians);
            if (isHorizontal) {
              const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
              minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
            } else {
              const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
              minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
            }
            this._calculatePadding(first, last, sin, cos);
          }
        }
        this._handleMargins();
        if (isHorizontal) {
          this.width = this._length = chart.width - this._margins.left - this._margins.right;
          this.height = minSize.height;
        } else {
          this.width = minSize.width;
          this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
      }
      _calculatePadding(first, last, sin, cos) {
        const {ticks: {align, padding}, position} = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== 'top' && this.axis === 'x';
        if (this.isHorizontal()) {
          const offsetLeft = this.getPixelForTick(0) - this.left;
          const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
          let paddingLeft = 0;
          let paddingRight = 0;
          if (isRotated) {
            if (labelsBelowTicks) {
              paddingLeft = cos * first.width;
              paddingRight = sin * last.height;
            } else {
              paddingLeft = sin * first.height;
              paddingRight = cos * last.width;
            }
          } else if (align === 'start') {
            paddingRight = last.width;
          } else if (align === 'end') {
            paddingLeft = first.width;
          } else {
            paddingLeft = first.width / 2;
            paddingRight = last.width / 2;
          }
          this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
          this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
          let paddingTop = last.height / 2;
          let paddingBottom = first.height / 2;
          if (align === 'start') {
            paddingTop = 0;
            paddingBottom = first.height;
          } else if (align === 'end') {
            paddingTop = last.height;
            paddingBottom = 0;
          }
          this.paddingTop = paddingTop + padding;
          this.paddingBottom = paddingBottom + padding;
        }
      }
      _handleMargins() {
        if (this._margins) {
          this._margins.left = Math.max(this.paddingLeft, this._margins.left);
          this._margins.top = Math.max(this.paddingTop, this._margins.top);
          this._margins.right = Math.max(this.paddingRight, this._margins.right);
          this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
      }
      afterFit() {
        callback(this.options.afterFit, [this]);
      }
      isHorizontal() {
        const {axis, position} = this.options;
        return position === 'top' || position === 'bottom' || axis === 'x';
      }
      isFullSize() {
        return this.options.fullSize;
      }
      _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (isNullOrUndef(ticks[i].label)) {
            ticks.splice(i, 1);
            ilen--;
            i--;
          }
        }
        this.afterTickToLabelConversion();
      }
      _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
          const sampleSize = this.options.ticks.sampleSize;
          let ticks = this.ticks;
          if (sampleSize < ticks.length) {
            ticks = sample(ticks, sampleSize);
          }
          this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
        }
        return labelSizes;
      }
      _computeLabelSizes(ticks, length) {
        const {ctx, _longestTextCache: caches} = this;
        const widths = [];
        const heights = [];
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for (i = 0; i < length; ++i) {
          label = ticks[i].label;
          tickFont = this._resolveTickFontOptions(i);
          ctx.font = fontString = tickFont.string;
          cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
          lineHeight = tickFont.lineHeight;
          width = height = 0;
          if (!isNullOrUndef(label) && !isArray(label)) {
            width = _measureText(ctx, cache.data, cache.gc, width, label);
            height = lineHeight;
          } else if (isArray(label)) {
            for (j = 0, jlen = label.length; j < jlen; ++j) {
              nestedLabel = label[j];
              if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                height += lineHeight;
              }
            }
          }
          widths.push(width);
          heights.push(height);
          widestLabelSize = Math.max(width, widestLabelSize);
          highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
        return {
          first: valueAt(0),
          last: valueAt(length - 1),
          widest: valueAt(widest),
          highest: valueAt(highest),
          widths,
          heights,
        };
      }
      getLabelForValue(value) {
        return value;
      }
      getPixelForValue(value, index) {
        return NaN;
      }
      getValueForPixel(pixel) {}
      getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index].value);
      }
      getPixelForDecimal(decimal) {
        if (this._reversePixels) {
          decimal = 1 - decimal;
        }
        const pixel = this._startPixel + decimal * this._length;
        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
      }
      getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
      }
      getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
      }
      getBaseValue() {
        const {min, max} = this;
        return min < 0 && max < 0 ? max :
          min > 0 && max > 0 ? min :
          0;
      }
      getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
          const tick = ticks[index];
          return tick.$context ||
    				(tick.$context = createTickContext(this.getContext(), index, tick));
        }
        return this.$context ||
    			(this.$context = createScaleContext(this.chart.getContext(), this));
      }
      _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = toRadians(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal()
          ? h * cos > w * sin ? w / cos : h / sin
          : h * sin < w * cos ? h / cos : w / sin;
      }
      _isVisible() {
        const display = this.options.display;
        if (display !== 'auto') {
          return !!display;
        }
        return this.getMatchingVisibleMetas().length > 0;
      }
      _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const {grid, position} = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = grid.setContext(this.getContext());
        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
          return _alignPixel(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === 'top') {
          borderValue = alignBorderValue(this.bottom);
          ty1 = this.bottom - tl;
          ty2 = borderValue - axisHalfWidth;
          y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
          y2 = chartArea.bottom;
        } else if (position === 'bottom') {
          borderValue = alignBorderValue(this.top);
          y1 = chartArea.top;
          y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
          ty1 = borderValue + axisHalfWidth;
          ty2 = this.top + tl;
        } else if (position === 'left') {
          borderValue = alignBorderValue(this.right);
          tx1 = this.right - tl;
          tx2 = borderValue - axisHalfWidth;
          x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
          x2 = chartArea.right;
        } else if (position === 'right') {
          borderValue = alignBorderValue(this.left);
          x1 = chartArea.left;
          x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
          tx1 = borderValue + axisHalfWidth;
          tx2 = this.left + tl;
        } else if (axis === 'x') {
          if (position === 'center') {
            borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          y1 = chartArea.top;
          y2 = chartArea.bottom;
          ty1 = borderValue + axisHalfWidth;
          ty2 = ty1 + tl;
        } else if (axis === 'y') {
          if (position === 'center') {
            borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
          }
          tx1 = borderValue - axisHalfWidth;
          tx2 = tx1 - tl;
          x1 = chartArea.left;
          x2 = chartArea.right;
        }
        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for (i = 0; i < ticksLength; i += step) {
          const optsAtIndex = grid.setContext(this.getContext(i));
          const lineWidth = optsAtIndex.lineWidth;
          const lineColor = optsAtIndex.color;
          const borderDash = grid.borderDash || [];
          const borderDashOffset = optsAtIndex.borderDashOffset;
          const tickWidth = optsAtIndex.tickWidth;
          const tickColor = optsAtIndex.tickColor;
          const tickBorderDash = optsAtIndex.tickBorderDash || [];
          const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
          lineValue = getPixelForGridLine(this, i, offset);
          if (lineValue === undefined) {
            continue;
          }
          alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
          if (isHorizontal) {
            tx1 = tx2 = x1 = x2 = alignedLineValue;
          } else {
            ty1 = ty2 = y1 = y2 = alignedLineValue;
          }
          items.push({
            tx1,
            ty1,
            tx2,
            ty2,
            x1,
            y1,
            x2,
            y2,
            width: lineWidth,
            color: lineColor,
            borderDash,
            borderDashOffset,
            tickWidth,
            tickColor,
            tickBorderDash,
            tickBorderDashOffset,
          });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
      }
      _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const {position, ticks: optionTicks} = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const {align, crossAlign, padding, mirror} = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -toRadians(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = 'middle';
        if (position === 'top') {
          y = this.bottom - hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'bottom') {
          y = this.top + hTickAndPadding;
          textAlign = this._getXAxisLabelAlignment();
        } else if (position === 'left') {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (position === 'right') {
          const ret = this._getYAxisLabelAlignment(tl);
          textAlign = ret.textAlign;
          x = ret.x;
        } else if (axis === 'x') {
          if (position === 'center') {
            y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
          }
          textAlign = this._getXAxisLabelAlignment();
        } else if (axis === 'y') {
          if (position === 'center') {
            x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;
          } else if (isObject(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            x = this.chart.scales[positionAxisID].getPixelForValue(value);
          }
          textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === 'y') {
          if (align === 'start') {
            textBaseline = 'top';
          } else if (align === 'end') {
            textBaseline = 'bottom';
          }
        }
        const labelSizes = this._getLabelSizes();
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick = ticks[i];
          label = tick.label;
          const optsAtIndex = optionTicks.setContext(this.getContext(i));
          pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
          font = this._resolveTickFontOptions(i);
          lineHeight = font.lineHeight;
          lineCount = isArray(label) ? label.length : 1;
          const halfCount = lineCount / 2;
          const color = optsAtIndex.color;
          const strokeColor = optsAtIndex.textStrokeColor;
          const strokeWidth = optsAtIndex.textStrokeWidth;
          if (isHorizontal) {
            x = pixel;
            if (position === 'top') {
              if (crossAlign === 'near' || rotation !== 0) {
                textOffset = -lineCount * lineHeight + lineHeight / 2;
              } else if (crossAlign === 'center') {
                textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
              } else {
                textOffset = -labelSizes.highest.height + lineHeight / 2;
              }
            } else {
              if (crossAlign === 'near' || rotation !== 0) {
                textOffset = lineHeight / 2;
              } else if (crossAlign === 'center') {
                textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
              } else {
                textOffset = labelSizes.highest.height - lineCount * lineHeight;
              }
            }
            if (mirror) {
              textOffset *= -1;
            }
          } else {
            y = pixel;
            textOffset = (1 - lineCount) * lineHeight / 2;
          }
          let backdrop;
          if (optsAtIndex.showLabelBackdrop) {
            const labelPadding = toPadding(optsAtIndex.backdropPadding);
            const height = labelSizes.heights[i];
            const width = labelSizes.widths[i];
            let top = y + textOffset - labelPadding.top;
            let left = x - labelPadding.left;
            switch (textBaseline) {
            case 'middle':
              top -= height / 2;
              break;
            case 'bottom':
              top -= height;
              break;
            }
            switch (textAlign) {
            case 'center':
              left -= width / 2;
              break;
            case 'right':
              left -= width;
              break;
            }
            backdrop = {
              left,
              top,
              width: width + labelPadding.width,
              height: height + labelPadding.height,
              color: optsAtIndex.backdropColor,
            };
          }
          items.push({
            rotation,
            label,
            font,
            color,
            strokeColor,
            strokeWidth,
            textOffset,
            textAlign,
            textBaseline,
            translation: [x, y],
            backdrop,
          });
        }
        return items;
      }
      _getXAxisLabelAlignment() {
        const {position, ticks} = this.options;
        const rotation = -toRadians(this.labelRotation);
        if (rotation) {
          return position === 'top' ? 'left' : 'right';
        }
        let align = 'center';
        if (ticks.align === 'start') {
          align = 'left';
        } else if (ticks.align === 'end') {
          align = 'right';
        }
        return align;
      }
      _getYAxisLabelAlignment(tl) {
        const {position, ticks: {crossAlign, mirror, padding}} = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === 'left') {
          if (mirror) {
            x = this.right + padding;
            if (crossAlign === 'near') {
              textAlign = 'left';
            } else if (crossAlign === 'center') {
              textAlign = 'center';
              x += (widest / 2);
            } else {
              textAlign = 'right';
              x += widest;
            }
          } else {
            x = this.right - tickAndPadding;
            if (crossAlign === 'near') {
              textAlign = 'right';
            } else if (crossAlign === 'center') {
              textAlign = 'center';
              x -= (widest / 2);
            } else {
              textAlign = 'left';
              x = this.left;
            }
          }
        } else if (position === 'right') {
          if (mirror) {
            x = this.left + padding;
            if (crossAlign === 'near') {
              textAlign = 'right';
            } else if (crossAlign === 'center') {
              textAlign = 'center';
              x -= (widest / 2);
            } else {
              textAlign = 'left';
              x -= widest;
            }
          } else {
            x = this.left + tickAndPadding;
            if (crossAlign === 'near') {
              textAlign = 'left';
            } else if (crossAlign === 'center') {
              textAlign = 'center';
              x += widest / 2;
            } else {
              textAlign = 'right';
              x = this.right;
            }
          }
        } else {
          textAlign = 'right';
        }
        return {textAlign, x};
      }
      _computeLabelArea() {
        if (this.options.ticks.mirror) {
          return;
        }
        const chart = this.chart;
        const position = this.options.position;
        if (position === 'left' || position === 'right') {
          return {top: 0, left: this.left, bottom: chart.height, right: this.right};
        } if (position === 'top' || position === 'bottom') {
          return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};
        }
      }
      drawBackground() {
        const {ctx, options: {backgroundColor}, left, top, width, height} = this;
        if (backgroundColor) {
          ctx.save();
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(left, top, width, height);
          ctx.restore();
        }
      }
      getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) {
          return 0;
        }
        const ticks = this.ticks;
        const index = ticks.findIndex(t => t.value === value);
        if (index >= 0) {
          const opts = grid.setContext(this.getContext(index));
          return opts.lineWidth;
        }
        return 0;
      }
      drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style) => {
          if (!style.width || !style.color) {
            return;
          }
          ctx.save();
          ctx.lineWidth = style.width;
          ctx.strokeStyle = style.color;
          ctx.setLineDash(style.borderDash || []);
          ctx.lineDashOffset = style.borderDashOffset;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
          ctx.restore();
        };
        if (grid.display) {
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            const item = items[i];
            if (grid.drawOnChartArea) {
              drawLine(
                {x: item.x1, y: item.y1},
                {x: item.x2, y: item.y2},
                item
              );
            }
            if (grid.drawTicks) {
              drawLine(
                {x: item.tx1, y: item.ty1},
                {x: item.tx2, y: item.ty2},
                {
                  color: item.tickColor,
                  width: item.tickWidth,
                  borderDash: item.tickBorderDash,
                  borderDashOffset: item.tickBorderDashOffset
                }
              );
            }
          }
        }
      }
      drawBorder() {
        const {chart, ctx, options: {grid}} = this;
        const borderOpts = grid.setContext(this.getContext());
        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
        if (!axisWidth) {
          return;
        }
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
          x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
          x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
          y1 = y2 = borderValue;
        } else {
          y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
          y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
          x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.borderWidth;
        ctx.strokeStyle = borderOpts.borderColor;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
      }
      drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) {
          return;
        }
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) {
          clipArea(ctx, area);
        }
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          const tickFont = item.font;
          const label = item.label;
          if (item.backdrop) {
            ctx.fillStyle = item.backdrop.color;
            ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
          }
          let y = item.textOffset;
          renderText(ctx, label, 0, y, tickFont, item);
        }
        if (area) {
          unclipArea(ctx);
        }
      }
      drawTitle() {
        const {ctx, options: {position, title, reverse}} = this;
        if (!title.display) {
          return;
        }
        const font = toFont(title.font);
        const padding = toPadding(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === 'bottom' || position === 'center' || isObject(position)) {
          offset += padding.bottom;
          if (isArray(title.text)) {
            offset += font.lineHeight * (title.text.length - 1);
          }
        } else {
          offset += padding.top;
        }
        const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
        renderText(ctx, title.text, 0, 0, font, {
          color: title.color,
          maxWidth,
          rotation,
          textAlign: titleAlign(align, position, reverse),
          textBaseline: 'middle',
          translation: [titleX, titleY],
        });
      }
      draw(chartArea) {
        if (!this._isVisible()) {
          return;
        }
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
      }
      _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
          return [{
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }];
        }
        return [{
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        }, {
          z: gz + 1,
          draw: () => {
            this.drawBorder();
          }
        }, {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }];
      }
      getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + 'AxisID';
        const result = [];
        let i, ilen;
        for (i = 0, ilen = metas.length; i < ilen; ++i) {
          const meta = metas[i];
          if (meta[axisID] === this.id && (!type || meta.type === type)) {
            result.push(meta);
          }
        }
        return result;
      }
      _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return toFont(opts.font);
      }
      _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
      }
    }

    class TypedRegistry {
      constructor(type, scope, override) {
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
      }
      isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
      }
      register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) {
          parentScope = this.register(proto);
        }
        const items = this.items;
        const id = item.id;
        const scope = this.scope + '.' + id;
        if (!id) {
          throw new Error('class does not have id: ' + item);
        }
        if (id in items) {
          return scope;
        }
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) {
          defaults.override(item.id, item.overrides);
        }
        return scope;
      }
      get(id) {
        return this.items[id];
      }
      unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) {
          delete items[id];
        }
        if (scope && id in defaults[scope]) {
          delete defaults[scope][id];
          if (this.override) {
            delete overrides[id];
          }
        }
      }
    }
    function registerDefaults(item, scope, parentScope) {
      const itemDefaults = merge(Object.create(null), [
        parentScope ? defaults.get(parentScope) : {},
        defaults.get(scope),
        item.defaults
      ]);
      defaults.set(scope, itemDefaults);
      if (item.defaultRoutes) {
        routeDefaults(scope, item.defaultRoutes);
      }
      if (item.descriptors) {
        defaults.describe(scope, item.descriptors);
      }
    }
    function routeDefaults(scope, routes) {
      Object.keys(routes).forEach(property => {
        const propertyParts = property.split('.');
        const sourceName = propertyParts.pop();
        const sourceScope = [scope].concat(propertyParts).join('.');
        const parts = routes[property].split('.');
        const targetName = parts.pop();
        const targetScope = parts.join('.');
        defaults.route(sourceScope, sourceName, targetScope, targetName);
      });
    }
    function isIChartComponent(proto) {
      return 'id' in proto && 'defaults' in proto;
    }

    class Registry {
      constructor() {
        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
        this.elements = new TypedRegistry(Element, 'elements');
        this.plugins = new TypedRegistry(Object, 'plugins');
        this.scales = new TypedRegistry(Scale, 'scales');
        this._typedRegistries = [this.controllers, this.scales, this.elements];
      }
      add(...args) {
        this._each('register', args);
      }
      remove(...args) {
        this._each('unregister', args);
      }
      addControllers(...args) {
        this._each('register', args, this.controllers);
      }
      addElements(...args) {
        this._each('register', args, this.elements);
      }
      addPlugins(...args) {
        this._each('register', args, this.plugins);
      }
      addScales(...args) {
        this._each('register', args, this.scales);
      }
      getController(id) {
        return this._get(id, this.controllers, 'controller');
      }
      getElement(id) {
        return this._get(id, this.elements, 'element');
      }
      getPlugin(id) {
        return this._get(id, this.plugins, 'plugin');
      }
      getScale(id) {
        return this._get(id, this.scales, 'scale');
      }
      removeControllers(...args) {
        this._each('unregister', args, this.controllers);
      }
      removeElements(...args) {
        this._each('unregister', args, this.elements);
      }
      removePlugins(...args) {
        this._each('unregister', args, this.plugins);
      }
      removeScales(...args) {
        this._each('unregister', args, this.scales);
      }
      _each(method, args, typedRegistry) {
        [...args].forEach(arg => {
          const reg = typedRegistry || this._getRegistryForType(arg);
          if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {
            this._exec(method, reg, arg);
          } else {
            each(arg, item => {
              const itemReg = typedRegistry || this._getRegistryForType(item);
              this._exec(method, itemReg, item);
            });
          }
        });
      }
      _exec(method, registry, component) {
        const camelMethod = _capitalize(method);
        callback(component['before' + camelMethod], [], component);
        registry[method](component);
        callback(component['after' + camelMethod], [], component);
      }
      _getRegistryForType(type) {
        for (let i = 0; i < this._typedRegistries.length; i++) {
          const reg = this._typedRegistries[i];
          if (reg.isForType(type)) {
            return reg;
          }
        }
        return this.plugins;
      }
      _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === undefined) {
          throw new Error('"' + id + '" is not a registered ' + type + '.');
        }
        return item;
      }
    }
    var registry = new Registry();

    class PluginService {
      constructor() {
        this._init = [];
      }
      notify(chart, hook, args, filter) {
        if (hook === 'beforeInit') {
          this._init = this._createDescriptors(chart, true);
          this._notify(this._init, chart, 'install');
        }
        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors, chart, hook, args);
        if (hook === 'destroy') {
          this._notify(descriptors, chart, 'stop');
          this._notify(this._init, chart, 'uninstall');
        }
        return result;
      }
      _notify(descriptors, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors) {
          const plugin = descriptor.plugin;
          const method = plugin[hook];
          const params = [chart, args, descriptor.options];
          if (callback(method, params, plugin) === false && args.cancelable) {
            return false;
          }
        }
        return true;
      }
      invalidate() {
        if (!isNullOrUndef(this._cache)) {
          this._oldCache = this._cache;
          this._cache = undefined;
        }
      }
      _descriptors(chart) {
        if (this._cache) {
          return this._cache;
        }
        const descriptors = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors;
      }
      _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = valueOrDefault(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
      }
      _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors = this._cache;
        const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
        this._notify(diff(descriptors, previousDescriptors), chart, 'start');
      }
    }
    function allPlugins(config) {
      const plugins = [];
      const keys = Object.keys(registry.plugins.items);
      for (let i = 0; i < keys.length; i++) {
        plugins.push(registry.getPlugin(keys[i]));
      }
      const local = config.plugins || [];
      for (let i = 0; i < local.length; i++) {
        const plugin = local[i];
        if (plugins.indexOf(plugin) === -1) {
          plugins.push(plugin);
        }
      }
      return plugins;
    }
    function getOpts(options, all) {
      if (!all && options === false) {
        return null;
      }
      if (options === true) {
        return {};
      }
      return options;
    }
    function createDescriptors(chart, plugins, options, all) {
      const result = [];
      const context = chart.getContext();
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) {
          continue;
        }
        result.push({
          plugin,
          options: pluginOpts(chart.config, plugin, opts, context)
        });
      }
      return result;
    }
    function pluginOpts(config, plugin, opts, context) {
      const keys = config.pluginScopeKeys(plugin);
      const scopes = config.getOptionScopes(opts, keys);
      return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});
    }

    function getIndexAxis(type, options) {
      const datasetDefaults = defaults.datasets[type] || {};
      const datasetOptions = (options.datasets || {})[type] || {};
      return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
    }
    function getAxisFromDefaultScaleID(id, indexAxis) {
      let axis = id;
      if (id === '_index_') {
        axis = indexAxis;
      } else if (id === '_value_') {
        axis = indexAxis === 'x' ? 'y' : 'x';
      }
      return axis;
    }
    function getDefaultScaleIDFromAxis(axis, indexAxis) {
      return axis === indexAxis ? '_index_' : '_value_';
    }
    function axisFromPosition(position) {
      if (position === 'top' || position === 'bottom') {
        return 'x';
      }
      if (position === 'left' || position === 'right') {
        return 'y';
      }
    }
    function determineAxis(id, scaleOptions) {
      if (id === 'x' || id === 'y') {
        return id;
      }
      return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
    }
    function mergeScaleConfig(config, options) {
      const chartDefaults = overrides[config.type] || {scales: {}};
      const configScales = options.scales || {};
      const chartIndexAxis = getIndexAxis(config.type, options);
      const firstIDs = Object.create(null);
      const scales = Object.create(null);
      Object.keys(configScales).forEach(id => {
        const scaleConf = configScales[id];
        if (!isObject(scaleConf)) {
          return console.error(`Invalid scale configuration for scale: ${id}`);
        }
        if (scaleConf._proxy) {
          return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        }
        const axis = determineAxis(id, scaleConf);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        firstIDs[axis] = firstIDs[axis] || id;
        scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
      });
      config.data.datasets.forEach(dataset => {
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = overrides[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach(defaultID => {
          const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
          const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
          scales[id] = scales[id] || Object.create(null);
          mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
        });
      });
      Object.keys(scales).forEach(key => {
        const scale = scales[key];
        mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
      });
      return scales;
    }
    function initOptions(config) {
      const options = config.options || (config.options = {});
      options.plugins = valueOrDefault(options.plugins, {});
      options.scales = mergeScaleConfig(config, options);
    }
    function initData(data) {
      data = data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      return data;
    }
    function initConfig(config) {
      config = config || {};
      config.data = initData(config.data);
      initOptions(config);
      return config;
    }
    const keyCache = new Map();
    const keysCached = new Set();
    function cachedKeys(cacheKey, generate) {
      let keys = keyCache.get(cacheKey);
      if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
      }
      return keys;
    }
    const addIfFound = (set, obj, key) => {
      const opts = resolveObjectKey(obj, key);
      if (opts !== undefined) {
        set.add(opts);
      }
    };
    class Config {
      constructor(config) {
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
      }
      get platform() {
        return this._config.platform;
      }
      get type() {
        return this._config.type;
      }
      set type(type) {
        this._config.type = type;
      }
      get data() {
        return this._config.data;
      }
      set data(data) {
        this._config.data = initData(data);
      }
      get options() {
        return this._config.options;
      }
      set options(options) {
        this._config.options = options;
      }
      get plugins() {
        return this._config.plugins;
      }
      update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
      }
      clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
      }
      datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType,
          () => [[
            `datasets.${datasetType}`,
            ''
          ]]);
      }
      datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`,
          () => [
            [
              `datasets.${datasetType}.transitions.${transition}`,
              `transitions.${transition}`,
            ],
            [
              `datasets.${datasetType}`,
              ''
            ]
          ]);
      }
      datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`,
          () => [[
            `datasets.${datasetType}.elements.${elementType}`,
            `datasets.${datasetType}`,
            `elements.${elementType}`,
            ''
          ]]);
      }
      pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`,
          () => [[
            `plugins.${id}`,
            ...plugin.additionalOptionScopes || [],
          ]]);
      }
      _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
          cache = new Map();
          _scopeCache.set(mainScope, cache);
        }
        return cache;
      }
      getOptionScopes(mainScope, keyLists, resetCache) {
        const {options, type} = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) {
          return cached;
        }
        const scopes = new Set();
        keyLists.forEach(keys => {
          if (mainScope) {
            scopes.add(mainScope);
            keys.forEach(key => addIfFound(scopes, mainScope, key));
          }
          keys.forEach(key => addIfFound(scopes, options, key));
          keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));
          keys.forEach(key => addIfFound(scopes, defaults, key));
          keys.forEach(key => addIfFound(scopes, descriptors, key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) {
          array.push(Object.create(null));
        }
        if (keysCached.has(keyLists)) {
          cache.set(keyLists, array);
        }
        return array;
      }
      chartOptionScopes() {
        const {options, type} = this;
        return [
          options,
          overrides[type] || {},
          defaults.datasets[type] || {},
          {type},
          defaults,
          descriptors
        ];
      }
      resolveNamedOptions(scopes, names, context, prefixes = ['']) {
        const result = {$shared: true};
        const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names)) {
          result.$shared = false;
          context = isFunction(context) ? context() : context;
          const subResolver = this.createResolver(scopes, context, subPrefixes);
          options = _attachContext(resolver, context, subResolver);
        }
        for (const prop of names) {
          result[prop] = options[prop];
        }
        return result;
      }
      createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
        const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
        return isObject(context)
          ? _attachContext(resolver, context, undefined, descriptorDefaults)
          : resolver;
      }
    }
    function getResolver(resolverCache, scopes, prefixes) {
      let cache = resolverCache.get(scopes);
      if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
      }
      const cacheKey = prefixes.join();
      let cached = cache.get(cacheKey);
      if (!cached) {
        const resolver = _createResolver(scopes, prefixes);
        cached = {
          resolver,
          subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
        };
        cache.set(cacheKey, cached);
      }
      return cached;
    }
    const hasFunction = value => isObject(value)
      && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
    function needContext(proxy, names) {
      const {isScriptable, isIndexable} = _descriptors(proxy);
      for (const prop of names) {
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if ((scriptable && (isFunction(value) || hasFunction(value)))
          || (indexable && isArray(value))) {
          return true;
        }
      }
      return false;
    }

    var version = "3.6.0";

    const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
    function positionIsHorizontal(position, axis) {
      return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');
    }
    function compare2Level(l1, l2) {
      return function(a, b) {
        return a[l1] === b[l1]
          ? a[l2] - b[l2]
          : a[l1] - b[l1];
      };
    }
    function onAnimationsComplete(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      chart.notifyPlugins('afterRender');
      callback(animationOptions && animationOptions.onComplete, [context], chart);
    }
    function onAnimationProgress(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      callback(animationOptions && animationOptions.onProgress, [context], chart);
    }
    function getCanvas(item) {
      if (_isDomSupported() && typeof item === 'string') {
        item = document.getElementById(item);
      } else if (item && item.length) {
        item = item[0];
      }
      if (item && item.canvas) {
        item = item.canvas;
      }
      return item;
    }
    const instances = {};
    const getChart = (key) => {
      const canvas = getCanvas(key);
      return Object.values(instances).filter((c) => c.canvas === canvas).pop();
    };
    class Chart {
      constructor(item, userConfig) {
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) {
          throw new Error(
            'Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' +
    				' must be destroyed before the canvas can be reused.'
          );
        }
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = uid();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
        this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);
        instances[this.id] = this;
        if (!context || !canvas) {
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }
        animator.listen(this, 'complete', onAnimationsComplete);
        animator.listen(this, 'progress', onAnimationProgress);
        this._initialize();
        if (this.attached) {
          this.update();
        }
      }
      get aspectRatio() {
        const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
        if (!isNullOrUndef(aspectRatio)) {
          return aspectRatio;
        }
        if (maintainAspectRatio && _aspectRatio) {
          return _aspectRatio;
        }
        return height ? width / height : null;
      }
      get data() {
        return this.config.data;
      }
      set data(data) {
        this.config.data = data;
      }
      get options() {
        return this._options;
      }
      set options(options) {
        this.config.options = options;
      }
      _initialize() {
        this.notifyPlugins('beforeInit');
        if (this.options.responsive) {
          this.resize();
        } else {
          retinaScale(this, this.options.devicePixelRatio);
        }
        this.bindEvents();
        this.notifyPlugins('afterInit');
        return this;
      }
      clear() {
        clearCanvas(this.canvas, this.ctx);
        return this;
      }
      stop() {
        animator.stop(this);
        return this;
      }
      resize(width, height) {
        if (!animator.running(this)) {
          this._resize(width, height);
        } else {
          this._resizeBeforeDraw = {width, height};
        }
      }
      _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? 'resize' : 'attach';
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!retinaScale(this, newRatio, true)) {
          return;
        }
        this.notifyPlugins('resize', {size: newSize});
        callback(options.onResize, [this, newSize], this);
        if (this.attached) {
          if (this._doResize(mode)) {
            this.render();
          }
        }
      }
      ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        each(scalesOptions, (axisOptions, axisID) => {
          axisOptions.id = axisID;
        });
      }
      buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id) => {
          obj[id] = false;
          return obj;
        }, {});
        let items = [];
        if (scaleOpts) {
          items = items.concat(
            Object.keys(scaleOpts).map((id) => {
              const scaleOptions = scaleOpts[id];
              const axis = determineAxis(id, scaleOptions);
              const isRadial = axis === 'r';
              const isHorizontal = axis === 'x';
              return {
                options: scaleOptions,
                dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
              };
            })
          );
        }
        each(items, (item) => {
          const scaleOptions = item.options;
          const id = scaleOptions.id;
          const axis = determineAxis(id, scaleOptions);
          const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
          if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }
          updated[id] = true;
          let scale = null;
          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
          } else {
            const scaleClass = registry.getScale(scaleType);
            scale = new scaleClass({
              id,
              type: scaleType,
              ctx: this.ctx,
              chart: this
            });
            scales[scale.id] = scale;
          }
          scale.init(scaleOptions, options);
        });
        each(updated, (hasUpdated, id) => {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        each(scales, (scale) => {
          layouts.configure(this, scale, scale.options);
          layouts.addBox(this, scale);
        });
      }
      _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b) => a.index - b.index);
        if (numMeta > numData) {
          for (let i = numData; i < numMeta; ++i) {
            this._destroyDatasetMeta(i);
          }
          metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
      }
      _removeUnreferencedMetasets() {
        const {_metasets: metasets, data: {datasets}} = this;
        if (metasets.length > datasets.length) {
          delete this._stacks;
        }
        metasets.forEach((meta, index) => {
          if (datasets.filter(x => x === meta._dataset).length === 0) {
            this._destroyDatasetMeta(index);
          }
        });
      }
      buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for (i = 0, ilen = datasets.length; i < ilen; i++) {
          const dataset = datasets[i];
          let meta = this.getDatasetMeta(i);
          const type = dataset.type || this.config.type;
          if (meta.type && meta.type !== type) {
            this._destroyDatasetMeta(i);
            meta = this.getDatasetMeta(i);
          }
          meta.type = type;
          meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
          meta.order = dataset.order || 0;
          meta.index = i;
          meta.label = '' + dataset.label;
          meta.visible = this.isDatasetVisible(i);
          if (meta.controller) {
            meta.controller.updateIndex(i);
            meta.controller.linkScales();
          } else {
            const ControllerClass = registry.getController(type);
            const {datasetElementType, dataElementType} = defaults.datasets[type];
            Object.assign(ControllerClass.prototype, {
              dataElementType: registry.getElement(dataElementType),
              datasetElementType: datasetElementType && registry.getElement(datasetElementType)
            });
            meta.controller = new ControllerClass(this, i);
            newControllers.push(meta.controller);
          }
        }
        this._updateMetasets();
        return newControllers;
      }
      _resetElements() {
        each(this.data.datasets, (dataset, datasetIndex) => {
          this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
      }
      reset() {
        this._resetElements();
        this.notifyPlugins('reset');
      }
      update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        each(this.scales, (scale) => {
          layouts.removeBox(this, scale);
        });
        const animsDisabled = this._animationsDisabled = !options.animation;
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
          this.unbindEvents();
          this.bindEvents();
        }
        this._plugins.invalidate();
        if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {
          return;
        }
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins('beforeElementsUpdate');
        let minPadding = 0;
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
          const {controller} = this.getDatasetMeta(i);
          const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
          controller.buildOrUpdateElements(reset);
          minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) {
          each(newControllers, (controller) => {
            controller.reset();
          });
        }
        this._updateDatasets(mode);
        this.notifyPlugins('afterUpdate', {mode});
        this._layers.sort(compare2Level('z', '_idx'));
        if (this._lastEvent) {
          this._eventHandler(this._lastEvent, true);
        }
        this.render();
      }
      _updateLayout(minPadding) {
        if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {
          return;
        }
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        each(this.boxes, (box) => {
          if (noArea && box.position === 'chartArea') {
            return;
          }
          if (box.configure) {
            box.configure();
          }
          this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index) => {
          item._idx = index;
        });
        this.notifyPlugins('afterLayout');
      }
      _updateDatasets(mode) {
        if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {
          return;
        }
        for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);
        }
        this.notifyPlugins('afterDatasetsUpdate', {mode});
      }
      _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {meta, index, mode, cancelable: true};
        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
          return;
        }
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins('afterDatasetUpdate', args);
      }
      render() {
        if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {
          return;
        }
        if (animator.has(this)) {
          if (this.attached && !animator.running(this)) {
            animator.start(this);
          }
        } else {
          this.draw();
          onAnimationsComplete({chart: this});
        }
      }
      draw() {
        let i;
        if (this._resizeBeforeDraw) {
          const {width, height} = this._resizeBeforeDraw;
          this._resize(width, height);
          this._resizeBeforeDraw = null;
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) {
          return;
        }
        if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {
          return;
        }
        const layers = this._layers;
        for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
          layers[i].draw(this.chartArea);
        }
        this._drawDatasets();
        for (; i < layers.length; ++i) {
          layers[i].draw(this.chartArea);
        }
        this.notifyPlugins('afterDraw');
      }
      _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          const meta = metasets[i];
          if (!filterVisible || meta.visible) {
            result.push(meta);
          }
        }
        return result;
      }
      getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
      }
      _drawDatasets() {
        if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {
          return;
        }
        const metasets = this.getSortedVisibleDatasetMetas();
        for (let i = metasets.length - 1; i >= 0; --i) {
          this._drawDataset(metasets[i]);
        }
        this.notifyPlugins('afterDatasetsDraw');
      }
      _drawDataset(meta) {
        const ctx = this.ctx;
        const clip = meta._clip;
        const useClip = !clip.disabled;
        const area = this.chartArea;
        const args = {
          meta,
          index: meta.index,
          cancelable: true
        };
        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
          return;
        }
        if (useClip) {
          clipArea(ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? this.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
          });
        }
        meta.controller.draw();
        if (useClip) {
          unclipArea(ctx);
        }
        args.cancelable = false;
        this.notifyPlugins('afterDatasetDraw', args);
      }
      getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === 'function') {
          return method(this, e, options, useFinalPosition);
        }
        return [];
      }
      getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter(x => x && x._dataset === dataset).pop();
        if (!meta) {
          meta = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: dataset && dataset.order || 0,
            index: datasetIndex,
            _dataset: dataset,
            _parsed: [],
            _sorted: false
          };
          metasets.push(meta);
        }
        return meta;
      }
      getContext() {
        return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));
      }
      getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
      }
      isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) {
          return false;
        }
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
      }
      setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
      }
      toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
      }
      getDataVisibility(index) {
        return !this._hiddenIndices[index];
      }
      _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? 'show' : 'hide';
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(undefined, mode);
        if (defined(dataIndex)) {
          meta.data[dataIndex].hidden = !visible;
          this.update();
        } else {
          this.setDatasetVisibility(datasetIndex, visible);
          anims.update(meta, {visible});
          this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);
        }
      }
      hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
      }
      show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
      }
      _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) {
          meta.controller._destroy();
        }
        delete this._metasets[datasetIndex];
      }
      _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          this._destroyDatasetMeta(i);
        }
      }
      destroy() {
        const {canvas, ctx} = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
          this.unbindEvents();
          clearCanvas(canvas, ctx);
          this.platform.releaseContext(ctx);
          this.canvas = null;
          this.ctx = null;
        }
        this.notifyPlugins('destroy');
        delete instances[this.id];
      }
      toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
      }
      bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) {
          this.bindResponsiveEvents();
        } else {
          this.attached = true;
        }
      }
      bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener) => {
          platform.addEventListener(this, type, listener);
          listeners[type] = listener;
        };
        const listener = (e, x, y) => {
          e.offsetX = x;
          e.offsetY = y;
          this._eventHandler(e);
        };
        each(this.options.events, (type) => _add(type, listener));
      }
      bindResponsiveEvents() {
        if (!this._responsiveListeners) {
          this._responsiveListeners = {};
        }
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener) => {
          platform.addEventListener(this, type, listener);
          listeners[type] = listener;
        };
        const _remove = (type, listener) => {
          if (listeners[type]) {
            platform.removeEventListener(this, type, listener);
            delete listeners[type];
          }
        };
        const listener = (width, height) => {
          if (this.canvas) {
            this.resize(width, height);
          }
        };
        let detached;
        const attached = () => {
          _remove('attach', attached);
          this.attached = true;
          this.resize();
          _add('resize', listener);
          _add('detach', detached);
        };
        detached = () => {
          this.attached = false;
          _remove('resize', listener);
          this._stop();
          this._resize(0, 0);
          _add('attach', attached);
        };
        if (platform.isAttached(this.canvas)) {
          attached();
        } else {
          detached();
        }
      }
      unbindEvents() {
        each(this._listeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        each(this._responsiveListeners, (listener, type) => {
          this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = undefined;
      }
      updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? 'set' : 'remove';
        let meta, item, i, ilen;
        if (mode === 'dataset') {
          meta = this.getDatasetMeta(items[0].datasetIndex);
          meta.controller['_' + prefix + 'DatasetHoverStyle']();
        }
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          item = items[i];
          const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
          if (controller) {
            controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
          }
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({datasetIndex, index}) => {
          const meta = this.getDatasetMeta(datasetIndex);
          if (!meta) {
            throw new Error('No dataset found at index ' + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta.data[index],
            index,
          };
        });
        const changed = !_elementsEqual(active, lastActive);
        if (changed) {
          this._active = active;
          this._updateHoverStyles(active, lastActive);
        }
      }
      notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
      }
      _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) {
          this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        }
        if (activated.length && hoverOptions.mode) {
          this.updateHoverStyle(activated, hoverOptions.mode, true);
        }
      }
      _eventHandler(e, replay) {
        const args = {event: e, replay, cancelable: true};
        const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
          return;
        }
        const changed = this._handleEvent(e, replay);
        args.cancelable = false;
        this.notifyPlugins('afterEvent', args, eventFilter);
        if (changed || args.changed) {
          this.render();
        }
        return this;
      }
      _handleEvent(e, replay) {
        const {_active: lastActive = [], options} = this;
        const hoverOptions = options.hover;
        const useFinalPosition = replay;
        let active = [];
        let changed = false;
        let lastEvent = null;
        if (e.type !== 'mouseout') {
          active = this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
          lastEvent = e.type === 'click' ? this._lastEvent : e;
        }
        this._lastEvent = null;
        if (_isPointInArea(e, this.chartArea, this._minPadding)) {
          callback(options.onHover, [e, active, this], this);
          if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {
            callback(options.onClick, [e, active, this], this);
          }
        }
        changed = !_elementsEqual(active, lastActive);
        if (changed || replay) {
          this._active = active;
          this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
      }
    }
    const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
    const enumerable = true;
    Object.defineProperties(Chart, {
      defaults: {
        enumerable,
        value: defaults
      },
      instances: {
        enumerable,
        value: instances
      },
      overrides: {
        enumerable,
        value: overrides
      },
      registry: {
        enumerable,
        value: registry
      },
      version: {
        enumerable,
        value: version
      },
      getChart: {
        enumerable,
        value: getChart
      },
      register: {
        enumerable,
        value: (...items) => {
          registry.add(...items);
          invalidatePlugins();
        }
      },
      unregister: {
        enumerable,
        value: (...items) => {
          registry.remove(...items);
          invalidatePlugins();
        }
      }
    });

    function clipArc(ctx, element, endAngle) {
      const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
      let angleMargin = pixelMargin / outerRadius;
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
      if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
      } else {
        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
      }
      ctx.closePath();
      ctx.clip();
    }
    function toRadiusCorners(value) {
      return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
    }
    function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
      const o = toRadiusCorners(arc.options.borderRadius);
      const halfThickness = (outerRadius - innerRadius) / 2;
      const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
      const computeOuterLimit = (val) => {
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
      };
      return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: _limitValue(o.innerStart, 0, innerLimit),
        innerEnd: _limitValue(o.innerEnd, 0, innerLimit),
      };
    }
    function rThetaToXY(r, theta, x, y) {
      return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta),
      };
    }
    function pathArc(ctx, element, offset, spacing, end) {
      const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
      const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
      const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
      let spacingOffset = 0;
      const alpha = end - start;
      if (spacing) {
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
      }
      const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
      const angleOffset = (alpha - beta) / 2;
      const startAngle = start + angleOffset + spacingOffset;
      const endAngle = end - angleOffset - spacingOffset;
      const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
      const outerStartAdjustedRadius = outerRadius - outerStart;
      const outerEndAdjustedRadius = outerRadius - outerEnd;
      const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
      const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
      const innerStartAdjustedRadius = innerRadius + innerStart;
      const innerEndAdjustedRadius = innerRadius + innerEnd;
      const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
      const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
      ctx.closePath();
    }
    function drawArc(ctx, element, offset, spacing) {
      const {fullCircles, startAngle, circumference} = element;
      let endAngle = element.endAngle;
      if (fullCircles) {
        pathArc(ctx, element, offset, spacing, startAngle + TAU);
        for (let i = 0; i < fullCircles; ++i) {
          ctx.fill();
        }
        if (!isNaN(circumference)) {
          endAngle = startAngle + circumference % TAU;
          if (circumference % TAU === 0) {
            endAngle += TAU;
          }
        }
      }
      pathArc(ctx, element, offset, spacing, endAngle);
      ctx.fill();
      return endAngle;
    }
    function drawFullCircleBorders(ctx, element, inner) {
      const {x, y, startAngle, pixelMargin, fullCircles} = element;
      const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
      const innerRadius = element.innerRadius + pixelMargin;
      let i;
      if (inner) {
        clipArc(ctx, element, startAngle + TAU);
      }
      ctx.beginPath();
      ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
      for (i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
      for (i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
    }
    function drawBorder(ctx, element, offset, spacing, endAngle) {
      const {options} = element;
      const inner = options.borderAlign === 'inner';
      if (!options.borderWidth) {
        return;
      }
      if (inner) {
        ctx.lineWidth = options.borderWidth * 2;
        ctx.lineJoin = 'round';
      } else {
        ctx.lineWidth = options.borderWidth;
        ctx.lineJoin = 'bevel';
      }
      if (element.fullCircles) {
        drawFullCircleBorders(ctx, element, inner);
      }
      if (inner) {
        clipArc(ctx, element, endAngle);
      }
      pathArc(ctx, element, offset, spacing, endAngle);
      ctx.stroke();
    }
    class ArcElement extends Element {
      constructor(cfg) {
        super();
        this.options = undefined;
        this.circumference = undefined;
        this.startAngle = undefined;
        this.endAngle = undefined;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps(['x', 'y'], useFinalPosition);
        const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});
        const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
          'startAngle',
          'endAngle',
          'innerRadius',
          'outerRadius',
          'circumference'
        ], useFinalPosition);
        const rAdjust = this.options.spacing / 2;
        const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
        const withinRadius = (distance >= innerRadius + rAdjust && distance <= outerRadius + rAdjust);
        return (betweenAngles && withinRadius);
      }
      getCenterPoint(useFinalPosition) {
        const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
          'x',
          'y',
          'startAngle',
          'endAngle',
          'innerRadius',
          'outerRadius',
          'circumference',
        ], useFinalPosition);
        const {offset, spacing} = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
          x: x + Math.cos(halfAngle) * halfRadius,
          y: y + Math.sin(halfAngle) * halfRadius
        };
      }
      tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
      }
      draw(ctx) {
        const {options, circumference} = this;
        const offset = (options.offset || 0) / 2;
        const spacing = (options.spacing || 0) / 2;
        this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;
        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
          return;
        }
        ctx.save();
        let radiusOffset = 0;
        if (offset) {
          radiusOffset = offset / 2;
          const halfAngle = (this.startAngle + this.endAngle) / 2;
          ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
          if (this.circumference >= PI) {
            radiusOffset = offset;
          }
        }
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        const endAngle = drawArc(ctx, this, radiusOffset, spacing);
        drawBorder(ctx, this, radiusOffset, spacing, endAngle);
        ctx.restore();
      }
    }
    ArcElement.id = 'arc';
    ArcElement.defaults = {
      borderAlign: 'center',
      borderColor: '#fff',
      borderRadius: 0,
      borderWidth: 2,
      offset: 0,
      spacing: 0,
      angle: undefined,
    };
    ArcElement.defaultRoutes = {
      backgroundColor: 'backgroundColor'
    };

    function setStyle(ctx, options, style = options) {
      ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
      ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
      ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
      ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
      ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
      ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
    }
    function lineTo(ctx, previous, target) {
      ctx.lineTo(target.x, target.y);
    }
    function getLineMethod(options) {
      if (options.stepped) {
        return _steppedLineTo;
      }
      if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return _bezierCurveTo;
      }
      return lineTo;
    }
    function pathVars(points, segment, params = {}) {
      const count = points.length;
      const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
      const {start: segmentStart, end: segmentEnd} = segment;
      const start = Math.max(paramsStart, segmentStart);
      const end = Math.min(paramsEnd, segmentEnd);
      const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
      return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
      };
    }
    function pathSegment(ctx, line, segment, params) {
      const {points, options} = line;
      const {count, start, loop, ilen} = pathVars(points, segment, params);
      const lineMethod = getLineMethod(options);
      let {move = true, reverse} = params || {};
      let i, point, prev;
      for (i = 0; i <= ilen; ++i) {
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) {
          continue;
        } else if (move) {
          ctx.moveTo(point.x, point.y);
          move = false;
        } else {
          lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        prev = point;
      }
      if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      return !!loop;
    }
    function fastPathSegment(ctx, line, segment, params) {
      const points = line.points;
      const {count, start, ilen} = pathVars(points, segment, params);
      const {move = true, reverse} = params || {};
      let avgX = 0;
      let countX = 0;
      let i, point, prevX, minY, maxY, lastY;
      const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
      const drawX = () => {
        if (minY !== maxY) {
          ctx.lineTo(avgX, maxY);
          ctx.lineTo(avgX, minY);
          ctx.lineTo(avgX, lastY);
        }
      };
      if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
      }
      for (i = 0; i <= ilen; ++i) {
        point = points[pointIndex(i)];
        if (point.skip) {
          continue;
        }
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
          if (y < minY) {
            minY = y;
          } else if (y > maxY) {
            maxY = y;
          }
          avgX = (countX * avgX + x) / ++countX;
        } else {
          drawX();
          ctx.lineTo(x, y);
          prevX = truncX;
          countX = 0;
          minY = maxY = y;
        }
        lastY = y;
      }
      drawX();
    }
    function _getSegmentMethod(line) {
      const opts = line.options;
      const borderDash = opts.borderDash && opts.borderDash.length;
      const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
      return useFastPath ? fastPathSegment : pathSegment;
    }
    function _getInterpolationMethod(options) {
      if (options.stepped) {
        return _steppedInterpolation;
      }
      if (options.tension || options.cubicInterpolationMode === 'monotone') {
        return _bezierInterpolation;
      }
      return _pointInLine;
    }
    function strokePathWithCache(ctx, line, start, count) {
      let path = line._path;
      if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) {
          path.closePath();
        }
      }
      setStyle(ctx, line.options);
      ctx.stroke(path);
    }
    function strokePathDirect(ctx, line, start, count) {
      const {segments, options} = line;
      const segmentMethod = _getSegmentMethod(line);
      for (const segment of segments) {
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
          ctx.closePath();
        }
        ctx.stroke();
      }
    }
    const usePath2D = typeof Path2D === 'function';
    function draw(ctx, line, start, count) {
      if (usePath2D && !line.options.segment) {
        strokePathWithCache(ctx, line, start, count);
      } else {
        strokePathDirect(ctx, line, start, count);
      }
    }
    class LineElement extends Element {
      constructor(cfg) {
        super();
        this.animated = true;
        this.options = undefined;
        this._chart = undefined;
        this._loop = undefined;
        this._fullLoop = undefined;
        this._path = undefined;
        this._points = undefined;
        this._segments = undefined;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = undefined;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
          const loop = options.spanGaps ? this._loop : this._fullLoop;
          _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
          this._pointsUpdated = true;
        }
      }
      set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
      }
      get points() {
        return this._points;
      }
      get segments() {
        return this._segments || (this._segments = _computeSegments(this, this.options.segment));
      }
      first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
      }
      last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
      }
      interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = _boundSegments(this, {property, start: value, end: value});
        if (!segments.length) {
          return;
        }
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for (i = 0, ilen = segments.length; i < ilen; ++i) {
          const {start, end} = segments[i];
          const p1 = points[start];
          const p2 = points[end];
          if (p1 === p2) {
            result.push(p1);
            continue;
          }
          const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
          const interpolated = _interpolate(p1, p2, t, options.stepped);
          interpolated[property] = point[property];
          result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
      }
      pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
      }
      path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || (this.points.length - start);
        for (const segment of segments) {
          loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});
        }
        return !!loop;
      }
      draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
          ctx.save();
          draw(ctx, this, start, count);
          ctx.restore();
        }
        if (this.animated) {
          this._pointsUpdated = false;
          this._path = undefined;
        }
      }
    }
    LineElement.id = 'line';
    LineElement.defaults = {
      borderCapStyle: 'butt',
      borderDash: [],
      borderDashOffset: 0,
      borderJoinStyle: 'miter',
      borderWidth: 3,
      capBezierPoints: true,
      cubicInterpolationMode: 'default',
      fill: false,
      spanGaps: false,
      stepped: false,
      tension: 0,
    };
    LineElement.defaultRoutes = {
      backgroundColor: 'backgroundColor',
      borderColor: 'borderColor'
    };
    LineElement.descriptors = {
      _scriptable: true,
      _indexable: (name) => name !== 'borderDash' && name !== 'fill',
    };

    function inRange$1(el, pos, axis, useFinalPosition) {
      const options = el.options;
      const {[axis]: value} = el.getProps([axis], useFinalPosition);
      return (Math.abs(pos - value) < options.radius + options.hitRadius);
    }
    class PointElement extends Element {
      constructor(cfg) {
        super();
        this.options = undefined;
        this.parsed = undefined;
        this.skip = undefined;
        this.stop = undefined;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
        return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));
      }
      inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, 'x', useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, 'y', useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
        const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
        return {x, y};
      }
      size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
      }
      draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
          return;
        }
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        drawPoint(ctx, options, this.x, this.y);
      }
      getRange() {
        const options = this.options || {};
        return options.radius + options.hitRadius;
      }
    }
    PointElement.id = 'point';
    PointElement.defaults = {
      borderWidth: 1,
      hitRadius: 1,
      hoverBorderWidth: 1,
      hoverRadius: 4,
      pointStyle: 'circle',
      radius: 3,
      rotation: 0
    };
    PointElement.defaultRoutes = {
      backgroundColor: 'backgroundColor',
      borderColor: 'borderColor'
    };

    function getBarBounds(bar, useFinalPosition) {
      const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
      let left, right, top, bottom, half;
      if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
      } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
      }
      return {left, top, right, bottom};
    }
    function skipOrLimit(skip, value, min, max) {
      return skip ? 0 : _limitValue(value, min, max);
    }
    function parseBorderWidth(bar, maxW, maxH) {
      const value = bar.options.borderWidth;
      const skip = bar.borderSkipped;
      const o = toTRBL(value);
      return {
        t: skipOrLimit(skip.top, o.top, 0, maxH),
        r: skipOrLimit(skip.right, o.right, 0, maxW),
        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip.left, o.left, 0, maxW)
      };
    }
    function parseBorderRadius(bar, maxW, maxH) {
      const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);
      const value = bar.options.borderRadius;
      const o = toTRBLCorners(value);
      const maxR = Math.min(maxW, maxH);
      const skip = bar.borderSkipped;
      const enableBorder = enableBorderRadius || isObject(value);
      return {
        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
      };
    }
    function boundingRects(bar) {
      const bounds = getBarBounds(bar);
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      const border = parseBorderWidth(bar, width / 2, height / 2);
      const radius = parseBorderRadius(bar, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height,
          radius
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b,
          radius: {
            topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
            topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
            bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
            bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),
          }
        }
      };
    }
    function inRange(bar, x, y, useFinalPosition) {
      const skipX = x === null;
      const skipY = y === null;
      const skipBoth = skipX && skipY;
      const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
      return bounds
    		&& (skipX || x >= bounds.left && x <= bounds.right)
    		&& (skipY || y >= bounds.top && y <= bounds.bottom);
    }
    function hasRadius(radius) {
      return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
    }
    function addNormalRectPath(ctx, rect) {
      ctx.rect(rect.x, rect.y, rect.w, rect.h);
    }
    function inflateRect(rect, amount, refRect = {}) {
      const x = rect.x !== refRect.x ? -amount : 0;
      const y = rect.y !== refRect.y ? -amount : 0;
      const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
      const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
      return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
      };
    }
    class BarElement extends Element {
      constructor(cfg) {
        super();
        this.options = undefined;
        this.horizontal = undefined;
        this.base = undefined;
        this.width = undefined;
        this.height = undefined;
        this.inflateAmount = undefined;
        if (cfg) {
          Object.assign(this, cfg);
        }
      }
      draw(ctx) {
        const {inflateAmount, options: {borderColor, backgroundColor}} = this;
        const {inner, outer} = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
          ctx.beginPath();
          addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
          ctx.clip();
          addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
          ctx.fillStyle = borderColor;
          ctx.fill('evenodd');
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
      inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
      }
      inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
        const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
        return {
          x: horizontal ? (x + base) / 2 : x,
          y: horizontal ? y : (y + base) / 2
        };
      }
      getRange(axis) {
        return axis === 'x' ? this.width / 2 : this.height / 2;
      }
    }
    BarElement.id = 'bar';
    BarElement.defaults = {
      borderSkipped: 'start',
      borderWidth: 0,
      borderRadius: 0,
      inflateAmount: 'auto',
      pointStyle: undefined
    };
    BarElement.defaultRoutes = {
      backgroundColor: 'backgroundColor',
      borderColor: 'borderColor'
    };

    var elements = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ArcElement: ArcElement,
    LineElement: LineElement,
    PointElement: PointElement,
    BarElement: BarElement
    });

    function lttbDecimation(data, start, count, availableWidth, options) {
      const samples = options.samples || availableWidth;
      if (samples >= count) {
        return data.slice(start, start + count);
      }
      const decimated = [];
      const bucketWidth = (count - 2) / (samples - 2);
      let sampledIndex = 0;
      const endIndex = start + count - 1;
      let a = start;
      let i, maxAreaPoint, maxArea, area, nextA;
      decimated[sampledIndex++] = data[a];
      for (i = 0; i < samples - 2; i++) {
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for (j = avgRangeStart; j < avgRangeEnd; j++) {
          avgX += data[j].x;
          avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const {x: pointAx, y: pointAy} = data[a];
        maxArea = area = -1;
        for (j = rangeOffs; j < rangeTo; j++) {
          area = 0.5 * Math.abs(
            (pointAx - avgX) * (data[j].y - pointAy) -
            (pointAx - data[j].x) * (avgY - pointAy)
          );
          if (area > maxArea) {
            maxArea = area;
            maxAreaPoint = data[j];
            nextA = j;
          }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
      }
      decimated[sampledIndex++] = data[endIndex];
      return decimated;
    }
    function minMaxDecimation(data, start, count, availableWidth) {
      let avgX = 0;
      let countX = 0;
      let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
      const decimated = [];
      const endIndex = start + count - 1;
      const xMin = data[start].x;
      const xMax = data[endIndex].x;
      const dx = xMax - xMin;
      for (i = start; i < start + count; ++i) {
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
          if (y < minY) {
            minY = y;
            minIndex = i;
          } else if (y > maxY) {
            maxY = y;
            maxIndex = i;
          }
          avgX = (countX * avgX + point.x) / ++countX;
        } else {
          const lastIndex = i - 1;
          if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
            const intermediateIndex1 = Math.min(minIndex, maxIndex);
            const intermediateIndex2 = Math.max(minIndex, maxIndex);
            if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
              decimated.push({
                ...data[intermediateIndex1],
                x: avgX,
              });
            }
            if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
              decimated.push({
                ...data[intermediateIndex2],
                x: avgX
              });
            }
          }
          if (i > 0 && lastIndex !== startIndex) {
            decimated.push(data[lastIndex]);
          }
          decimated.push(point);
          prevX = truncX;
          countX = 0;
          minY = maxY = y;
          minIndex = maxIndex = startIndex = i;
        }
      }
      return decimated;
    }
    function cleanDecimatedDataset(dataset) {
      if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, 'data', {value: data});
      }
    }
    function cleanDecimatedData(chart) {
      chart.data.datasets.forEach((dataset) => {
        cleanDecimatedDataset(dataset);
      });
    }
    function getStartAndCountOfVisiblePointsSimplified(meta, points) {
      const pointCount = points.length;
      let start = 0;
      let count;
      const {iScale} = meta;
      const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
      if (minDefined) {
        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
      }
      if (maxDefined) {
        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
      return {start, count};
    }
    var plugin_decimation = {
      id: 'decimation',
      defaults: {
        algorithm: 'min-max',
        enabled: false,
      },
      beforeElementsUpdate: (chart, args, options) => {
        if (!options.enabled) {
          cleanDecimatedData(chart);
          return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex) => {
          const {_data, indexAxis} = dataset;
          const meta = chart.getDatasetMeta(datasetIndex);
          const data = _data || dataset.data;
          if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {
            return;
          }
          if (meta.type !== 'line') {
            return;
          }
          const xAxis = chart.scales[meta.xAxisID];
          if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
            return;
          }
          if (chart.options.parsing) {
            return;
          }
          let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
          const threshold = options.threshold || 4 * availableWidth;
          if (count <= threshold) {
            cleanDecimatedDataset(dataset);
            return;
          }
          if (isNullOrUndef(_data)) {
            dataset._data = data;
            delete dataset.data;
            Object.defineProperty(dataset, 'data', {
              configurable: true,
              enumerable: true,
              get: function() {
                return this._decimated;
              },
              set: function(d) {
                this._data = d;
              }
            });
          }
          let decimated;
          switch (options.algorithm) {
          case 'lttb':
            decimated = lttbDecimation(data, start, count, availableWidth, options);
            break;
          case 'min-max':
            decimated = minMaxDecimation(data, start, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
          }
          dataset._decimated = decimated;
        });
      },
      destroy(chart) {
        cleanDecimatedData(chart);
      }
    };

    function getLineByIndex(chart, index) {
      const meta = chart.getDatasetMeta(index);
      const visible = meta && chart.isDatasetVisible(index);
      return visible ? meta.dataset : null;
    }
    function parseFillOption(line) {
      const options = line.options;
      const fillOption = options.fill;
      let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
      if (fill === undefined) {
        fill = !!options.backgroundColor;
      }
      if (fill === false || fill === null) {
        return false;
      }
      if (fill === true) {
        return 'origin';
      }
      return fill;
    }
    function decodeFill(line, index, count) {
      const fill = parseFillOption(line);
      if (isObject(fill)) {
        return isNaN(fill.value) ? false : fill;
      }
      let target = parseFloat(fill);
      if (isNumberFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }
        if (target === index || target < 0 || target >= count) {
          return false;
        }
        return target;
      }
      return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
    }
    function computeLinearBoundary(source) {
      const {scale = {}, fill} = source;
      let target = null;
      let horizontal;
      if (fill === 'start') {
        target = scale.bottom;
      } else if (fill === 'end') {
        target = scale.top;
      } else if (isObject(fill)) {
        target = scale.getPixelForValue(fill.value);
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }
      if (isNumberFinite(target)) {
        horizontal = scale.isHorizontal();
        return {
          x: horizontal ? target : null,
          y: horizontal ? null : target
        };
      }
      return null;
    }
    class simpleArc {
      constructor(opts) {
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
      }
      pathSegment(ctx, bounds, opts) {
        const {x, y, radius} = this;
        bounds = bounds || {start: 0, end: TAU};
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
      }
      interpolate(point) {
        const {x, y, radius} = this;
        const angle = point.angle;
        return {
          x: x + Math.cos(angle) * radius,
          y: y + Math.sin(angle) * radius,
          angle
        };
      }
    }
    function computeCircularBoundary(source) {
      const {scale, fill} = source;
      const options = scale.options;
      const length = scale.getLabels().length;
      const target = [];
      const start = options.reverse ? scale.max : scale.min;
      const end = options.reverse ? scale.min : scale.max;
      let i, center, value;
      if (fill === 'start') {
        value = start;
      } else if (fill === 'end') {
        value = end;
      } else if (isObject(fill)) {
        value = fill.value;
      } else {
        value = scale.getBaseValue();
      }
      if (options.grid.circular) {
        center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
          x: center.x,
          y: center.y,
          radius: scale.getDistanceFromCenterForValue(value)
        });
      }
      for (i = 0; i < length; ++i) {
        target.push(scale.getPointPositionForValue(i, value));
      }
      return target;
    }
    function computeBoundary(source) {
      const scale = source.scale || {};
      if (scale.getPointPositionForValue) {
        return computeCircularBoundary(source);
      }
      return computeLinearBoundary(source);
    }
    function findSegmentEnd(start, end, points) {
      for (;end > start; end--) {
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) {
          break;
        }
      }
      return end;
    }
    function pointsFromSegments(boundary, line) {
      const {x = null, y = null} = boundary || {};
      const linePoints = line.points;
      const points = [];
      line.segments.forEach(({start, end}) => {
        end = findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
          points.push({x: first.x, y});
          points.push({x: last.x, y});
        } else if (x !== null) {
          points.push({x, y: first.y});
          points.push({x, y: last.y});
        }
      });
      return points;
    }
    function buildStackLine(source) {
      const {scale, index, line} = source;
      const points = [];
      const segments = line.segments;
      const sourcePoints = line.points;
      const linesBelow = getLinesBelow(scale, index);
      linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        for (let j = segment.start; j <= segment.end; j++) {
          addPointsBelow(points, sourcePoints[j], linesBelow);
        }
      }
      return new LineElement({points, options: {}});
    }
    function getLinesBelow(scale, index) {
      const below = [];
      const metas = scale.getMatchingVisibleMetas('line');
      for (let i = 0; i < metas.length; i++) {
        const meta = metas[i];
        if (meta.index === index) {
          break;
        }
        if (!meta.hidden) {
          below.unshift(meta.dataset);
        }
      }
      return below;
    }
    function addPointsBelow(points, sourcePoint, linesBelow) {
      const postponed = [];
      for (let j = 0; j < linesBelow.length; j++) {
        const line = linesBelow[j];
        const {first, last, point} = findPoint(line, sourcePoint, 'x');
        if (!point || (first && last)) {
          continue;
        }
        if (first) {
          postponed.unshift(point);
        } else {
          points.push(point);
          if (!last) {
            break;
          }
        }
      }
      points.push(...postponed);
    }
    function findPoint(line, sourcePoint, property) {
      const point = line.interpolate(sourcePoint, property);
      if (!point) {
        return {};
      }
      const pointValue = point[property];
      const segments = line.segments;
      const linePoints = line.points;
      let first = false;
      let last = false;
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if (pointValue >= firstValue && pointValue <= lastValue) {
          first = pointValue === firstValue;
          last = pointValue === lastValue;
          break;
        }
      }
      return {first, last, point};
    }
    function getTarget(source) {
      const {chart, fill, line} = source;
      if (isNumberFinite(fill)) {
        return getLineByIndex(chart, fill);
      }
      if (fill === 'stack') {
        return buildStackLine(source);
      }
      if (fill === 'shape') {
        return true;
      }
      const boundary = computeBoundary(source);
      if (boundary instanceof simpleArc) {
        return boundary;
      }
      return createBoundaryLine(boundary, line);
    }
    function createBoundaryLine(boundary, line) {
      let points = [];
      let _loop = false;
      if (isArray(boundary)) {
        _loop = true;
        points = boundary;
      } else {
        points = pointsFromSegments(boundary, line);
      }
      return points.length ? new LineElement({
        points,
        options: {tension: 0},
        _loop,
        _fullLoop: _loop
      }) : null;
    }
    function resolveTarget(sources, index, propagate) {
      const source = sources[index];
      let fill = source.fill;
      const visited = [index];
      let target;
      if (!propagate) {
        return fill;
      }
      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isNumberFinite(fill)) {
          return fill;
        }
        target = sources[fill];
        if (!target) {
          return false;
        }
        if (target.visible) {
          return fill;
        }
        visited.push(fill);
        fill = target.fill;
      }
      return false;
    }
    function _clip(ctx, target, clipY) {
      ctx.beginPath();
      target.path(ctx);
      ctx.lineTo(target.last().x, clipY);
      ctx.lineTo(target.first().x, clipY);
      ctx.closePath();
      ctx.clip();
    }
    function getBounds(property, first, last, loop) {
      if (loop) {
        return;
      }
      let start = first[property];
      let end = last[property];
      if (property === 'angle') {
        start = _normalizeAngle(start);
        end = _normalizeAngle(end);
      }
      return {property, start, end};
    }
    function _getEdge(a, b, prop, fn) {
      if (a && b) {
        return fn(a[prop], b[prop]);
      }
      return a ? a[prop] : b ? b[prop] : 0;
    }
    function _segments(line, target, property) {
      const segments = line.segments;
      const points = line.points;
      const tpoints = target.points;
      const parts = [];
      for (const segment of segments) {
        let {start, end} = segment;
        end = findSegmentEnd(start, end, points);
        const bounds = getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
          parts.push({
            source: segment,
            target: bounds,
            start: points[start],
            end: points[end]
          });
          continue;
        }
        const targetSegments = _boundSegments(target, bounds);
        for (const tgt of targetSegments) {
          const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
          const fillSources = _boundSegment(segment, points, subBounds);
          for (const fillSource of fillSources) {
            parts.push({
              source: fillSource,
              target: tgt,
              start: {
                [property]: _getEdge(bounds, subBounds, 'start', Math.max)
              },
              end: {
                [property]: _getEdge(bounds, subBounds, 'end', Math.min)
              }
            });
          }
        }
      }
      return parts;
    }
    function clipBounds(ctx, scale, bounds) {
      const {top, bottom} = scale.chart.chartArea;
      const {property, start, end} = bounds || {};
      if (property === 'x') {
        ctx.beginPath();
        ctx.rect(start, top, end - start, bottom - top);
        ctx.clip();
      }
    }
    function interpolatedLineTo(ctx, target, point, property) {
      const interpolatedPoint = target.interpolate(point, property);
      if (interpolatedPoint) {
        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
      }
    }
    function _fill(ctx, cfg) {
      const {line, target, property, color, scale} = cfg;
      const segments = _segments(line, target, property);
      for (const {source: src, target: tgt, start, end} of segments) {
        const {style: {backgroundColor = color} = {}} = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, notShape && getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
          if (lineLoop) {
            ctx.closePath();
          } else {
            interpolatedLineTo(ctx, target, end, property);
          }
          const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
          loop = lineLoop && targetLoop;
          if (!loop) {
            interpolatedLineTo(ctx, target, start, property);
          }
        }
        ctx.closePath();
        ctx.fill(loop ? 'evenodd' : 'nonzero');
        ctx.restore();
      }
    }
    function doFill(ctx, cfg) {
      const {line, target, above, below, area, scale} = cfg;
      const property = line._loop ? 'angle' : cfg.axis;
      ctx.save();
      if (property === 'x' && below !== above) {
        _clip(ctx, target, area.top);
        _fill(ctx, {line, target, color: above, scale, property});
        ctx.restore();
        ctx.save();
        _clip(ctx, target, area.bottom);
      }
      _fill(ctx, {line, target, color: below, scale, property});
      ctx.restore();
    }
    function drawfill(ctx, source, area) {
      const target = getTarget(source);
      const {line, scale, axis} = source;
      const lineOpts = line.options;
      const fillOption = lineOpts.fill;
      const color = lineOpts.backgroundColor;
      const {above = color, below = color} = fillOption || {};
      if (target && line.points.length) {
        clipArea(ctx, area);
        doFill(ctx, {line, target, above, below, area, scale, axis});
        unclipArea(ctx);
      }
    }
    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate(chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          line = meta.dataset;
          source = null;
          if (line && line.options && line instanceof LineElement) {
            source = {
              visible: chart.isDatasetVisible(i),
              index: i,
              fill: decodeFill(line, i, count),
              chart,
              axis: meta.controller.options.indexAxis,
              scale: meta.vScale,
              line,
            };
          }
          meta.$filler = source;
          sources.push(source);
        }
        for (i = 0; i < count; ++i) {
          source = sources[i];
          if (!source || source.fill === false) {
            continue;
          }
          source.fill = resolveTarget(sources, i, options.propagate);
        }
      },
      beforeDraw(chart, _args, options) {
        const draw = options.drawTime === 'beforeDraw';
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for (let i = metasets.length - 1; i >= 0; --i) {
          const source = metasets[i].$filler;
          if (!source) {
            continue;
          }
          source.line.updateControlPoints(area, source.axis);
          if (draw) {
            drawfill(chart.ctx, source, area);
          }
        }
      },
      beforeDatasetsDraw(chart, _args, options) {
        if (options.drawTime !== 'beforeDatasetsDraw') {
          return;
        }
        const metasets = chart.getSortedVisibleDatasetMetas();
        for (let i = metasets.length - 1; i >= 0; --i) {
          const source = metasets[i].$filler;
          if (source) {
            drawfill(chart.ctx, source, chart.chartArea);
          }
        }
      },
      beforeDatasetDraw(chart, args, options) {
        const source = args.meta.$filler;
        if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {
          return;
        }
        drawfill(chart.ctx, source, chart.chartArea);
      },
      defaults: {
        propagate: true,
        drawTime: 'beforeDatasetDraw'
      }
    };

    const getBoxSize = (labelOpts, fontSize) => {
      let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
      if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = Math.min(boxWidth, fontSize);
      }
      return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
      };
    };
    const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
    class Legend extends Element {
      constructor(config) {
        super();
        this._added = false;
        this.legendHitBoxes = [];
        this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = undefined;
        this.columnSizes = undefined;
        this.lineWidths = undefined;
        this.maxHeight = undefined;
        this.maxWidth = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.height = undefined;
        this.width = undefined;
        this._margins = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
      }
      update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
      }
      setDimensions() {
        if (this.isHorizontal()) {
          this.width = this.maxWidth;
          this.left = this._margins.left;
          this.right = this.width;
        } else {
          this.height = this.maxHeight;
          this.top = this._margins.top;
          this.bottom = this.height;
        }
      }
      buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
        if (labelOpts.filter) {
          legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
        }
        if (labelOpts.sort) {
          legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
        }
        if (this.options.reverse) {
          legendItems.reverse();
        }
        this.legendItems = legendItems;
      }
      fit() {
        const {options, ctx} = this;
        if (!options.display) {
          this.width = this.height = 0;
          return;
        }
        const labelOpts = options.labels;
        const labelFont = toFont(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
          width = this.maxWidth;
          height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
          height = this.maxHeight;
          width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
      }
      _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const {ctx, maxWidth, options: {labels: {padding}}} = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [0];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i) => {
          const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
          if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
            totalHeight += lineHeight;
            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
            top += lineHeight;
            row++;
          }
          hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};
          lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
      }
      _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
        const {ctx, maxHeight, options: {labels: {padding}}} = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i) => {
          const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
          if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
            totalWidth += currentColWidth + padding;
            columnSizes.push({width: currentColWidth, height: currentColHeight});
            left += currentColWidth + padding;
            col++;
            currentColWidth = currentColHeight = 0;
          }
          hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};
          currentColWidth = Math.max(currentColWidth, itemWidth);
          currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({width: currentColWidth, height: currentColHeight});
        return totalWidth;
      }
      adjustHitBoxes() {
        if (!this.options.display) {
          return;
        }
        const titleHeight = this._computeTitleHeight();
        const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
        if (this.isHorizontal()) {
          let row = 0;
          let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          for (const hitbox of hitboxes) {
            if (row !== hitbox.row) {
              row = hitbox.row;
              left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
            }
            hitbox.top += this.top + titleHeight + padding;
            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
            left += hitbox.width + padding;
          }
        } else {
          let col = 0;
          let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          for (const hitbox of hitboxes) {
            if (hitbox.col !== col) {
              col = hitbox.col;
              top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            }
            hitbox.top = top;
            hitbox.left += this.left + padding;
            hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
            top += hitbox.height + padding;
          }
        }
      }
      isHorizontal() {
        return this.options.position === 'top' || this.options.position === 'bottom';
      }
      draw() {
        if (this.options.display) {
          const ctx = this.ctx;
          clipArea(ctx, this);
          this._draw();
          unclipArea(ctx);
        }
      }
      _draw() {
        const {options: opts, columnSizes, lineWidths, ctx} = this;
        const {align, labels: labelOpts} = opts;
        const defaultColor = defaults.color;
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const labelFont = toFont(labelOpts.font);
        const {color: fontColor, padding} = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign('left');
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
          if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
            return;
          }
          ctx.save();
          const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
          ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
          ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
          ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
          ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
          ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
          if (labelOpts.usePointStyle) {
            const drawOptions = {
              radius: boxWidth * Math.SQRT2 / 2,
              pointStyle: legendItem.pointStyle,
              rotation: legendItem.rotation,
              borderWidth: lineWidth
            };
            const centerX = rtlHelper.xPlus(x, boxWidth / 2);
            const centerY = y + halfFontSize;
            drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
            const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
            const borderRadius = toTRBLCorners(legendItem.borderRadius);
            ctx.beginPath();
            if (Object.values(borderRadius).some(v => v !== 0)) {
              addRoundedRectPath(ctx, {
                x: xBoxLeft,
                y: yBoxTop,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius,
              });
            } else {
              ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
            }
            ctx.fill();
            if (lineWidth !== 0) {
              ctx.stroke();
            }
          }
          ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
          renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {
            strikethrough: legendItem.hidden,
            textAlign: rtlHelper.textAlign(legendItem.textAlign)
          });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) {
          cursor = {
            x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
            y: this.top + padding + titleHeight,
            line: 0
          };
        } else {
          cursor = {
            x: this.left + padding,
            y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
            line: 0
          };
        }
        overrideTextDirection(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i) => {
          ctx.strokeStyle = legendItem.fontColor || fontColor;
          ctx.fillStyle = legendItem.fontColor || fontColor;
          const textWidth = ctx.measureText(legendItem.text).width;
          const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
          const width = boxWidth + halfFontSize + textWidth;
          let x = cursor.x;
          let y = cursor.y;
          rtlHelper.setWidth(this.width);
          if (isHorizontal) {
            if (i > 0 && x + width + padding > this.right) {
              y = cursor.y += lineHeight;
              cursor.line++;
              x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
            }
          } else if (i > 0 && y + lineHeight > this.bottom) {
            x = cursor.x = x + columnSizes[cursor.line].width + padding;
            cursor.line++;
            y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
          }
          const realX = rtlHelper.x(x);
          drawLegendBox(realX, y, legendItem);
          x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
          fillText(rtlHelper.x(x), y, legendItem);
          if (isHorizontal) {
            cursor.x += width + padding;
          } else {
            cursor.y += lineHeight;
          }
        });
        restoreTextDirection(this.ctx, opts.textDirection);
      }
      drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        if (!titleOpts.display) {
          return;
        }
        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
          maxWidth = Math.max(...this.lineWidths);
          y = this.top + topPaddingPlusHalfFontSize;
          left = _alignStartEnd(opts.align, left, this.right - maxWidth);
        } else {
          const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
          y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = _alignStartEnd(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        renderText(ctx, titleOpts.text, x, y, titleFont);
      }
      _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = toFont(titleOpts.font);
        const titlePadding = toPadding(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
      }
      _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if (x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {
          lh = this.legendHitBoxes;
          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];
            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              return this.legendItems[i];
            }
          }
        }
        return null;
      }
      handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) {
          return;
        }
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === 'mousemove') {
          const previous = this._hoveredItem;
          const sameItem = itemsEqual(previous, hoveredItem);
          if (previous && !sameItem) {
            callback(opts.onLeave, [e, previous, this], this);
          }
          this._hoveredItem = hoveredItem;
          if (hoveredItem && !sameItem) {
            callback(opts.onHover, [e, hoveredItem, this], this);
          }
        } else if (hoveredItem) {
          callback(opts.onClick, [e, hoveredItem, this], this);
        }
      }
    }
    function isListened(type, opts) {
      if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {
        return true;
      }
      if (opts.onClick && (type === 'click' || type === 'mouseup')) {
        return true;
      }
      return false;
    }
    var plugin_legend = {
      id: 'legend',
      _element: Legend,
      start(chart, _args, options) {
        const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
      },
      stop(chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
      },
      beforeUpdate(chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
      },
      afterUpdate(chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
      },
      afterEvent(chart, args) {
        if (!args.replay) {
          chart.legend.handleEvent(args.event);
        }
      },
      defaults: {
        display: true,
        position: 'top',
        align: 'center',
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick(e, legendItem, legend) {
          const index = legendItem.datasetIndex;
          const ci = legend.chart;
          if (ci.isDatasetVisible(index)) {
            ci.hide(index);
            legendItem.hidden = true;
          } else {
            ci.show(index);
            legendItem.hidden = false;
          }
        },
        onHover: null,
        onLeave: null,
        labels: {
          color: (ctx) => ctx.chart.options.color,
          boxWidth: 40,
          padding: 10,
          generateLabels(chart) {
            const datasets = chart.data.datasets;
            const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;
            return chart._getSortedDatasetMetas().map((meta) => {
              const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
              const borderWidth = toPadding(style.borderWidth);
              return {
                text: datasets[meta.index].label,
                fillStyle: style.backgroundColor,
                fontColor: color,
                hidden: !meta.visible,
                lineCap: style.borderCapStyle,
                lineDash: style.borderDash,
                lineDashOffset: style.borderDashOffset,
                lineJoin: style.borderJoinStyle,
                lineWidth: (borderWidth.width + borderWidth.height) / 4,
                strokeStyle: style.borderColor,
                pointStyle: pointStyle || style.pointStyle,
                rotation: style.rotation,
                textAlign: textAlign || style.textAlign,
                borderRadius: 0,
                datasetIndex: meta.index
              };
            }, this);
          }
        },
        title: {
          color: (ctx) => ctx.chart.options.color,
          display: false,
          position: 'center',
          text: '',
        }
      },
      descriptors: {
        _scriptable: (name) => !name.startsWith('on'),
        labels: {
          _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),
        }
      },
    };

    class Title extends Element {
      constructor(config) {
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
      }
      update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
          this.width = this.height = this.right = this.bottom = 0;
          return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = isArray(opts.text) ? opts.text.length : 1;
        this._padding = toPadding(opts.padding);
        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) {
          this.height = textSize;
        } else {
          this.width = textSize;
        }
      }
      isHorizontal() {
        const pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      }
      _drawArgs(offset) {
        const {top, left, bottom, right, options} = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
          titleX = _alignStartEnd(align, left, right);
          titleY = top + offset;
          maxWidth = right - left;
        } else {
          if (options.position === 'left') {
            titleX = left + offset;
            titleY = _alignStartEnd(align, bottom, top);
            rotation = PI * -0.5;
          } else {
            titleX = right - offset;
            titleY = _alignStartEnd(align, top, bottom);
            rotation = PI * 0.5;
          }
          maxWidth = bottom - top;
        }
        return {titleX, titleY, maxWidth, rotation};
      }
      draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) {
          return;
        }
        const fontOpts = toFont(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
        renderText(ctx, opts.text, 0, 0, fontOpts, {
          color: opts.color,
          maxWidth,
          rotation,
          textAlign: _toLeftRightCenter(opts.align),
          textBaseline: 'middle',
          translation: [titleX, titleY],
        });
      }
    }
    function createTitle(chart, titleOpts) {
      const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
      });
      layouts.configure(chart, title, titleOpts);
      layouts.addBox(chart, title);
      chart.titleBlock = title;
    }
    var plugin_title = {
      id: 'title',
      _element: Title,
      start(chart, _args, options) {
        createTitle(chart, options);
      },
      stop(chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
      },
      beforeUpdate(chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
      },
      defaults: {
        align: 'center',
        display: false,
        font: {
          weight: 'bold',
        },
        fullSize: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000
      },
      defaultRoutes: {
        color: 'color'
      },
      descriptors: {
        _scriptable: true,
        _indexable: false,
      },
    };

    const map = new WeakMap();
    var plugin_subtitle = {
      id: 'subtitle',
      start(chart, _args, options) {
        const title = new Title({
          ctx: chart.ctx,
          options,
          chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
      },
      stop(chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
      },
      beforeUpdate(chart, _args, options) {
        const title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
      },
      defaults: {
        align: 'center',
        display: false,
        font: {
          weight: 'normal',
        },
        fullSize: true,
        padding: 0,
        position: 'top',
        text: '',
        weight: 1500
      },
      defaultRoutes: {
        color: 'color'
      },
      descriptors: {
        _scriptable: true,
        _indexable: false,
      },
    };

    const positioners = {
      average(items) {
        if (!items.length) {
          return false;
        }
        let i, len;
        let x = 0;
        let y = 0;
        let count = 0;
        for (i = 0, len = items.length; i < len; ++i) {
          const el = items[i].element;
          if (el && el.hasValue()) {
            const pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }
        return {
          x: x / count,
          y: y / count
        };
      },
      nearest(items, eventPosition) {
        if (!items.length) {
          return false;
        }
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for (i = 0, len = items.length; i < len; ++i) {
          const el = items[i].element;
          if (el && el.hasValue()) {
            const center = el.getCenterPoint();
            const d = distanceBetweenPoints(eventPosition, center);
            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }
        if (nearestElement) {
          const tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }
        return {
          x,
          y
        };
      }
    };
    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (isArray(toPush)) {
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }
      return base;
    }
    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }
      return str;
    }
    function createTooltipItem(chart, item) {
      const {element, datasetIndex, index} = item;
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      const {label, value} = controller.getLabelAndValue(index);
      return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element
      };
    }
    function getTooltipSize(tooltip, options) {
      const ctx = tooltip._chart.ctx;
      const {body, footer, title} = tooltip;
      const {boxWidth, boxHeight} = options;
      const bodyFont = toFont(options.bodyFont);
      const titleFont = toFont(options.titleFont);
      const footerFont = toFont(options.footerFont);
      const titleLineCount = title.length;
      const footerLineCount = footer.length;
      const bodyLineItemCount = body.length;
      const padding = toPadding(options.padding);
      let height = padding.height;
      let width = 0;
      let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
      combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
      if (titleLineCount) {
        height += titleLineCount * titleFont.lineHeight
    			+ (titleLineCount - 1) * options.titleSpacing
    			+ options.titleMarginBottom;
      }
      if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight
    			+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight
    			+ (combinedBodyLength - 1) * options.bodySpacing;
      }
      if (footerLineCount) {
        height += options.footerMarginTop
    			+ footerLineCount * footerFont.lineHeight
    			+ (footerLineCount - 1) * options.footerSpacing;
      }
      let widthPadding = 0;
      const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };
      ctx.save();
      ctx.font = titleFont.string;
      each(tooltip.title, maxLineWidth);
      ctx.font = bodyFont.string;
      each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
      widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;
      each(body, (bodyItem) => {
        each(bodyItem.before, maxLineWidth);
        each(bodyItem.lines, maxLineWidth);
        each(bodyItem.after, maxLineWidth);
      });
      widthPadding = 0;
      ctx.font = footerFont.string;
      each(tooltip.footer, maxLineWidth);
      ctx.restore();
      width += padding.width;
      return {width, height};
    }
    function determineYAlign(chart, size) {
      const {y, height} = size;
      if (y < height / 2) {
        return 'top';
      } else if (y > (chart.height - height / 2)) {
        return 'bottom';
      }
      return 'center';
    }
    function doesNotFitWithAlign(xAlign, chart, options, size) {
      const {x, width} = size;
      const caret = options.caretSize + options.caretPadding;
      if (xAlign === 'left' && x + width + caret > chart.width) {
        return true;
      }
      if (xAlign === 'right' && x - width - caret < 0) {
        return true;
      }
    }
    function determineXAlign(chart, options, size, yAlign) {
      const {x, width} = size;
      const {width: chartWidth, chartArea: {left, right}} = chart;
      let xAlign = 'center';
      if (yAlign === 'center') {
        xAlign = x <= (left + right) / 2 ? 'left' : 'right';
      } else if (x <= width / 2) {
        xAlign = 'left';
      } else if (x >= chartWidth - width / 2) {
        xAlign = 'right';
      }
      if (doesNotFitWithAlign(xAlign, chart, options, size)) {
        xAlign = 'center';
      }
      return xAlign;
    }
    function determineAlignment(chart, options, size) {
      const yAlign = options.yAlign || determineYAlign(chart, size);
      return {
        xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
      };
    }
    function alignX(size, xAlign) {
      let {x, width} = size;
      if (xAlign === 'right') {
        x -= width;
      } else if (xAlign === 'center') {
        x -= (width / 2);
      }
      return x;
    }
    function alignY(size, yAlign, paddingAndSize) {
      let {y, height} = size;
      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= height + paddingAndSize;
      } else {
        y -= (height / 2);
      }
      return y;
    }
    function getBackgroundPoint(options, size, alignment, chart) {
      const {caretSize, caretPadding, cornerRadius} = options;
      const {xAlign, yAlign} = alignment;
      const paddingAndSize = caretSize + caretPadding;
      const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
      let x = alignX(size, xAlign);
      const y = alignY(size, yAlign, paddingAndSize);
      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= Math.max(topLeft, bottomLeft) + caretPadding;
      } else if (xAlign === 'right') {
        x += Math.max(topRight, bottomRight) + caretPadding;
      }
      return {
        x: _limitValue(x, 0, chart.width - size.width),
        y: _limitValue(y, 0, chart.height - size.height)
      };
    }
    function getAlignedX(tooltip, align, options) {
      const padding = toPadding(options.padding);
      return align === 'center'
        ? tooltip.x + tooltip.width / 2
        : align === 'right'
          ? tooltip.x + tooltip.width - padding.right
          : tooltip.x + padding.left;
    }
    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }
    function createTooltipContext(parent, tooltip, tooltipItems) {
      return createContext(parent, {
        tooltip,
        tooltipItems,
        type: 'tooltip'
      });
    }
    function overrideCallbacks(callbacks, context) {
      const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
      return override ? callbacks.override(override) : callbacks;
    }
    class Tooltip extends Element {
      constructor(config) {
        super();
        this.opacity = 0;
        this._active = [];
        this._chart = config._chart;
        this._eventPosition = undefined;
        this._size = undefined;
        this._cachedAnimations = undefined;
        this._tooltipItems = [];
        this.$animations = undefined;
        this.$context = undefined;
        this.options = config.options;
        this.dataPoints = undefined;
        this.title = undefined;
        this.beforeBody = undefined;
        this.body = undefined;
        this.afterBody = undefined;
        this.footer = undefined;
        this.xAlign = undefined;
        this.yAlign = undefined;
        this.x = undefined;
        this.y = undefined;
        this.height = undefined;
        this.width = undefined;
        this.caretX = undefined;
        this.caretY = undefined;
        this.labelColors = undefined;
        this.labelPointStyles = undefined;
        this.labelTextColors = undefined;
      }
      initialize(options) {
        this.options = options;
        this._cachedAnimations = undefined;
        this.$context = undefined;
      }
      _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) {
          return cached;
        }
        const chart = this._chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this._chart, opts);
        if (opts._cacheable) {
          this._cachedAnimations = Object.freeze(animations);
        }
        return animations;
      }
      getContext() {
        return this.$context ||
    			(this.$context = createTooltipContext(this._chart.getContext(), this, this._tooltipItems));
      }
      getTitle(context, options) {
        const {callbacks} = options;
        const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
        const title = callbacks.title.apply(this, [context]);
        const afterTitle = callbacks.afterTitle.apply(this, [context]);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      }
      getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
      }
      getBody(tooltipItems, options) {
        const {callbacks} = options;
        const bodyItems = [];
        each(tooltipItems, (context) => {
          const bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          const scoped = overrideCallbacks(callbacks, context);
          pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
          pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
          pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      }
      getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
      }
      getFooter(tooltipItems, options) {
        const {callbacks} = options;
        const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
        const footer = callbacks.footer.apply(this, [tooltipItems]);
        const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      }
      _createItems(options) {
        const active = this._active;
        const data = this._chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for (i = 0, len = active.length; i < len; ++i) {
          tooltipItems.push(createTooltipItem(this._chart, active[i]));
        }
        if (options.filter) {
          tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
        }
        if (options.itemSort) {
          tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
        }
        each(tooltipItems, (context) => {
          const scoped = overrideCallbacks(options.callbacks, context);
          labelColors.push(scoped.labelColor.call(this, context));
          labelPointStyles.push(scoped.labelPointStyle.call(this, context));
          labelTextColors.push(scoped.labelTextColor.call(this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
      }
      update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
          if (this.opacity !== 0) {
            properties = {
              opacity: 0
            };
          }
        } else {
          const position = positioners[options.position].call(this, active, this._eventPosition);
          tooltipItems = this._createItems(options);
          this.title = this.getTitle(tooltipItems, options);
          this.beforeBody = this.getBeforeBody(tooltipItems, options);
          this.body = this.getBody(tooltipItems, options);
          this.afterBody = this.getAfterBody(tooltipItems, options);
          this.footer = this.getFooter(tooltipItems, options);
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, size);
          const alignment = determineAlignment(this._chart, options, positionAndSize);
          const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this._chart);
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          properties = {
            opacity: 1,
            x: backgroundPoint.x,
            y: backgroundPoint.y,
            width: size.width,
            height: size.height,
            caretX: position.x,
            caretY: position.y
          };
        }
        this._tooltipItems = tooltipItems;
        this.$context = undefined;
        if (properties) {
          this._resolveAnimations().update(this, properties);
        }
        if (changed && options.external) {
          options.external.call(this, {chart: this._chart, tooltip: this, replay});
        }
      }
      drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      }
      getCaretPosition(tooltipPoint, size, options) {
        const {xAlign, yAlign} = this;
        const {caretSize, cornerRadius} = options;
        const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
        const {x: ptX, y: ptY} = tooltipPoint;
        const {width, height} = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === 'center') {
          y2 = ptY + (height / 2);
          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
          x3 = x1;
        } else {
          if (xAlign === 'left') {
            x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);
          } else if (xAlign === 'right') {
            x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
          } else {
            x2 = this.caretX;
          }
          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            x1 = x2 + caretSize;
            x3 = x2 - caretSize;
          }
          y3 = y1;
        }
        return {x1, x2, x3, y1, y2, y3};
      }
      drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.titleAlign, options);
          ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
          ctx.textBaseline = 'middle';
          titleFont = toFont(options.titleFont);
          titleSpacing = options.titleSpacing;
          ctx.fillStyle = options.titleColor;
          ctx.font = titleFont.string;
          for (i = 0; i < length; ++i) {
            ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
            pt.y += titleFont.lineHeight + titleSpacing;
            if (i + 1 === length) {
              pt.y += options.titleMarginBottom - titleSpacing;
            }
          }
        }
      }
      _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColors = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const {boxHeight, boxWidth, boxPadding} = options;
        const bodyFont = toFont(options.bodyFont);
        const colorX = getAlignedX(this, 'left', options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
          const drawOptions = {
            radius: Math.min(boxWidth, boxHeight) / 2,
            pointStyle: labelPointStyle.pointStyle,
            rotation: labelPointStyle.rotation,
            borderWidth: 1
          };
          const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
          const centerY = colorY + boxHeight / 2;
          ctx.strokeStyle = options.multiKeyBackground;
          ctx.fillStyle = options.multiKeyBackground;
          drawPoint(ctx, drawOptions, centerX, centerY);
          ctx.strokeStyle = labelColors.borderColor;
          ctx.fillStyle = labelColors.backgroundColor;
          drawPoint(ctx, drawOptions, centerX, centerY);
        } else {
          ctx.lineWidth = labelColors.borderWidth || 1;
          ctx.strokeStyle = labelColors.borderColor;
          ctx.setLineDash(labelColors.borderDash || []);
          ctx.lineDashOffset = labelColors.borderDashOffset || 0;
          const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
          const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
          const borderRadius = toTRBLCorners(labelColors.borderRadius);
          if (Object.values(borderRadius).some(v => v !== 0)) {
            ctx.beginPath();
            ctx.fillStyle = options.multiKeyBackground;
            addRoundedRectPath(ctx, {
              x: outerX,
              y: colorY,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius,
            });
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = labelColors.backgroundColor;
            ctx.beginPath();
            addRoundedRectPath(ctx, {
              x: innerX,
              y: colorY + 1,
              w: boxWidth - 2,
              h: boxHeight - 2,
              radius: borderRadius,
            });
            ctx.fill();
          } else {
            ctx.fillStyle = options.multiKeyBackground;
            ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
            ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
            ctx.fillStyle = labelColors.backgroundColor;
            ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
          }
        }
        ctx.fillStyle = this.labelTextColors[i];
      }
      drawBody(pt, ctx, options) {
        const {body} = this;
        const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
        const bodyFont = toFont(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
          ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
          pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'middle';
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        each(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== 'right'
          ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)
          : 0;
        for (i = 0, ilen = body.length; i < ilen; ++i) {
          bodyItem = body[i];
          textColor = this.labelTextColors[i];
          ctx.fillStyle = textColor;
          each(bodyItem.before, fillLineOfText);
          lines = bodyItem.lines;
          if (displayColors && lines.length) {
            this._drawColorBox(ctx, pt, i, rtlHelper, options);
            bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
          }
          for (j = 0, jlen = lines.length; j < jlen; ++j) {
            fillLineOfText(lines[j]);
            bodyLineHeight = bodyFont.lineHeight;
          }
          each(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        each(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
      }
      drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          pt.x = getAlignedX(this, options.footerAlign, options);
          pt.y += options.footerMarginTop;
          ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
          ctx.textBaseline = 'middle';
          footerFont = toFont(options.footerFont);
          ctx.fillStyle = options.footerColor;
          ctx.font = footerFont.string;
          for (i = 0; i < length; ++i) {
            ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
            pt.y += footerFont.lineHeight + options.footerSpacing;
          }
        }
      }
      drawBackground(pt, ctx, tooltipSize, options) {
        const {xAlign, yAlign} = this;
        const {x, y} = pt;
        const {width, height} = tooltipSize;
        const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === 'top') {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === 'bottom') {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, ctx, tooltipSize, options);
        }
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) {
          ctx.stroke();
        }
      }
      _updateAnimationTarget(options) {
        const chart = this._chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
          const position = positioners[options.position].call(this, this._active, this._eventPosition);
          if (!position) {
            return;
          }
          const size = this._size = getTooltipSize(this, options);
          const positionAndSize = Object.assign({}, position, this._size);
          const alignment = determineAlignment(chart, options, positionAndSize);
          const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
          if (animX._to !== point.x || animY._to !== point.y) {
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            this.width = size.width;
            this.height = size.height;
            this.caretX = position.x;
            this.caretY = position.y;
            this._resolveAnimations().update(this, point);
          }
        }
      }
      draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) {
          return;
        }
        this._updateAnimationTarget(options);
        const tooltipSize = {
          width: this.width,
          height: this.height
        };
        const pt = {
          x: this.x,
          y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = toPadding(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity;
          this.drawBackground(pt, ctx, tooltipSize, options);
          overrideTextDirection(ctx, options.textDirection);
          pt.y += padding.top;
          this.drawTitle(pt, ctx, options);
          this.drawBody(pt, ctx, options);
          this.drawFooter(pt, ctx, options);
          restoreTextDirection(ctx, options.textDirection);
          ctx.restore();
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({datasetIndex, index}) => {
          const meta = this._chart.getDatasetMeta(datasetIndex);
          if (!meta) {
            throw new Error('Cannot find a dataset at index ' + datasetIndex);
          }
          return {
            datasetIndex,
            element: meta.data[index],
            index,
          };
        });
        const changed = !_elementsEqual(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
          this._active = active;
          this._eventPosition = eventPosition;
          this.update(true);
        }
      }
      handleEvent(e, replay) {
        const options = this.options;
        const lastActive = this._active || [];
        let changed = false;
        let active = [];
        if (e.type !== 'mouseout') {
          active = this._chart.getElementsAtEventForMode(e, options.mode, options, replay);
          if (options.reverse) {
            active.reverse();
          }
        }
        const positionChanged = this._positionChanged(active, e);
        changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
        if (changed) {
          this._active = active;
          if (options.enabled || options.external) {
            this._eventPosition = {
              x: e.x,
              y: e.y
            };
            this.update(true, replay);
          }
        }
        return changed;
      }
      _positionChanged(active, e) {
        const {caretX, caretY, options} = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
      }
    }
    Tooltip.positioners = positioners;
    var plugin_tooltip = {
      id: 'tooltip',
      _element: Tooltip,
      positioners,
      afterInit(chart, _args, options) {
        if (options) {
          chart.tooltip = new Tooltip({_chart: chart, options});
        }
      },
      beforeUpdate(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      reset(chart, _args, options) {
        if (chart.tooltip) {
          chart.tooltip.initialize(options);
        }
      },
      afterDraw(chart) {
        const tooltip = chart.tooltip;
        const args = {
          tooltip
        };
        if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {
          return;
        }
        if (tooltip) {
          tooltip.draw(chart.ctx);
        }
        chart.notifyPlugins('afterTooltipDraw', args);
      },
      afterEvent(chart, args) {
        if (chart.tooltip) {
          const useFinalPosition = args.replay;
          if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {
            args.changed = true;
          }
        }
      },
      defaults: {
        enabled: true,
        external: null,
        position: 'average',
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleColor: '#fff',
        titleFont: {
          weight: 'bold',
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: 'left',
        bodyColor: '#fff',
        bodySpacing: 2,
        bodyFont: {
        },
        bodyAlign: 'left',
        footerColor: '#fff',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
          weight: 'bold',
        },
        footerAlign: 'left',
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts) => opts.bodyFont.size,
        boxWidth: (ctx, opts) => opts.bodyFont.size,
        multiKeyBackground: '#fff',
        displayColors: true,
        boxPadding: 0,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        animation: {
          duration: 400,
          easing: 'easeOutQuart',
        },
        animations: {
          numbers: {
            type: 'number',
            properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
          },
          opacity: {
            easing: 'linear',
            duration: 200
          }
        },
        callbacks: {
          beforeTitle: noop,
          title(tooltipItems) {
            if (tooltipItems.length > 0) {
              const item = tooltipItems[0];
              const labels = item.chart.data.labels;
              const labelCount = labels ? labels.length : 0;
              if (this && this.options && this.options.mode === 'dataset') {
                return item.dataset.label || '';
              } else if (item.label) {
                return item.label;
              } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
              }
            }
            return '';
          },
          afterTitle: noop,
          beforeBody: noop,
          beforeLabel: noop,
          label(tooltipItem) {
            if (this && this.options && this.options.mode === 'dataset') {
              return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
            }
            let label = tooltipItem.dataset.label || '';
            if (label) {
              label += ': ';
            }
            const value = tooltipItem.formattedValue;
            if (!isNullOrUndef(value)) {
              label += value;
            }
            return label;
          },
          labelColor(tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
              borderColor: options.borderColor,
              backgroundColor: options.backgroundColor,
              borderWidth: options.borderWidth,
              borderDash: options.borderDash,
              borderDashOffset: options.borderDashOffset,
              borderRadius: 0,
            };
          },
          labelTextColor() {
            return this.options.bodyColor;
          },
          labelPointStyle(tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
              pointStyle: options.pointStyle,
              rotation: options.rotation,
            };
          },
          afterLabel: noop,
          afterBody: noop,
          beforeFooter: noop,
          footer: noop,
          afterFooter: noop
        }
      },
      defaultRoutes: {
        bodyFont: 'font',
        footerFont: 'font',
        titleFont: 'font'
      },
      descriptors: {
        _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',
        _indexable: false,
        callbacks: {
          _scriptable: false,
          _indexable: false,
        },
        animation: {
          _fallback: false
        },
        animations: {
          _fallback: 'animation'
        }
      },
      additionalOptionScopes: ['interaction']
    };

    var plugins = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Decimation: plugin_decimation,
    Filler: plugin_filler,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
    });

    const addIfString = (labels, raw, index) => typeof raw === 'string'
      ? labels.push(raw) - 1
      : isNaN(raw) ? null : index;
    function findOrAddLabel(labels, raw, index) {
      const first = labels.indexOf(raw);
      if (first === -1) {
        return addIfString(labels, raw, index);
      }
      const last = labels.lastIndexOf(raw);
      return first !== last ? index : first;
    }
    const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
    class CategoryScale extends Scale {
      constructor(cfg) {
        super(cfg);
        this._startValue = undefined;
        this._valueRange = 0;
      }
      parse(raw, index) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index
          : findOrAddLabel(labels, raw, valueOrDefault(index, raw));
        return validIndex(index, labels.length - 1);
      }
      determineDataLimits() {
        const {minDefined, maxDefined} = this.getUserBounds();
        let {min, max} = this.getMinMax(true);
        if (this.options.bounds === 'ticks') {
          if (!minDefined) {
            min = 0;
          }
          if (!maxDefined) {
            max = this.getLabels().length - 1;
          }
        }
        this.min = min;
        this.max = max;
      }
      buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for (let value = min; value <= max; value++) {
          ticks.push({value});
        }
        return ticks;
      }
      getLabelForValue(value) {
        const labels = this.getLabels();
        if (value >= 0 && value < labels.length) {
          return labels[value];
        }
        return value;
      }
      configure() {
        super.configure();
        if (!this.isHorizontal()) {
          this._reversePixels = !this._reversePixels;
        }
      }
      getPixelForValue(value) {
        if (typeof value !== 'number') {
          value = this.parse(value);
        }
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) {
          return null;
        }
        return this.getPixelForValue(ticks[index].value);
      }
      getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
      }
      getBasePixel() {
        return this.bottom;
      }
    }
    CategoryScale.id = 'category';
    CategoryScale.defaults = {
      ticks: {
        callback: CategoryScale.prototype.getLabelForValue
      }
    };

    function generateTicks$1(generationOptions, dataRange) {
      const ticks = [];
      const MIN_SPACING = 1e-14;
      const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
      const unit = step || 1;
      const maxSpaces = maxTicks - 1;
      const {min: rmin, max: rmax} = dataRange;
      const minDefined = !isNullOrUndef(min);
      const maxDefined = !isNullOrUndef(max);
      const countDefined = !isNullOrUndef(count);
      const minSpacing = (rmax - rmin) / (maxDigits + 1);
      let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
      let factor, niceMin, niceMax, numSpaces;
      if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
        return [{value: rmin}, {value: rmax}];
      }
      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
      if (numSpaces > maxSpaces) {
        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
      }
      if (!isNullOrUndef(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }
      if (bounds === 'ticks') {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
      } else {
        niceMin = rmin;
        niceMax = rmax;
      }
      if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
      } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
      } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
          numSpaces = Math.round(numSpaces);
        } else {
          numSpaces = Math.ceil(numSpaces);
        }
      }
      const decimalPlaces = Math.max(
        _decimalPlaces(spacing),
        _decimalPlaces(niceMin)
      );
      factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      let j = 0;
      if (minDefined) {
        if (includeBounds && niceMin !== min) {
          ticks.push({value: min});
          if (niceMin < min) {
            j++;
          }
          if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
            j++;
          }
        } else if (niceMin < min) {
          j++;
        }
      }
      for (; j < numSpaces; ++j) {
        ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
      }
      if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
          ticks[ticks.length - 1].value = max;
        } else {
          ticks.push({value: max});
        }
      } else if (!maxDefined || niceMax === max) {
        ticks.push({value: niceMax});
      }
      return ticks;
    }
    function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
      const rad = toRadians(minRotation);
      const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
      const length = 0.75 * minSpacing * ('' + value).length;
      return Math.min(minSpacing / ratio, length);
    }
    class LinearScaleBase extends Scale {
      constructor(cfg) {
        super(cfg);
        this.start = undefined;
        this.end = undefined;
        this._startValue = undefined;
        this._endValue = undefined;
        this._valueRange = 0;
      }
      parse(raw, index) {
        if (isNullOrUndef(raw)) {
          return null;
        }
        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
          return null;
        }
        return +raw;
      }
      handleTickRangeOptions() {
        const {beginAtZero} = this.options;
        const {minDefined, maxDefined} = this.getUserBounds();
        let {min, max} = this;
        const setMin = v => (min = minDefined ? min : v);
        const setMax = v => (max = maxDefined ? max : v);
        if (beginAtZero) {
          const minSign = sign(min);
          const maxSign = sign(max);
          if (minSign < 0 && maxSign < 0) {
            setMax(0);
          } else if (minSign > 0 && maxSign > 0) {
            setMin(0);
          }
        }
        if (min === max) {
          let offset = 1;
          if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
            offset = Math.abs(max * 0.05);
          }
          setMax(max + offset);
          if (!beginAtZero) {
            setMin(min - offset);
          }
        }
        this.min = min;
        this.max = max;
      }
      getTickLimit() {
        const tickOpts = this.options.ticks;
        let {maxTicksLimit, stepSize} = tickOpts;
        let maxTicks;
        if (stepSize) {
          maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
          if (maxTicks > 1000) {
            console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
            maxTicks = 1000;
          }
        } else {
          maxTicks = this.computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }
        return maxTicks;
      }
      computeTickLimit() {
        return Number.POSITIVE_INFINITY;
      }
      buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
          maxTicks,
          bounds: opts.bounds,
          min: opts.min,
          max: opts.max,
          precision: tickOpts.precision,
          step: tickOpts.stepSize,
          count: tickOpts.count,
          maxDigits: this._maxDigits(),
          horizontal: this.isHorizontal(),
          minRotation: tickOpts.minRotation || 0,
          includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === 'ticks') {
          _setMinAndMaxByKey(ticks, this, 'value');
        }
        if (opts.reverse) {
          ticks.reverse();
          this.start = this.max;
          this.end = this.min;
        } else {
          this.start = this.min;
          this.end = this.max;
        }
        return ticks;
      }
      configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
          const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
          start -= offset;
          end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
      }
      getLabelForValue(value) {
        return formatNumber(value, this.chart.options.locale);
      }
    }

    class LinearScale extends LinearScaleBase {
      determineDataLimits() {
        const {min, max} = this.getMinMax(true);
        this.min = isNumberFinite(min) ? min : 0;
        this.max = isNumberFinite(max) ? max : 1;
        this.handleTickRangeOptions();
      }
      computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = toRadians(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
      }
      getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
      }
    }
    LinearScale.id = 'linear';
    LinearScale.defaults = {
      ticks: {
        callback: Ticks.formatters.numeric
      }
    };

    function isMajor(tickVal) {
      const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));
      return remain === 1;
    }
    function generateTicks(generationOptions, dataRange) {
      const endExp = Math.floor(log10(dataRange.max));
      const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      const ticks = [];
      let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
      let exp = Math.floor(log10(tickVal));
      let significand = Math.floor(tickVal / Math.pow(10, exp));
      let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
      do {
        ticks.push({value: tickVal, major: isMajor(tickVal)});
        ++significand;
        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }
        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || (exp === endExp && significand < endSignificand));
      const lastTick = finiteOrDefault(generationOptions.max, tickVal);
      ticks.push({value: lastTick, major: isMajor(tickVal)});
      return ticks;
    }
    class LogarithmicScale extends Scale {
      constructor(cfg) {
        super(cfg);
        this.start = undefined;
        this.end = undefined;
        this._startValue = undefined;
        this._valueRange = 0;
      }
      parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
        if (value === 0) {
          this._zero = true;
          return undefined;
        }
        return isNumberFinite(value) && value > 0 ? value : null;
      }
      determineDataLimits() {
        const {min, max} = this.getMinMax(true);
        this.min = isNumberFinite(min) ? Math.max(0, min) : null;
        this.max = isNumberFinite(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) {
          this._zero = true;
        }
        this.handleTickRangeOptions();
      }
      handleTickRangeOptions() {
        const {minDefined, maxDefined} = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = v => (min = minDefined ? min : v);
        const setMax = v => (max = maxDefined ? max : v);
        const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
        if (min === max) {
          if (min <= 0) {
            setMin(1);
            setMax(10);
          } else {
            setMin(exp(min, -1));
            setMax(exp(max, +1));
          }
        }
        if (min <= 0) {
          setMin(exp(max, -1));
        }
        if (max <= 0) {
          setMax(exp(min, +1));
        }
        if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
          setMin(exp(min, -1));
        }
        this.min = min;
        this.max = max;
      }
      buildTicks() {
        const opts = this.options;
        const generationOptions = {
          min: this._userMin,
          max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === 'ticks') {
          _setMinAndMaxByKey(ticks, this, 'value');
        }
        if (opts.reverse) {
          ticks.reverse();
          this.start = this.max;
          this.end = this.min;
        } else {
          this.start = this.min;
          this.end = this.max;
        }
        return ticks;
      }
      getLabelForValue(value) {
        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale);
      }
      configure() {
        const start = this.min;
        super.configure();
        this._startValue = log10(start);
        this._valueRange = log10(this.max) - log10(start);
      }
      getPixelForValue(value) {
        if (value === undefined || value === 0) {
          value = this.min;
        }
        if (value === null || isNaN(value)) {
          return NaN;
        }
        return this.getPixelForDecimal(value === this.min
          ? 0
          : (log10(value) - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
      }
    }
    LogarithmicScale.id = 'logarithmic';
    LogarithmicScale.defaults = {
      ticks: {
        callback: Ticks.formatters.logarithmic,
        major: {
          enabled: true
        }
      }
    };

    function getTickBackdropHeight(opts) {
      const tickOpts = opts.ticks;
      if (tickOpts.display && opts.display) {
        const padding = toPadding(tickOpts.backdropPadding);
        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
      }
      return 0;
    }
    function measureLabelSize(ctx, font, label) {
      label = isArray(label) ? label : [label];
      return {
        w: _longestText(ctx, font.string, label),
        h: label.length * font.lineHeight
      };
    }
    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - (size / 2),
          end: pos + (size / 2)
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }
      return {
        start: pos,
        end: pos + size
      };
    }
    function fitWithPointLabels(scale) {
      const furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      const furthestAngles = {};
      const labelSizes = [];
      const padding = [];
      const valueCount = scale.getLabels().length;
      for (let i = 0; i < valueCount; i++) {
        const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);
        const plFont = toFont(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = scale.getIndexAngle(i);
        const angle = toDegrees(angleRadians);
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }
        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }
        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }
        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }
      scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);
      scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
    }
    function buildPointLabelItems(scale, labelSizes, padding) {
      const items = [];
      const valueCount = scale.getLabels().length;
      const opts = scale.options;
      const tickBackdropHeight = getTickBackdropHeight(opts);
      const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
      for (let i = 0; i < valueCount; i++) {
        const extra = (i === 0 ? tickBackdropHeight / 2 : 0);
        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);
        const angle = toDegrees(scale.getIndexAngle(i));
        const size = labelSizes[i];
        const y = yForAngle(pointLabelPosition.y, size.h, angle);
        const textAlign = getTextAlignForAngle(angle);
        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
        items.push({
          x: pointLabelPosition.x,
          y,
          textAlign,
          left,
          top: y,
          right: left + size.w,
          bottom: y + size.h
        });
      }
      return items;
    }
    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }
      return 'right';
    }
    function leftForTextAlign(x, w, align) {
      if (align === 'right') {
        x -= w;
      } else if (align === 'center') {
        x -= (w / 2);
      }
      return x;
    }
    function yForAngle(y, h, angle) {
      if (angle === 90 || angle === 270) {
        y -= (h / 2);
      } else if (angle > 270 || angle < 90) {
        y -= h;
      }
      return y;
    }
    function drawPointLabels(scale, labelCount) {
      const {ctx, options: {pointLabels}} = scale;
      for (let i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        const plFont = toFont(optsAtIndex.font);
        const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
        const {backdropColor} = optsAtIndex;
        if (!isNullOrUndef(backdropColor)) {
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillStyle = backdropColor;
          ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
        }
        renderText(
          ctx,
          scale._pointLabels[i],
          x,
          y + (plFont.lineHeight / 2),
          plFont,
          {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: 'middle'
          }
        );
      }
    }
    function pathRadiusLine(scale, radius, circular, labelCount) {
      const {ctx} = scale;
      if (circular) {
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
      } else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for (let i = 1; i < labelCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }
    }
    function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
      const ctx = scale.ctx;
      const circular = gridLineOpts.circular;
      const {color, lineWidth} = gridLineOpts;
      if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {
        return;
      }
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.setLineDash(gridLineOpts.borderDash);
      ctx.lineDashOffset = gridLineOpts.borderDashOffset;
      ctx.beginPath();
      pathRadiusLine(scale, radius, circular, labelCount);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
    function numberOrZero(param) {
      return isNumber(param) ? param : 0;
    }
    function createPointLabelContext(parent, index, label) {
      return createContext(parent, {
        label,
        index,
        type: 'pointLabel'
      });
    }
    class RadialLinearScale extends LinearScaleBase {
      constructor(cfg) {
        super(cfg);
        this.xCenter = undefined;
        this.yCenter = undefined;
        this.drawingArea = undefined;
        this._pointLabels = [];
        this._pointLabelItems = [];
      }
      setDimensions() {
        this.width = this.maxWidth;
        this.height = this.maxHeight;
        this.paddingTop = getTickBackdropHeight(this.options) / 2;
        this.xCenter = Math.floor(this.width / 2);
        this.yCenter = Math.floor((this.height - this.paddingTop) / 2);
        this.drawingArea = Math.min(this.height - this.paddingTop, this.width) / 2;
      }
      determineDataLimits() {
        const {min, max} = this.getMinMax(false);
        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
      }
      computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      }
      generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index) => {
          const label = callback(this.options.pointLabels.callback, [value, index], this);
          return label || label === 0 ? label : '';
        });
      }
      fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(this);
        } else {
          this.setCenterPoint(0, 0, 0, 0);
        }
      }
      _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
        let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        let radiusReductionRight = Math.max(furthestLimits.r - this.width, 0) / Math.sin(furthestAngles.r);
        let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        let radiusReductionBottom = -Math.max(furthestLimits.b - (this.height - this.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        this.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(
          Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
          Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));
        this.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      }
      setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        const maxRight = this.width - rightMovement - this.drawingArea;
        const maxLeft = leftMovement + this.drawingArea;
        const maxTop = topMovement + this.drawingArea;
        const maxBottom = (this.height - this.paddingTop) - bottomMovement - this.drawingArea;
        this.xCenter = Math.floor(((maxLeft + maxRight) / 2) + this.left);
        this.yCenter = Math.floor(((maxTop + maxBottom) / 2) + this.top + this.paddingTop);
      }
      getIndexAngle(index) {
        const angleMultiplier = TAU / this.getLabels().length;
        const startAngle = this.options.startAngle || 0;
        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
      }
      getDistanceFromCenterForValue(value) {
        if (isNullOrUndef(value)) {
          return NaN;
        }
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) {
          return (this.max - value) * scalingFactor;
        }
        return (value - this.min) * scalingFactor;
      }
      getValueForDistanceFromCenter(distance) {
        if (isNullOrUndef(distance)) {
          return NaN;
        }
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
      }
      getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
          const pointLabel = pointLabels[index];
          return createPointLabelContext(this.getContext(), index, pointLabel);
        }
      }
      getPointPosition(index, distanceFromCenter) {
        const angle = this.getIndexAngle(index) - HALF_PI;
        return {
          x: Math.cos(angle) * distanceFromCenter + this.xCenter,
          y: Math.sin(angle) * distanceFromCenter + this.yCenter,
          angle
        };
      }
      getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      }
      getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
      }
      getPointLabelPosition(index) {
        const {left, top, right, bottom} = this._pointLabelItems[index];
        return {
          left,
          top,
          right,
          bottom,
        };
      }
      drawBackground() {
        const {backgroundColor, grid: {circular}} = this.options;
        if (backgroundColor) {
          const ctx = this.ctx;
          ctx.save();
          ctx.beginPath();
          pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this.getLabels().length);
          ctx.closePath();
          ctx.fillStyle = backgroundColor;
          ctx.fill();
          ctx.restore();
        }
      }
      drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const {angleLines, grid} = opts;
        const labelCount = this.getLabels().length;
        let i, offset, position;
        if (opts.pointLabels.display) {
          drawPointLabels(this, labelCount);
        }
        if (grid.display) {
          this.ticks.forEach((tick, index) => {
            if (index !== 0) {
              offset = this.getDistanceFromCenterForValue(tick.value);
              const optsAtIndex = grid.setContext(this.getContext(index - 1));
              drawRadiusLine(this, optsAtIndex, offset, labelCount);
            }
          });
        }
        if (angleLines.display) {
          ctx.save();
          for (i = this.getLabels().length - 1; i >= 0; i--) {
            const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
            const {color, lineWidth} = optsAtIndex;
            if (!lineWidth || !color) {
              continue;
            }
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = color;
            ctx.setLineDash(optsAtIndex.borderDash);
            ctx.lineDashOffset = optsAtIndex.borderDashOffset;
            offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
            position = this.getPointPosition(i, offset);
            ctx.beginPath();
            ctx.moveTo(this.xCenter, this.yCenter);
            ctx.lineTo(position.x, position.y);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      drawBorder() {}
      drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) {
          return;
        }
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        this.ticks.forEach((tick, index) => {
          if (index === 0 && !opts.reverse) {
            return;
          }
          const optsAtIndex = tickOpts.setContext(this.getContext(index));
          const tickFont = toFont(optsAtIndex.font);
          offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
          if (optsAtIndex.showLabelBackdrop) {
            ctx.font = tickFont.string;
            width = ctx.measureText(tick.label).width;
            ctx.fillStyle = optsAtIndex.backdropColor;
            const padding = toPadding(optsAtIndex.backdropPadding);
            ctx.fillRect(
              -width / 2 - padding.left,
              -offset - tickFont.size / 2 - padding.top,
              width + padding.width,
              tickFont.size + padding.height
            );
          }
          renderText(ctx, tick.label, 0, -offset, tickFont, {
            color: optsAtIndex.color,
          });
        });
        ctx.restore();
      }
      drawTitle() {}
    }
    RadialLinearScale.id = 'radialLinear';
    RadialLinearScale.defaults = {
      display: true,
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      grid: {
        circular: false
      },
      startAngle: 0,
      ticks: {
        showLabelBackdrop: true,
        callback: Ticks.formatters.numeric
      },
      pointLabels: {
        backdropColor: undefined,
        backdropPadding: 2,
        display: true,
        font: {
          size: 10
        },
        callback(label) {
          return label;
        },
        padding: 5
      }
    };
    RadialLinearScale.defaultRoutes = {
      'angleLines.color': 'borderColor',
      'pointLabels.color': 'color',
      'ticks.color': 'color'
    };
    RadialLinearScale.descriptors = {
      angleLines: {
        _fallback: 'grid'
      }
    };

    const INTERVALS = {
      millisecond: {common: true, size: 1, steps: 1000},
      second: {common: true, size: 1000, steps: 60},
      minute: {common: true, size: 60000, steps: 60},
      hour: {common: true, size: 3600000, steps: 24},
      day: {common: true, size: 86400000, steps: 30},
      week: {common: false, size: 604800000, steps: 4},
      month: {common: true, size: 2.628e9, steps: 12},
      quarter: {common: false, size: 7.884e9, steps: 4},
      year: {common: true, size: 3.154e10}
    };
    const UNITS = (Object.keys(INTERVALS));
    function sorter(a, b) {
      return a - b;
    }
    function parse(scale, input) {
      if (isNullOrUndef(input)) {
        return null;
      }
      const adapter = scale._adapter;
      const {parser, round, isoWeekday} = scale._parseOpts;
      let value = input;
      if (typeof parser === 'function') {
        value = parser(value);
      }
      if (!isNumberFinite(value)) {
        value = typeof parser === 'string'
          ? adapter.parse(value, parser)
          : adapter.parse(value);
      }
      if (value === null) {
        return null;
      }
      if (round) {
        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)
          ? adapter.startOf(value, 'isoWeek', isoWeekday)
          : adapter.startOf(value, round);
      }
      return +value;
    }
    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      const ilen = UNITS.length;
      for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }
      return UNITS[ilen - 1];
    }
    function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
      for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
          return unit;
        }
      }
      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
    function determineMajorUnit(unit) {
      for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    function addTick(ticks, time, timestamps) {
      if (!timestamps) {
        ticks[time] = true;
      } else if (timestamps.length) {
        const {lo, hi} = _lookup(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
      }
    }
    function setMajorTicks(scale, ticks, map, majorUnit) {
      const adapter = scale._adapter;
      const first = +adapter.startOf(ticks[0].value, majorUnit);
      const last = ticks[ticks.length - 1].value;
      let major, index;
      for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
        index = map[major];
        if (index >= 0) {
          ticks[index].major = true;
        }
      }
      return ticks;
    }
    function ticksFromTimestamps(scale, values, majorUnit) {
      const ticks = [];
      const map = {};
      const ilen = values.length;
      let i, value;
      for (i = 0; i < ilen; ++i) {
        value = values[i];
        map[value] = i;
        ticks.push({
          value,
          major: false
        });
      }
      return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
    }
    class TimeScale extends Scale {
      constructor(props) {
        super(props);
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
        this._unit = 'day';
        this._majorUnit = undefined;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = undefined;
      }
      init(scaleOpts, opts) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        mergeIf(time.displayFormats, adapter.formats());
        this._parseOpts = {
          parser: time.parser,
          round: time.round,
          isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
      }
      parse(raw, index) {
        if (raw === undefined) {
          return null;
        }
        return parse(this, raw);
      }
      beforeLayout() {
        super.beforeLayout();
        this._cache = {
          data: [],
          labels: [],
          all: []
        };
      }
      determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || 'day';
        let {min, max, minDefined, maxDefined} = this.getUserBounds();
        function _applyBounds(bounds) {
          if (!minDefined && !isNaN(bounds.min)) {
            min = Math.min(min, bounds.min);
          }
          if (!maxDefined && !isNaN(bounds.max)) {
            max = Math.max(max, bounds.max);
          }
        }
        if (!minDefined || !maxDefined) {
          _applyBounds(this._getLabelBounds());
          if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
            _applyBounds(this.getMinMax(false));
          }
        }
        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
      }
      _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
          min = arr[0];
          max = arr[arr.length - 1];
        }
        return {min, max};
      }
      buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === 'ticks' && timestamps.length) {
          this.min = this._userMin || timestamps[0];
          this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = _filterBetween(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip
          ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))
          : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined
          : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) {
          ticks.reverse();
        }
        return ticksFromTimestamps(this, ticks, this._majorUnit);
      }
      initOffsets(timestamps) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
          first = this.getDecimalForValue(timestamps[0]);
          if (timestamps.length === 1) {
            start = 1 - first;
          } else {
            start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
          }
          last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
          if (timestamps.length === 1) {
            end = last;
          } else {
            end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
          }
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = _limitValue(start, 0, limit);
        end = _limitValue(end, 0, limit);
        this._offsets = {start, end, factor: 1 / (start + 1 + end)};
      }
      _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = valueOrDefault(timeOpts.stepSize, 1);
        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
        const hasWeekday = isNumber(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) {
          first = +adapter.startOf(first, 'isoWeek', weekday);
        }
        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
        if (adapter.diff(max, min, minor) > 100000 * stepSize) {
          throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
        }
        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
        for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
          addTick(ticks, time, timestamps);
        }
        if (time === max || options.bounds === 'ticks' || count === 1) {
          addTick(ticks, time, timestamps);
        }
        return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
      }
      getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) {
          return adapter.format(value, timeOpts.tooltipFormat);
        }
        return adapter.format(value, timeOpts.displayFormats.datetime);
      }
      _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
        const formatter = options.ticks.callback;
        return formatter ? callback(formatter, [label, index, ticks], this) : label;
      }
      generateTickLabels(ticks) {
        let i, ilen, tick;
        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          tick = ticks[i];
          tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
      }
      getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
      }
      getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
      }
      _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
          w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
          h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
        };
      }
      _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
      }
      getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) {
          return (this._cache.data = metas[0].controller.getAllParsedValues(this));
        }
        for (i = 0, ilen = metas.length; i < ilen; ++i) {
          timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        }
        return (this._cache.data = this.normalize(timestamps));
      }
      getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) {
          return timestamps;
        }
        const labels = this.getLabels();
        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          timestamps.push(parse(this, labels[i]));
        }
        return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
      }
      normalize(values) {
        return _arrayUnique(values.sort(sorter));
      }
    }
    TimeScale.id = 'time';
    TimeScale.defaults = {
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        unit: false,
        round: false,
        isoWeekday: false,
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };

    function interpolate(table, val, reverse) {
      let lo = 0;
      let hi = table.length - 1;
      let prevSource, nextSource, prevTarget, nextTarget;
      if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) {
          ({lo, hi} = _lookupByKey(table, 'pos', val));
        }
        ({pos: prevSource, time: prevTarget} = table[lo]);
        ({pos: nextSource, time: nextTarget} = table[hi]);
      } else {
        if (val >= table[lo].time && val <= table[hi].time) {
          ({lo, hi} = _lookupByKey(table, 'time', val));
        }
        ({time: prevSource, pos: prevTarget} = table[lo]);
        ({time: nextSource, pos: nextTarget} = table[hi]);
      }
      const span = nextSource - prevSource;
      return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
    }
    class TimeSeriesScale extends TimeScale {
      constructor(props) {
        super(props);
        this._table = [];
        this._minPos = undefined;
        this._tableRange = undefined;
      }
      initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
      }
      buildLookupTable(timestamps) {
        const {min, max} = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          curr = timestamps[i];
          if (curr >= min && curr <= max) {
            items.push(curr);
          }
        }
        if (items.length < 2) {
          return [
            {time: min, pos: 0},
            {time: max, pos: 1}
          ];
        }
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          next = items[i + 1];
          prev = items[i - 1];
          curr = items[i];
          if (Math.round((next + prev) / 2) !== curr) {
            table.push({time: curr, pos: i / (ilen - 1)});
          }
        }
        return table;
      }
      _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) {
          return timestamps;
        }
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) {
          timestamps = this.normalize(data.concat(label));
        } else {
          timestamps = data.length ? data : label;
        }
        timestamps = this._cache.all = timestamps;
        return timestamps;
      }
      getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
      }
      getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
      }
    }
    TimeSeriesScale.id = 'timeseries';
    TimeSeriesScale.defaults = TimeScale.defaults;

    var scales = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CategoryScale: CategoryScale,
    LinearScale: LinearScale,
    LogarithmicScale: LogarithmicScale,
    RadialLinearScale: RadialLinearScale,
    TimeScale: TimeScale,
    TimeSeriesScale: TimeSeriesScale
    });

    const registerables = [
      controllers,
      elements,
      plugins,
      scales,
    ];

    /* node_modules/svelte-chartjs/src/Base.svelte generated by Svelte v3.42.4 */

    function create_fragment$4(ctx) {
    	let canvas;
    	let canvas_levels = [/*props*/ ctx[1]];
    	let canvas_data = {};

    	for (let i = 0; i < canvas_levels.length; i += 1) {
    		canvas_data = assign(canvas_data, canvas_levels[i]);
    	}

    	return {
    		c() {
    			canvas = element("canvas");
    			set_attributes(canvas, canvas_data);
    		},
    		m(target, anchor) {
    			insert(target, canvas, anchor);
    			/*canvas_binding*/ ctx[5](canvas);
    		},
    		p(ctx, [dirty]) {
    			set_attributes(canvas, canvas_data = get_spread_update(canvas_levels, [/*props*/ ctx[1]]));
    		},
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(canvas);
    			/*canvas_binding*/ ctx[5](null);
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {
    	Chart.register(...registerables);

    	let { data = {
    		labels: [],
    		datasets: [{ data: [] }],
    		yMarkers: {},
    		yRegions: []
    	} } = $$props;

    	let { type = 'line' } = $$props;
    	let { options = {} } = $$props;
    	let chart = null;
    	let chartRef;
    	let props = clean($$props, ["data", "type", "options"]);

    	onMount(() => {
    		chart = new Chart(chartRef, { type, data, options });
    	});

    	afterUpdate(() => {
    		if (!chart) return;
    		chart.data = data;
    		chart.type = type;
    		chart.options = options;
    		chart.update();
    	});

    	onDestroy(() => {
    		chart = null;
    	});

    	function canvas_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			chartRef = $$value;
    			$$invalidate(0, chartRef);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('data' in $$new_props) $$invalidate(2, data = $$new_props.data);
    		if ('type' in $$new_props) $$invalidate(3, type = $$new_props.type);
    		if ('options' in $$new_props) $$invalidate(4, options = $$new_props.options);
    	};

    	$$props = exclude_internal_props($$props);
    	return [chartRef, props, data, type, options, canvas_binding];
    }

    class Base extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$3, create_fragment$4, safe_not_equal, { data: 2, type: 3, options: 4 });
    	}
    }

    /* node_modules/svelte-chartjs/src/Line.svelte generated by Svelte v3.42.4 */

    function create_fragment$3(ctx) {
    	let base;
    	let current;
    	const base_spread_levels = [/*$$props*/ ctx[0], { type: "line" }];
    	let base_props = {};

    	for (let i = 0; i < base_spread_levels.length; i += 1) {
    		base_props = assign(base_props, base_spread_levels[i]);
    	}

    	base = new Base({ props: base_props });

    	return {
    		c() {
    			create_component(base.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(base, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const base_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(base_spread_levels, [get_spread_object(/*$$props*/ ctx[0]), base_spread_levels[1]])
    			: {};

    			base.$set(base_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(base.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(base.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(base, detaching);
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Line extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$2, create_fragment$3, safe_not_equal, {});
    	}
    }

    /* src/components/Dashboard/Stats/Stats.svelte generated by Svelte v3.42.4 */

    function create_catch_block(ctx) {
    	let p;

    	return {
    		c() {
    			p = element("p");
    			p.textContent = "Statistiken konnten nicht geladen werden :(";
    			attr(p, "class", "error");
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (251:2) {:then stats}
    function create_then_block(ctx) {
    	let line;
    	let current;

    	line = new Line({
    			props: {
    				data: /*stats*/ ctx[1],
    				options: {
    					scales: {
    						x: { ticks: { font: { size: 18 } } },
    						y: {
    							beginAtZero: true,
    							ticks: { font: { size: 18 } }
    						}
    					},
    					plugins: {
    						legend: {
    							position: "bottom",
    							labels: { font: { size: 14 } }
    						}
    					}
    				}
    			}
    		});

    	return {
    		c() {
    			create_component(line.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(line, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(line.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(line.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(line, detaching);
    		}
    	};
    }

    // (249:22)      <LoadingAnimation positionFixed={false}
    function create_pending_block(ctx) {
    	let loadinganimation;
    	let current;
    	loadinganimation = new LoadingAnimation({ props: { positionFixed: false } });

    	return {
    		c() {
    			create_component(loadinganimation.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(loadinganimation, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(loadinganimation.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(loadinganimation.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(loadinganimation, detaching);
    		}
    	};
    }

    function create_fragment$2(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 1,
    		error: 2,
    		blocks: [,,,]
    	};

    	handle_promise(/*calcStats*/ ctx[0](), info);

    	return {
    		c() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Statistiken";
    			t1 = space();
    			info.block.c();
    			attr(div0, "class", "statscontainerheader svelte-3chnvp");
    			attr(div1, "class", "statscontainer svelte-3chnvp");
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div1, t1);
    			info.block.m(div1, info.anchor = null);
    			info.mount = () => div1;
    			info.anchor = null;
    			current = true;
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			update_await_block_branch(info, ctx, dirty);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			info.block.d();
    			info.token = null;
    			info = null;
    		}
    	};
    }

    function startOfMonthMs(timestamp) {
    	const date = new Date(timestamp);
    	return new Date(date.getFullYear(), date.getMonth(), 1).getTime();
    }

    function addMonths(timestamp, monthsCount) {
    	const date = new Date(timestamp);
    	date.setMonth(date.getMonth() + monthsCount);
    	return date.getTime();
    }

    function monthDiff(d1, d2) {
    	var months;
    	months = (d2.getFullYear() - d1.getFullYear()) * 12;
    	months -= d1.getMonth();
    	months += d2.getMonth();
    	return months <= 0 ? 0 : months;
    }

    function cache(stats) {
    	localStorage.setItem("stats", JSON.stringify({ timestamp: new Date().getTime(), stats }));
    }

    function loadFromCache() {
    	const statsFromCache = JSON.parse(localStorage.getItem("stats"));

    	if (statsFromCache !== null && monthDiff(new Date(statsFromCache.timestamp), new Date()) === 0) {
    		return statsFromCache.stats;
    	}

    	return false;
    }

    function instance$1($$self) {
    	const calcStats = async () => {
    		let cachedStats = loadFromCache();

    		if (cachedStats) {
    			return cachedStats;
    		}

    		let rentals = await Database.findCached({
    			fields: ["customer_id", "rented_on", "returned_on"],
    			limit: 1_000_000,
    			selector: Database.selectorBuilder().withDocType("rental").withAny(Database.selectorBuilder().withField("returned_on").greaterThan(0).withField("rented_on").greaterThan(0).buildSelectors()).build()
    		}).then(result => result.docs.map(doc => ({
    			customer_id: doc["customer_id"],
    			timestamp: doc["returned_on"]
    			? doc["returned_on"]
    			: doc["rented_on"]
    		})));

    		let customers = await Database.findCached({
    			fields: ["registration_date"],
    			limit: 1_000_000,
    			selector: Database.selectorBuilder().withDocType("customer").build()
    		}).then(result => result.docs);

    		let items = await Database.findCached({
    			fields: ["added"],
    			limit: 1_000_000,
    			selector: Database.selectorBuilder().withDocType("item").withField("status").isNotEqualTo("deleted").build()
    		}).then(result => result.docs);

    		const timestampLiesInMonthsBefore = (timestamp, before, monthCount) => timestamp < before && timestamp >= addMonths(before, monthCount * -1);

    		const monthYearString = timestamp => {
    			return new Date(timestamp).toLocaleString("de-DE", { month: "short", year: "2-digit" });
    		};

    		const CURRENT_MS = new Date().getTime();
    		const ACTIVE_CUSTOMER_TIMEOUT_MONTHS = 3;
    		const activeCustomerCountsPerMonth = [];
    		const numberOfRentalsCountsPerMonth = [];
    		const newCustomerCountsPerMonth = [];
    		const itemCountPerMonth = [];
    		const labels = [];

    		for (let monthsAgo = monthDiff(new Date(2018, 11), new Date()) + 1; monthsAgo >= 0; monthsAgo--) {
    			// timestamp n months ago
    			const timestampNMonthsAgo = startOfMonthMs(addMonths(CURRENT_MS, monthsAgo * -1));

    			const activeCustomerCount = rentals.// at least one rental during ACTIVE_CUSTOMER_TIMEOUT at time timestampNMonthsAgo
    			filter(rental => timestampLiesInMonthsBefore(rental.timestamp, timestampNMonthsAgo, ACTIVE_CUSTOMER_TIMEOUT_MONTHS)).map(rental => rental.customer_id).// unique customer ids
    			filter((v, i, a) => a.indexOf(v) === i).length;

    			// number of rentals in month of timestampNMonthsAgo
    			const rentalCount = rentals.filter(rental => timestampLiesInMonthsBefore(rental.timestamp, timestampNMonthsAgo, 1)).length;

    			const newCustomerCount = customers.filter(customer => timestampLiesInMonthsBefore(customer.registration_date, timestampNMonthsAgo, 1)).length;
    			const itemCount = items.filter(item => item.added <= addMonths(CURRENT_MS, monthsAgo * -1)).length;
    			labels.push(monthYearString(addMonths(timestampNMonthsAgo, -1)));
    			activeCustomerCountsPerMonth.push(activeCustomerCount);
    			numberOfRentalsCountsPerMonth.push(rentalCount);
    			newCustomerCountsPerMonth.push(newCustomerCount);
    			itemCountPerMonth.push(itemCount);
    		}

    		let stats = {
    			labels,
    			datasets: [
    				{
    					label: "Aktive Nutzer:innen (innerhalb der letzten 3 Monate)",
    					fill: true,
    					lineTension: 0.3,
    					backgroundColor: "rgba(184, 185, 210, .3)",
    					borderColor: "rgb(35, 26, 136)",
    					borderCapStyle: "butt",
    					borderDash: [],
    					borderDashOffset: 0.0,
    					borderJoinStyle: "miter",
    					pointBorderColor: "rgb(35, 26, 136)",
    					pointBackgroundColor: "rgb(255, 255, 255)",
    					pointBorderWidth: 10,
    					pointHoverRadius: 5,
    					pointHoverBackgroundColor: "rgb(0, 0, 0)",
    					pointHoverBorderColor: "rgba(220, 220, 220, 1)",
    					pointHoverBorderWidth: 2,
    					pointRadius: 1,
    					pointHitRadius: 10,
    					data: activeCustomerCountsPerMonth
    				},
    				{
    					label: "Anzahl Ausleihen",
    					fill: true,
    					lineTension: 0.3,
    					backgroundColor: "rgba(225, 204,230, .3)",
    					borderColor: "rgb(205, 130, 158)",
    					borderCapStyle: "butt",
    					borderDash: [],
    					borderDashOffset: 0.0,
    					borderJoinStyle: "miter",
    					pointBorderColor: "rgb(205, 130, 158)",
    					pointBackgroundColor: "rgb(255, 255, 255)",
    					pointBorderWidth: 10,
    					pointHoverRadius: 5,
    					pointHoverBackgroundColor: "rgb(0, 0, 0)",
    					pointHoverBorderColor: "rgba(220, 220, 220,1)",
    					pointHoverBorderWidth: 2,
    					pointRadius: 1,
    					pointHitRadius: 10,
    					data: numberOfRentalsCountsPerMonth
    				},
    				{
    					label: "Neue Nutzer:innen",
    					fill: true,
    					lineTension: 0.3,
    					backgroundColor: "rgba(71, 225, 167, 0.3)",
    					borderColor: "rgb(71, 225, 167)",
    					borderCapStyle: "butt",
    					borderDash: [],
    					borderDashOffset: 0.0,
    					borderJoinStyle: "miter",
    					pointBorderColor: "rgb(71, 225, 167)",
    					pointBackgroundColor: "rgb(255, 255, 255)",
    					pointBorderWidth: 10,
    					pointHoverRadius: 5,
    					pointHoverBackgroundColor: "rgb(0, 0, 0)",
    					pointHoverBorderColor: "rgba(220, 220, 220,1)",
    					pointHoverBorderWidth: 2,
    					pointRadius: 1,
    					pointHitRadius: 10,
    					data: newCustomerCountsPerMonth
    				},
    				{
    					label: "Anzahl Gegenstände",
    					fill: true,
    					lineTension: 0.3,
    					backgroundColor: "rgba(189, 224, 254, 0.3)",
    					borderColor: "rgb(189, 224, 254)",
    					borderCapStyle: "butt",
    					borderDash: [],
    					borderDashOffset: 0.0,
    					borderJoinStyle: "miter",
    					pointBorderColor: "rgb(189, 224, 254)",
    					pointBackgroundColor: "rgb(255, 255, 255)",
    					pointBorderWidth: 10,
    					pointHoverRadius: 5,
    					pointHoverBackgroundColor: "rgb(0, 0, 0)",
    					pointHoverBorderColor: "rgba(220, 220, 220,1)",
    					pointHoverBorderWidth: 2,
    					pointRadius: 1,
    					pointHitRadius: 10,
    					data: itemCountPerMonth
    				}
    			]
    		};

    		cache(stats);
    		return stats;
    	};

    	calcStats();
    	return [calcStats];
    }

    class Stats extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1, create_fragment$2, safe_not_equal, {});
    	}
    }

    /* src/components/Dashboard/Dashboard.svelte generated by Svelte v3.42.4 */

    function create_fragment$1(ctx) {
    	let div2;
    	let div0;
    	let notes;
    	let t;
    	let div1;
    	let stats;
    	let current;
    	notes = new Notes({});
    	stats = new Stats({});

    	return {
    		c() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(notes.$$.fragment);
    			t = space();
    			div1 = element("div");
    			create_component(stats.$$.fragment);
    			attr(div0, "class", "container svelte-1tr6ndy");
    			attr(div1, "class", "container svelte-1tr6ndy");
    			attr(div2, "class", "dashboardcontent svelte-1tr6ndy");
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			mount_component(notes, div0, null);
    			append(div2, t);
    			append(div2, div1);
    			mount_component(stats, div1, null);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(notes.$$.fragment, local);
    			transition_in(stats.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(notes.$$.fragment, local);
    			transition_out(stats.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			destroy_component(notes);
    			destroy_component(stats);
    		}
    	};
    }

    class Dashboard extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$1, safe_not_equal, {});
    	}
    }

    /* src/components/App.svelte generated by Svelte v3.42.4 */

    function create_fragment(ctx) {
    	let logger;
    	let t0;
    	let notificationdisplay;
    	let t1;
    	let div;
    	let navbar;
    	let t2;
    	let router;
    	let current;
    	logger = new Logger_1({});
    	notificationdisplay = new Notifications({});
    	navbar = new Navbar({ props: { tabs: config.map(func) } });
    	router = new Router({ props: { routes: /*routes*/ ctx[0] } });

    	return {
    		c() {
    			create_component(logger.$$.fragment);
    			t0 = space();
    			create_component(notificationdisplay.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(navbar.$$.fragment);
    			t2 = space();
    			create_component(router.$$.fragment);
    			attr(div, "class", "container svelte-zebrrh");
    		},
    		m(target, anchor) {
    			mount_component(logger, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(notificationdisplay, target, anchor);
    			insert(target, t1, anchor);
    			insert(target, div, anchor);
    			mount_component(navbar, div, null);
    			append(div, t2);
    			mount_component(router, div, null);
    			current = true;
    		},
    		p: noop$1,
    		i(local) {
    			if (current) return;
    			transition_in(logger.$$.fragment, local);
    			transition_in(notificationdisplay.$$.fragment, local);
    			transition_in(navbar.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(logger.$$.fragment, local);
    			transition_out(notificationdisplay.$$.fragment, local);
    			transition_out(navbar.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(logger, detaching);
    			if (detaching) detach(t0);
    			destroy_component(notificationdisplay, detaching);
    			if (detaching) detach(t1);
    			if (detaching) detach(div);
    			destroy_component(navbar);
    			destroy_component(router);
    		}
    	};
    }

    const func = tableEditorConfig => ({
    	title: tableEditorConfig.title,
    	route: tableEditorConfig.route
    });

    function instance($$self) {
    	const routes = new Map();

    	config.forEach(tableViewConfig => routes.set(tableViewConfig.route, wrap({
    		component: TableView,
    		props: {
    			columns: tableViewConfig.columns,
    			filters: tableViewConfig.filters,
    			docType: tableViewConfig.docType,
    			inputs: tableViewConfig.inputs,
    			onData: tableViewConfig.onData
    		}
    	})));

    	routes.set("/logs", LogView);
    	routes.set("/settings", wrap({ component: SettingsFormular }));
    	routes.set("/start", wrap({ component: Dashboard }));

    	routes.set("*", wrap({
    		component: {},
    		conditions: [
    			detail => {
    				replace("/start");
    				return false;
    			}
    		]
    	}));

    	Database.onConnected(createIndex);
    	Database.connect();
    	return [routes];
    }

    class App extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance, create_fragment, safe_not_equal, {});
    	}
    }

    // https://github.com/cypress-io/cypress/issues/702
    if ("serviceWorker" in navigator && !window.Cypress) {
      window.addEventListener("load", function () {
        {
          navigator.serviceWorker.register("service-worker.js").then(
            function (registration) {
              // Registration was successful
              console.debug(
                "ServiceWorker registration successful with scope: ",
                registration.scope
              );
            },
            function (err) {
              // registration failed :(
              console.error("ServiceWorker registration failed: ", err);
            }
          );
        }
      });
    }

    var app = new App({
      target: document.body,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
